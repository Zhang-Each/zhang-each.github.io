<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手写神经网络12：LSTM</title>
      <link href="2021/05/18/coding12/"/>
      <url>2021/05/18/coding12/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络12：LSTM"><a href="#手写神经网络12：LSTM" class="headerlink" title="手写神经网络12：LSTM"></a>手写神经网络12：LSTM</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p><p>限于个人水平实在有限，我尽量减少参考网上代码的次数</p></blockquote><h2 id="1-LSTM的基本架构"><a href="#1-LSTM的基本架构" class="headerlink" title="1.LSTM的基本架构"></a>1.LSTM的基本架构</h2><ul><li>LSTM是<code>Long Short Term Memory</code>(长短期记忆模型)，是一种加入了门控单元的RNN，具有更长的“记忆能力”，可以捕捉到序列化输入中的<strong>长距离依赖关系</strong>(比如一个文本中距离很远的两个单词的某种特定关系)</li><li>LSTM的组成单元是在RNN的组成单元的基础上加上了若干个控制单元(也叫做门)对整个单元进行控制，有输入门，输出门，遗忘门等等，同时又有一系列<code>memory cell</code>作为“<strong>长期记忆单元</strong>”，这些cell也要传递到下一个隐层中，用于保存当前输入的长期记忆，其基本组成单元的架构如下图所示：</li></ul><img src="image-20210517203155370.png" alt="LSTM单元" style="zoom:50%;" /><h2 id="2-LSTM的计算过程"><a href="#2-LSTM的计算过程" class="headerlink" title="2.LSTM的计算过程"></a>2.LSTM的计算过程</h2><ul><li>三个门控单元的结果计算</li></ul><p>$$<br>i,f,o=\mathrm{sigmoid}(W_hh_{t-1}+W_xx_t)\quad \text{Three gates}<br>$$</p><ul><li>生成新的记忆单元</li></ul><p>$$<br>g=\tanh(W_hh_{t-1}+W_xx_t))<br>$$</p><ul><li>按照门控单元的内容来控制输出结果，生成新的</li></ul><p>$$<br>c_{t} =f \odot c_{t-1}+i \odot g<br>$$</p><ul><li>生成最终的隐状态：</li></ul><p>$$<br>h_{t} =o \odot \tanh \left(c_{t}\right)<br>$$</p><ul><li>这里的三个<strong>门控单元和记忆单元</strong>分别起到如下作用：<ul><li>记忆单元：暂时生成一个当前输入内容的记忆</li><li>输入门：评估<strong>当前的序列输入$x_t$的重要程度</strong>，将其加权反映到最终记忆单元中</li><li>遗忘门：评估<strong>上一个单元输入的记忆单元的重要程度</strong>，将其加权反映到最终记忆单元中</li><li>输出门：将最终的记忆单元和隐状态区分开，因为最终记忆单元中的很多序列信息是<strong>没有必要暴露到隐藏状态</strong>中的，输出门就是来评估<strong>有多少信息可以从最终记忆单元传递到隐状态中</strong></li></ul></li><li>整个计算过程可以用一张图来表示：</li></ul><img src="image-20210517203753682.png" alt="LSTM计算过程" style="zoom:50%;" /><h2 id="3-LSTM的前向传播实现"><a href="#3-LSTM的前向传播实现" class="headerlink" title="3.LSTM的前向传播实现"></a>3.LSTM的前向传播实现</h2><ul><li>我们发现跟RNN相比，LSTM还多了三个门控单元和一个记忆单元需要处理，并且这些组件的值都需要用输入的$x_t$和$h_{t-1}$用类似的方法计算，非常麻烦，因此CS231N的assignment3里面采取了这样的trick来解决计算太麻烦的问题：<ul><li>将用来处理$x_t,h_{t-1}$的权重矩阵的列数扩大四倍，再将结果$A$按照列进行四等分，分别用sigmoid和tanh函数处理之后生成三个门$i，f，o$以及新的记忆单元$g$，然后按公式分别计算并合并</li><li>求梯度的时候分别求出$i，f，o$和$g$的梯度然后合并成$A$的梯度</li></ul></li><li>因此LSTM单元的前向传播可以用下面这个函数<code>lstm_step_forward</code>来实现：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">lstm_step_forward</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> prev_h<span class="token punctuation">,</span> prev_c<span class="token punctuation">,</span> Wx<span class="token punctuation">,</span> Wh<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Forward pass for a single time step of an LSTM.    Inputs:    - x: Input data, of shape (N, D)    - prev_h: Previous hidden state, of shape (N, H)    - prev_c: previous cell state, of shape (N, H)    - Wx: Input-to-hidden weights, of shape (D, 4H)    - Wh: Hidden-to-hidden weights, of shape (H, 4H)    - b: Biases, of shape (4H,)    Returns a tuple of:    - next_h: Next hidden state, of shape (N, H)    - next_c: Next cell state, of shape (N, H)    - cache: Tuple of values needed for backward pass.    """</span>    next_h<span class="token punctuation">,</span> next_c<span class="token punctuation">,</span> cache <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span>    N<span class="token punctuation">,</span> H <span class="token operator">=</span> prev_h<span class="token punctuation">.</span>shape    A <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>x<span class="token punctuation">,</span> Wx<span class="token punctuation">)</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>prev_h<span class="token punctuation">,</span> Wh<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># 分割成四等份，每一份的size都是N * H</span>    ai<span class="token punctuation">,</span> af<span class="token punctuation">,</span> ao<span class="token punctuation">,</span> ag <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">:</span> H<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> H<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token operator">*</span> H<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> H<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token operator">*</span> H<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> H<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token operator">*</span> H<span class="token punctuation">]</span>    i<span class="token punctuation">,</span> f<span class="token punctuation">,</span> o<span class="token punctuation">,</span> g <span class="token operator">=</span> sigmoid<span class="token punctuation">(</span>ai<span class="token punctuation">)</span><span class="token punctuation">,</span> sigmoid<span class="token punctuation">(</span>af<span class="token punctuation">)</span><span class="token punctuation">,</span> sigmoid<span class="token punctuation">(</span>ao<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>ag<span class="token punctuation">)</span>    <span class="token comment"># 按公式一步步进行计算</span>    next_c <span class="token operator">=</span> f <span class="token operator">*</span> prev_c <span class="token operator">+</span> i <span class="token operator">*</span> g    next_h <span class="token operator">=</span> o <span class="token operator">*</span> np<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>next_c<span class="token punctuation">)</span>    cache <span class="token operator">=</span> <span class="token punctuation">(</span>next_c<span class="token punctuation">,</span> g<span class="token punctuation">,</span> o<span class="token punctuation">,</span> f<span class="token punctuation">,</span> i<span class="token punctuation">,</span> A<span class="token punctuation">,</span> prev_c<span class="token punctuation">,</span> prev_h<span class="token punctuation">,</span> Wh<span class="token punctuation">,</span> Wx<span class="token punctuation">,</span> x<span class="token punctuation">)</span>    <span class="token keyword">return</span> next_h<span class="token punctuation">,</span> next_c<span class="token punctuation">,</span> cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>而LSTM整体的前向传播和普通的RNN没有什么区别，这里就不重复了。</li></ul><h2 id="4-LSTM的反向传播的实现"><a href="#4-LSTM的反向传播的实现" class="headerlink" title="4. LSTM的反向传播的实现"></a>4. LSTM的反向传播的实现</h2><ul><li>LSTM的反向传播过程中，依然遵循RNN的反向传播的基本形式，即时间反向传播，在计算梯度的时候需要考虑后一个隐状态传递回来的梯度，并且需要对$i,o,f,g$分别求梯度然后拼成一个完整的A的梯度，再对A下属的几个参数矩阵进行求导进行反向传播，最终实现LSTM反向传播的代码如下(这里的公式推导和RNN没有本质区别，难点在于把四个梯度矩阵拼接成一个，其他地方的导数还是很好求的)：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">lstm_step_backward</span><span class="token punctuation">(</span>dnext_h<span class="token punctuation">,</span> dnext_c<span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Backward pass for a single time step of an LSTM.    Inputs:    - dnext_h: Gradients of next hidden state, of shape (N, H)    - dnext_c: Gradients of next cell state, of shape (N, H)    - cache: Values from the forward pass    Returns a tuple of:    - dx: Gradient of input data, of shape (N, D)    - dprev_h: Gradient of previous hidden state, of shape (N, H)    - dprev_c: Gradient of previous cell state, of shape (N, H)    - dWx: Gradient of input-to-hidden weights, of shape (D, 4H)    - dWh: Gradient of hidden-to-hidden weights, of shape (H, 4H)    - db: Gradient of biases, of shape (4H,)    """</span>    next_c<span class="token punctuation">,</span> g<span class="token punctuation">,</span> o<span class="token punctuation">,</span> f<span class="token punctuation">,</span> i<span class="token punctuation">,</span> A<span class="token punctuation">,</span> prev_c<span class="token punctuation">,</span> prev_h<span class="token punctuation">,</span> Wh<span class="token punctuation">,</span> Wx<span class="token punctuation">,</span> x <span class="token operator">=</span> cache    dnext_c <span class="token operator">+=</span> dnext_h <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> np<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>next_c<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> o    dprev_c <span class="token operator">=</span> np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>dnext_c<span class="token punctuation">,</span> f<span class="token punctuation">)</span>    <span class="token comment"># 分别求出四部分的梯度然后进行合并</span>    df <span class="token operator">=</span> dnext_c <span class="token operator">*</span> prev_c <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> f<span class="token punctuation">)</span> <span class="token operator">*</span> f    di <span class="token operator">=</span> dnext_c <span class="token operator">*</span> g <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">*</span> i    dg <span class="token operator">=</span> dnext_c <span class="token operator">*</span> i <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> g <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>    do <span class="token operator">=</span> dnext_h <span class="token operator">*</span> np<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>next_c<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> o<span class="token punctuation">)</span> <span class="token operator">*</span> o    dA <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>di<span class="token punctuation">,</span> df<span class="token punctuation">,</span> do<span class="token punctuation">,</span> dg<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 得到一个 N * 4H的梯度矩阵</span>    dWx <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>x<span class="token punctuation">.</span>T<span class="token punctuation">,</span> dA<span class="token punctuation">)</span>    dx <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>dA<span class="token punctuation">,</span> Wx<span class="token punctuation">.</span>T<span class="token punctuation">)</span>    dWh <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>prev_h<span class="token punctuation">.</span>T<span class="token punctuation">,</span> dA<span class="token punctuation">)</span>    dprev_h <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>dA<span class="token punctuation">,</span> Wh<span class="token punctuation">.</span>T<span class="token punctuation">)</span>    db <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dA<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> dx<span class="token punctuation">,</span> dprev_h<span class="token punctuation">,</span> dprev_c<span class="token punctuation">,</span> dWx<span class="token punctuation">,</span> dWh<span class="token punctuation">,</span> db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>LSTM的整个序列的反向传播和RNN也类似，这里就不放基本重复的代码了，至此我们完成了RNN和LSTM的基本单元的前向传播和反向传播的底层代码的实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络11：RNN</title>
      <link href="2021/05/18/coding11/"/>
      <url>2021/05/18/coding11/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络11：RNN"><a href="#手写神经网络11：RNN" class="headerlink" title="手写神经网络11：RNN"></a>手写神经网络11：RNN</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p><p>限于个人水平实在有限，我尽量减少参考网上代码的次数</p></blockquote><h2 id="1-RNN的结构"><a href="#1-RNN的结构" class="headerlink" title="1.RNN的结构"></a>1.RNN的结构</h2><ul><li>RNN指的是循环神经网络，是一种设计出来用于<strong>处理序列化数据(比如自然语言，时序数据)的神经网络</strong>，RNN可以保留一定的上下文信息并将序列前面的信息不断向后面传递。</li><li>RNN的架构如下图所示，主要包含一个输入层，一个隐层和一个输出层，隐层单元的隐状态$h_t$也会不断向下一个隐层单元传递。</li></ul><img src="image-20210517185038311.png" alt="RNN架构图" style="zoom:50%;" /><ul><li>RNN的隐状态更新公式可以表示为：</li></ul><p>$$<br>h_t=\sigma(W_xx_{t}+W_hh_{t-1}+b)<br>$$</p><ul><li>这里的<strong>可学习参数</strong>包括$W_x,W_h,b$，分别是两个权重矩阵和一个bias向量，而激活函数通常使用双曲正切tanh函数，而最终的输出结果的计算方式是：</li></ul><p>$$<br>y_t=\mathrm{softmax}(W_sh_t)<br>$$</p><h2 id="2-RNN的前向传播及实现"><a href="#2-RNN的前向传播及实现" class="headerlink" title="2.RNN的前向传播及实现"></a>2.RNN的前向传播及实现</h2><ul><li>从RNN的架构可以看出，我们输入RNN的数据是一个序列$X=(x_1,x_2,\dots,x_T)$，这个序列需要在RNN中按照顺序逐渐前向传播，最终得到一个隐状态的序列$H=(h_1,h_2,\dots,h_T)$，而每一个单元内的前向传播过程可以用函数<code>rnn_step_forward</code>来描述</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">rnn_step_forward</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> prev_h<span class="token punctuation">,</span> Wx<span class="token punctuation">,</span> Wh<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    The input data has dimension D, the hidden state has dimension H,    and the minibatch is of size N.    Inputs:    - x: Input data for this timestep, of shape (N, D)    - prev_h: Hidden state from previous timestep, of shape (N, H)    - Wx: Weight matrix for input-to-hidden connections, of shape (D, H)    - Wh: Weight matrix for hidden-to-hidden connections, of shape (H, H)    - b: Biases of shape (H,)    Returns a tuple of:    - next_h: Next hidden state, of shape (N, H)    - cache: Tuple of values needed for the backward pass.    """</span>    next_h <span class="token operator">=</span> np<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>prev_h<span class="token punctuation">,</span> Wh<span class="token punctuation">)</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>x<span class="token punctuation">,</span> Wx<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">)</span>    cache <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> prev_h<span class="token punctuation">,</span> Wx<span class="token punctuation">,</span> Wh<span class="token punctuation">,</span> b<span class="token punctuation">,</span> next_h<span class="token punctuation">)</span>    <span class="token keyword">return</span> next_h<span class="token punctuation">,</span> cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>而整个序列的前向传播需要使用一个循环来完成，因此<strong>RNN的训练不能并行化</strong>，这也是RNN的一个重大缺点。我们使用一个函数来描述整个序列在RNN中的前向传播过程：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">rnn_forward</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> h0<span class="token punctuation">,</span> Wx<span class="token punctuation">,</span> Wh<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    We assume an input sequence composed of T vectors, each of dimension D.    The RNN uses a hidden size of H, and we work over a minibatch containing    N sequences. After running the RNN forward,    Inputs:    - x: Input data for the entire time series, of shape (N, T, D)    - h0: Initial hidden state, of shape (N, H)    """</span>    h<span class="token punctuation">,</span> cache <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    N<span class="token punctuation">,</span> T<span class="token punctuation">,</span> D <span class="token operator">=</span> x<span class="token punctuation">.</span>shape    N<span class="token punctuation">,</span> H <span class="token operator">=</span> h0<span class="token punctuation">.</span>shape    <span class="token comment"># 最终生成的一个隐状态</span>    h <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> T<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">)</span>    next_h <span class="token operator">=</span> h0    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>        x_step <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>N<span class="token punctuation">,</span> D<span class="token punctuation">)</span>        next_h<span class="token punctuation">,</span> cache_step <span class="token operator">=</span> rnn_step_forward<span class="token punctuation">(</span>x_step<span class="token punctuation">,</span> next_h<span class="token punctuation">,</span> Wx<span class="token punctuation">,</span> Wh<span class="token punctuation">,</span> b<span class="token punctuation">)</span>        h<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> next_h        <span class="token comment"># cache用来保存每个单元中的有效信息，用于反向传播过程中的导数计算</span>        cache<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cache_step<span class="token punctuation">)</span>    <span class="token keyword">return</span> h<span class="token punctuation">,</span> cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>RNN的前向传播总体来说比较简单。</li></ul><h2 id="3-RNN的反向传播及实现"><a href="#3-RNN的反向传播及实现" class="headerlink" title="3.RNN的反向传播及实现"></a>3.RNN的反向传播及实现</h2><ul><li>RNN的反向传播和CNN等传统神经网络不同，是一种<strong>“时间”上的反向传播</strong>，也就是说在计算梯度并更新参数的时候，不仅要考虑从最上层的loss函数中传递下来的梯度，<strong>也要考虑从后面一个隐层单元(从前向传播的时间来看要更迟，所以被称为时间反向传播)传递下来的梯度</strong></li><li>而对于各个参数，其梯度的计算方式如下(注意tanh函数导数的特殊性)：</li></ul><p>$$<br>s_t=W_xx_{t}+W_hh_{t-1}+b,\quad h_t=\tanh(s_t)<br>$$</p><p>$$<br>\frac{\partial h_t}{\partial s_t}=1-\tanh^2(s_t)<br>$$</p><p>$$<br>\frac{\partial s_t}{\partial W_x}=x_t^T<br>$$</p><p>$$<br>\frac{\partial s_t}{\partial W_h}=h_{t-1}^T<br>$$</p><p>$$<br>\frac{\partial s_t}{\partial x_t}=W_x^T<br>$$</p><p>$$<br>\frac{\partial s_t}{\partial h_{t-1}}=W_h^T<br>$$</p><ul><li>根据这些公式和梯度的链式法则，我们可以写出一个隐层单元中的反向传播过程，用一个函数<code>rnn_step_backward</code>来表示</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">rnn_step_backward</span><span class="token punctuation">(</span>dnext_h<span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Backward pass for a single time step of a vanilla RNN.    Inputs:    - dnext_h: Gradient of loss with respect to next hidden state, of shape (N, H)    - cache: Cache object from the forward pass    Returns a tuple of:    - dx: Gradients of input data, of shape (N, D)    - dprev_h: Gradients of previous hidden state, of shape (N, H)    - dWx: Gradients of input-to-hidden weights, of shape (D, H)    - dWh: Gradients of hidden-to-hidden weights, of shape (H, H)    - db: Gradients of bias vector, of shape (H,)    """</span>    dx<span class="token punctuation">,</span> dprev_h<span class="token punctuation">,</span> dWx<span class="token punctuation">,</span> dWh<span class="token punctuation">,</span> db <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span>    x<span class="token punctuation">,</span> prev_h<span class="token punctuation">,</span> Wx<span class="token punctuation">,</span> Wh<span class="token punctuation">,</span> b<span class="token punctuation">,</span> next_h <span class="token operator">=</span> cache    ds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> next_h <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> dnext_h  <span class="token comment"># ds的大小是N*H</span>    db <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>ds<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    dWh <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>prev_h<span class="token punctuation">.</span>T<span class="token punctuation">,</span> ds<span class="token punctuation">)</span>    dWx <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>x<span class="token punctuation">.</span>T<span class="token punctuation">,</span> ds<span class="token punctuation">)</span>    dprev_h <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>ds<span class="token punctuation">,</span> Wh<span class="token punctuation">.</span>T<span class="token punctuation">)</span>    dx <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>ds<span class="token punctuation">,</span> Wx<span class="token punctuation">.</span>T<span class="token punctuation">)</span>    <span class="token keyword">return</span> dx<span class="token punctuation">,</span> dprev_h<span class="token punctuation">,</span> dWx<span class="token punctuation">,</span> dWh<span class="token punctuation">,</span> db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>而RNN整体的反向传播也需要一个序列来完成，同时考虑从输出层的loss函数传递下来的梯度和从后一个隐藏单元传递下来的梯度，并使用函数<code>rnn_step_backward</code>来完成单个隐状态的更新。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">rnn_backward</span><span class="token punctuation">(</span>dh<span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Inputs:    - dh: Upstream gradients of all hidden states, of shape (N, T, H)    NOTE: 'dh' contains the upstream gradients produced by the     individual loss functions at each time step, *not* the gradients    being passed between time steps (which you'll have to compute yourself    by calling rnn_step_backward in a loop).    """</span>   N<span class="token punctuation">,</span> T<span class="token punctuation">,</span> H <span class="token operator">=</span> dh<span class="token punctuation">.</span>shape    D <span class="token operator">=</span> cache<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    dx <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> T<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">)</span>    dh0 <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">)</span>    dWx <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>D<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">)</span>    dWh <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">)</span>    db <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>    dh_prev <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> H<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>T <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 这一步特别重要，将两个方向传递过来的梯度融合</span>        dh_step <span class="token operator">=</span> dh<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> dh_prev        dx_step<span class="token punctuation">,</span> dh_prev<span class="token punctuation">,</span> dwx<span class="token punctuation">,</span> dwh<span class="token punctuation">,</span> db_step <span class="token operator">=</span> rnn_step_backward<span class="token punctuation">(</span>dh_step<span class="token punctuation">,</span> cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        dx<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> dx_step        dh0 <span class="token operator">=</span> dh_prev        dWx <span class="token operator">+=</span> dwx        dWh <span class="token operator">+=</span> dwh        db <span class="token operator">+=</span> db_step    <span class="token keyword">return</span> dx<span class="token punctuation">,</span> dh0<span class="token punctuation">,</span> dWx<span class="token punctuation">,</span> dWh<span class="token punctuation">,</span> db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-RNN的缺点"><a href="#4-RNN的缺点" class="headerlink" title="4.RNN的缺点"></a>4.RNN的缺点</h2><ul><li>从上面的代码实现中可以看出，RNN一个很大的缺点就是对于一个序列必须串行化训练，不能并行训练，造成训练的速度非常缓慢，同时RNN也存在梯度爆炸和梯度消失的问题，对于<strong>长距离的依赖关系也缺乏学习的能力</strong>，这些问题的具体分析可以在CS224N的相关笔记中看到</li><li>拥有门控单元的RNN可以在一定程度上解决这个问题，比如LSTM</li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络10：优化器</title>
      <link href="2021/05/18/coding10/"/>
      <url>2021/05/18/coding10/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络10：优化器"><a href="#手写神经网络10：优化器" class="headerlink" title="手写神经网络10：优化器"></a>手写神经网络10：优化器</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p><p>限于个人水平实在有限，我尽量减少参考网上代码的次数</p></blockquote><h2 id="1-神经网络的训练"><a href="#1-神经网络的训练" class="headerlink" title="1.神经网络的训练"></a>1.神经网络的训练</h2><ul><li>神经网络的参数学习的总原则是用反向传播求出梯度，然后用梯度下降的方法对参数进行更新，而对于神经网络的训练的主要改进，就是对梯度下降的方法进行改进，最直接的批梯度下降会带来巨大的运算量，而<strong>随机梯度下降</strong>的出现解决了直接对整个数据集进行梯度下降求解时计算量过大的问题。</li><li>前面在《手写神经网络4》中我们已经实现了一个SGD优化器对神经网络中的参数进行随机梯度下降的优化，<ul><li>而SGD虽然相比于梯度下降<strong>对训练速度有了比较大的提升</strong>，但是计算出的梯度受数据的影响比较大(因为只有一个)，可能会因为数据分布的问题</li><li>对于收敛速度来说，由于随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解</li><li>随机梯度下降的计算密度也比较高，仍然可以继续改进</li></ul></li><li>因此在SGD的基础上，衍生出了若干种改进的训练方法<ul><li>动量随机梯度下降</li><li>RMSProp算法</li><li>Adam算法</li></ul></li></ul><h2 id="2-动量随机梯度下降"><a href="#2-动量随机梯度下降" class="headerlink" title="2.动量随机梯度下降"></a>2.动量随机梯度下降</h2><h2 id="3-RMSProp算法"><a href="#3-RMSProp算法" class="headerlink" title="3.RMSProp算法"></a>3.RMSProp算法</h2><h2 id="4-Adam算法"><a href="#4-Adam算法" class="headerlink" title="4.Adam算法"></a>4.Adam算法</h2>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021春招实习-Java语法和底层原理</title>
      <link href="2021/05/16/intern3/"/>
      <url>2021/05/16/intern3/</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分：Java的语法和数据结构的底层细节"><a href="#第一部分：Java的语法和数据结构的底层细节" class="headerlink" title="第一部分：Java的语法和数据结构的底层细节"></a>第一部分：Java的语法和数据结构的底层细节</h2><h3 id="1-0-Java的循环"><a href="#1-0-Java的循环" class="headerlink" title="1.0 Java的循环"></a>1.0 Java的循环</h3><ul><li><p>Java的循环方式有for使用下标循环，for-each循环，while循环和迭代器循环</p><ul><li>使用下标和while完成循环是最常见的方式，对于数组或者collection都通用</li><li>for-each循环是Java1.5之后带来的语法糖，可以用一个变量来遍历该类型的一个可迭代的结构，比如数组和集合</li><li>iterator是一些结构提供的一个迭代器，可以用hasNext来判断是否到了末尾，并依次进行迭代</li></ul></li><li><p>在Collection框架的数据结构下，如果使用for-each对一个容器进行遍历，那么在编译之后这一段for循环在class文件中会被优化成迭代器的形式</p><ul><li>也就是说for-each语句是通过迭代器实现的<h4 id="1-0-1-for-each循环的坑"><a href="#1-0-1-for-each循环的坑" class="headerlink" title="1.0.1 for-each循环的坑"></a>1.0.1 for-each循环的坑</h4></li></ul></li><li><p>for-each循环是通过迭代器实现的，而Collection又一个fail-fast机制，如果有多个线程对同一个集合的内容进行操作的话就可能产生fail-fast，比如当一个线程A通过Iterator去遍历集合的时候，如果这个集合的内容被其他的线程改变了，那么迭代器访问集合的时候会抛出异常</p></li><li><p>迭代器工作在一个独立的线程中，并且拥有一个mutex锁，通过访问一个单向的索引链表来遍历所有的元素，如果原本的collection中的元素数量发生变化，索引表并不会同步这一变化，因此可能造成对象的遗失。比如遍历一个集合的时候如果remove了元素可能就会发生异常。</p><ul><li>也就是说迭代器工作的过程中不允许被迭代的对象发生改变。<h4 id="1-0-2-效率问题"><a href="#1-0-2-效率问题" class="headerlink" title="1.0.2 效率问题"></a>1.0.2 效率问题</h4></li></ul></li><li><p>一般来说如果是可以随机访问的结构，比如说数组，那么直接食用for循环的效率将高于for-each循环，反过来如果只能进行顺序访问，比如链表，那么for-each循环的效率就会更高。</p><h3 id="1-1-Java的STL-Collection"><a href="#1-1-Java的STL-Collection" class="headerlink" title="1.1 Java的STL(Collection)"></a>1.1 Java的STL(Collection)</h3></li><li><p>Java标准库中提供的常用数据结构和算法的模版有Vector，Stack，Queue，List，Set，Map等等，其中List，Set和Map又是Java的Collection大框架下的</p></li><li><p>以下是我在用Java刷Leetcode的过程中碰到的一些常见Collection的总结</p></li></ul><h4 id="1-1-1-List"><a href="#1-1-1-List" class="headerlink" title="1.1.1 List"></a>1.1.1 List</h4><ul><li><p>List是一个继承了Collection的接口，底下有具体实现的类ArrayList和LinkedList，一般创建List对象的时候都需要用ArrayList或者LinkedList来具体实现，添加元素用add，获取元素用get</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>ArrayList和LinkedList的区别在于<strong>底层实现方式的不同</strong>，从名字中就可以看出一个是用数组实现的，一个是用链表实现的，值得注意的是LinkedList的底层是一个<strong>双向链表</strong></p><ul><li><strong>相比于ArrayList，LinkedList的增删更快，而插入更慢，因此更具实际操作的需要可以确定具体选用哪种List的具体实现来提高代码的性能</strong></li><li>Vector和ArrayList一样，都是通过数组实现的，但是Vector是线程安全的<h4 id="1-1-2-Vector"><a href="#1-1-2-Vector" class="headerlink" title="1.1.2 Vector"></a>1.1.2 Vector</h4></li></ul></li><li><p>Vector是一类动态数组，和ArrayList比较类似，用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况</p><ul><li>Vector也是实现了List的接口</li></ul></li><li><p>Vector添加元素用add方法或者addElement，获取元素用elementAt方法</p><h4 id="1-1-3-Stack与Queue"><a href="#1-1-3-Stack与Queue" class="headerlink" title="1.1.3 Stack与Queue"></a>1.1.3 Stack与Queue</h4></li><li><p>Java提供的实现了栈和队列的数据结构，实际上都是一种List接口的具体实现，其中<strong>Stack是Vector的一个子类</strong>，提供了push，pop和peek等方法</p></li><li><p>LinkedList类实现了Queue接口，因此可以用LinkedList来创建一个队列，队列提供了offer和add方法在末尾插入元素，同时提供了poll方法移除队列首部的元素</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="1-2-HashMap的底层实现"><a href="#1-2-HashMap的底层实现" class="headerlink" title="1.2 HashMap的底层实现"></a>1.2 HashMap的底层实现</h3><h4 id="1-2-1-基本结构"><a href="#1-2-1-基本结构" class="headerlink" title="1.2.1 基本结构"></a>1.2.1 基本结构</h4><ul><li>总体原则：<strong>先扩容，再变树，先数组，后链表</strong></li><li>Java的HashMap实现了自Map抽象类，用<strong>数组+链表+红黑树</strong>来实现，数组用于存储元素的内容，链表用于解决hash时产生的冲突<ul><li>如果链表长度大于阈值8但是当前数组长度小于树化的阈值64就会进行扩容，每次扩大两倍，如果数组的长度大于树化阈值64，链表就转变成红黑树</li><li>默认的初始容量是16，负载因子默认是0.75，当Map的当前容量大于总容量*负载因子的时候就要进行扩容的操作，并且扩容成原来的两倍</li></ul></li></ul><h4 id="1-2-2-HashMap和HashTable的区别"><a href="#1-2-2-HashMap和HashTable的区别" class="headerlink" title="1.2.2 HashMap和HashTable的区别"></a>1.2.2 HashMap和HashTable的区别</h4><ul><li>HashTable<strong>没有树化操作</strong>，只有数组+链表<ul><li>HashTable在扩容的时候是2n+1的规则，而且初始的默认容量是11</li></ul></li><li>在hash发生冲突的时候，hashmap使用<strong>尾插法</strong>插入链表，而table使用<strong>头插法</strong>插入链表</li><li>map是线程不安全的，而table用了synchronized关键字，所以是线程安全的</li></ul><h4 id="1-2-3-ConcurrentHashMap"><a href="#1-2-3-ConcurrentHashMap" class="headerlink" title="1.2.3 ConcurrentHashMap"></a>1.2.3 ConcurrentHashMap</h4><ul><li>通过<strong>synchronized关键字</strong>和CAS操作<strong>实现线程安全</strong>，如果插入的槽没有数据则使用CAS如果插入的槽有数据那么就可以通过synchronized关键字锁住链表的头节点从而实现效率和线程安全</li></ul><h4 id="1-2-4-冲突解决和具体实现"><a href="#1-2-4-冲突解决和具体实现" class="headerlink" title="1.2.4 冲突解决和具体实现"></a>1.2.4 冲突解决和具体实现</h4><ul><li>hash产生冲突的时候常见的处理办法有开放定址法(比如使用线性探测和平方探测)，也有rehash的办法和链地址法，hashmap采用的是链地址的方法，也就是数组+链表的方法</li><li>hashmap的主体是一个entry数组，每个entry是一个key-value对，如果定位到的数组位置没有链表，那么就很简单只需要一次寻址就查到了，如果包含链表那么就说明这个位置产生了hash冲突，链表上的点都对应着同一个hash函数值，那么就需要遍历链表进行插入删除等操作</li><li>处于性能的考虑，hashmap的链表出现的越少越好。</li></ul><h3 id="1-3-HashSet和TreeSet"><a href="#1-3-HashSet和TreeSet" class="headerlink" title="1.3 HashSet和TreeSet"></a>1.3 HashSet和TreeSet</h3><ul><li><p>这是Java的collection框架下Set接口的两种具体实现，所有的Set都是不包含重复元素的</p><h4 id="1-3-1-HashSet"><a href="#1-3-1-HashSet" class="headerlink" title="1.3.1 HashSet"></a>1.3.1 HashSet</h4></li><li><p>HashSet底层是通过hash表来实现的，存储的元素是无序的，并且是不同步的，需要外部保持线程之间的同步问题，集合中元素的值允许事null，而通过构造函数可以知道，HashSet的底层是通过HashMap来实现的</p></li><li><p>HashSet实际上就是一个阉割了一些功能的HashMap</p></li><li><p>LinkedHashSet在HashSet的基础之上保留了插入的顺序</p><h4 id="1-3-2-TreeSet"><a href="#1-3-2-TreeSet" class="headerlink" title="1.3.2 TreeSet"></a>1.3.2 TreeSet</h4></li><li><p>TreeSet中的元素是有序存放的，因此必须要是可比较大小的元素才可以在TreeSet中存储，换句话说就是需要实现Comparable接口</p></li><li><p>TreeSet中的元素是不重复并且排好序的，默认采用升序排列，也可以进行自定义的排序。</p></li></ul><h3 id="1-4-并发与多线程"><a href="#1-4-并发与多线程" class="headerlink" title="1.4 并发与多线程"></a>1.4 并发与多线程</h3><ul><li><p>Java实现多线程并发的方式有三种：</p><ul><li>实现runnable接口</li><li>继承Thread类</li><li>实现Callable接口</li></ul></li><li><p>Java中的线程有New，Runnable,Blocked,Waiting,Timed-Waiting和Terminated等多种状态</p></li><li><p>实现Java的并发编程需要关注线程之间的同步和死锁，而同步往往可以</p><h4 id="1-4-1-synchronized关键字"><a href="#1-4-1-synchronized关键字" class="headerlink" title="1.4.1 synchronized关键字"></a>1.4.1 synchronized关键字</h4></li><li><p>synchronized方法可以修饰变量、方法和类</p><ul><li>synchronized解决的是执行控制的问题，当有线程在使用一个synchronized的方法的时候，会阻止其他线程调用这个方法，等该调用结束之后才允许下一个线程调用</li><li>使用synchronized修饰的东西无法并发执行</li></ul></li></ul><h4 id="1-4-2-volatile关键字"><a href="#1-4-2-volatile关键字" class="headerlink" title="1.4.2 volatile关键字"></a>1.4.2 volatile关键字</h4><ul><li><p>Volatile关键字解决的是<strong>内存可见</strong>性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求</p></li><li><p>volatile就是标记一个变量存储在主内存中，堆该类型变量的每次读操作都会直接从计算机的主存中读取，而不是从CPU中读取</p><h4 id="1-4-3-二者的区别"><a href="#1-4-3-二者的区别" class="headerlink" title="1.4.3 二者的区别"></a>1.4.3 二者的区别</h4></li><li><p>volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住</p></li><li><p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</p></li><li><p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</p></li><li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞</p></li><li><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p></li></ul><h2 id="第二部分：JVM相关"><a href="#第二部分：JVM相关" class="headerlink" title="第二部分：JVM相关"></a>第二部分：JVM相关</h2><h3 id="2-1-JVM垃圾回收机制-GC"><a href="#2-1-JVM垃圾回收机制-GC" class="headerlink" title="2.1  JVM垃圾回收机制 GC"></a>2.1  JVM垃圾回收机制 GC</h3><h4 id="2-1-1-常见的回收判断算法"><a href="#2-1-1-常见的回收判断算法" class="headerlink" title="2.1.1 常见的回收判断算法"></a>2.1.1 常见的回收判断算法</h4><ul><li><p>要回收首先需要使用算法来<strong>判断对象是否可以回收</strong></p><ul><li><p>引用计数算法：记录每个对象被引用的次数，如果引用的次数为0就说明需要回收内存但事实上Java用的并不是这种策略，可以用下面一段代码来说明</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> refGC <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1MB <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bigMem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> _1MB<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        refGC a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">refGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">refGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span>instance <span class="token operator">=</span> b<span class="token punctuation">;</span>        b<span class="token punctuation">.</span>instance <span class="token operator">=</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>这段代码中虽然AB互相引用了，但是事实上还是作为垃圾被回收了，说明Java使用的并不是引用计数的策略</p></li></ul></li><li><p><strong>可达性分析算法</strong>：Java中使用的方法：<strong>GC-root</strong></p><ul><li>用一个对象作为GC-Roots，每次垃圾回收层root开始向下搜索，搜索的路径称为<strong>引用链</strong></li><li>如果一个对象和root之间没有任何引用链，那么就需要进行回收</li><li>Java语言中可以作为root的对象包括<ul><li>虚拟机栈中应用的对象</li><li>方法区类静态属性引用的对象</li><li>方法区常量引用的对象</li><li>本地方法栈中本地方法引用的对象</li></ul></li><li>对象被回收的时候，可以用<strong>finalize方法</strong>进行“自救”</li></ul></li><li><p>引用的多种类型</p><ul><li><strong>强引用</strong>，只要强引用还存在，就不能把对象作为垃圾来回收，new出来的就是强引用</li><li><strong>软引用</strong>：用来描述一些还有用但是并非必须的对象，软引用的关联的对象在系统将要发生内存溢出的异常之前，会对它们进行二次回收，之后还不行再抛出OOM异常</li><li>弱引用：描述非必须的对象，引用的强度比软引用还要弱，垃圾回收的时候一定会回收掉只有弱引用的对象</li><li>虚引用：最弱的引用，基本没啥用</li></ul></li></ul><h4 id="2-1-2-垃圾回收算法"><a href="#2-1-2-垃圾回收算法" class="headerlink" title="2.1.2 垃圾回收算法"></a>2.1.2 垃圾回收算法</h4><ul><li><strong>标记-清除</strong>算法：<ul><li>先标记出有哪些垃圾需要回收，再进行回收——先标记再回收</li><li>问题是<strong>效率太低了</strong>，并且会在回收之后产生大量的不连续内存</li></ul></li><li><strong>复制</strong>算法：<ul><li>将内存分成两块，一次只使用其中一块，需要垃圾回收的时候就把不需要回收的内存直接复制到另一块过去，然后把那一块内存清除，如此循环往复</li><li>实现简单，运行高效</li></ul></li><li><strong>标记-整理</strong>算法：<ul><li>标记之后，回收的时候直接向前移动，这样就避免了一半内存的浪费</li></ul></li></ul><h3 id="2-2-JVM运行时数据区"><a href="#2-2-JVM运行时数据区" class="headerlink" title="2.2 JVM运行时数据区"></a>2.2 JVM运行时数据区</h3><ul><li><p>Java虚拟机在执行Java程序的时候会把它管理的内存划分为若干个不同的数据区域，这些区域有各自的创建和销毁的时间，而Java的运行时数据区域包含这样几个部分</p><ul><li><p><strong>方法区</strong>：</p><ul><li>存储已经被虚拟机加载的<strong>类的信息、常量、静态变量</strong>和JIT编译器编译后的代码，JVM的规范把方法区描述成了堆的一个逻辑部分</li><li>这个区域中垃圾回收方法比较少见</li><li>运行时<strong>常量池</strong> Runtime Constant Pool<ul><li>Java的class文件中除了有类的版本、字段、方法、接口等信息描述之外，还需要有常量池用于存放编译器生成的<strong>字面量和符号引用</strong>，这一部分内容将在类加载到方法区之后，在常量池中存放</li><li>动态性：常量不一定需要编译器才能产生，运行期间也可以将新的常量放入常量池中，这种特性用的比较多的就是String类中的<code>intern( )</code>方法</li></ul></li></ul></li><li><p><strong>堆</strong>：</p><ul><li>是JVM管理的内存中最大的一块，是线程共享的的一块内存区域，在虚拟机启动的时候就会创建</li><li>所有对象的实例和数组都需要在堆上分配内存，也是垃圾收集器的主要管理区域</li><li>线程共享的Java堆可以划分出多个线程私有的分配缓冲区 TLAB</li><li>Java堆的内存空间不一定是物理上连续的，只要是逻辑上连续就可以</li><li>下面这段代码是非常常见的<strong>堆溢出异常</strong>，引发原因是对象实例过多<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOM</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OOMObject</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OOMObject</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OOMObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>虚拟机栈</strong>：</p><ul><li>Java的<strong>虚拟机栈也是线程私有的</strong>，生命周期和所属线程的生命周期相同</li><li>描述了Java方法执行的内存模型，在每个方法执行的时候会创建一个<strong>栈帧</strong>(Stack Frame),用于存储<ul><li>局部变量表<ul><li>存放了编译期就可以知道的数据类型(基本的boolean，byte，char，int等八种)、对象引用和returnAddress类型</li><li>其中long和double需要占用2个局部变量空间slot(槽)，其他的都是1个空间</li><li>局部变量表在运行期间就完成了分配，一个方法的分配的局部变量空间是完全确定的，因此方法运行期间不会改变局部变量的大小</li></ul></li><li>操作数栈</li><li>动态链接</li><li>方法出口</li></ul></li><li>每一个方法从调用到执行结束的过程，就是一个栈帧在VMStack中入栈到出栈的过程</li><li>这个区域会抛出StackOverFlowError异常和OutOfMemoryError异常</li></ul></li><li><p><strong>本地方法栈</strong>：</p><ul><li>和虚拟机栈发挥的作用比较类似，区别是本地方法栈执行的是<strong>本地的方法</strong></li></ul></li><li><p><strong>程序计数器</strong>：</p><ul><li>比较小的一块内存空间，和汇编语言中的PC一样用来指示当前运行的字节码的行号，各种分支、循环、跳转和异常处理都依赖PC实现</li><li>Java虚拟机的多线程是通过线程的切换和分配处理器执行时间的方式来实现的，在任何一个确定的时候，一个处理器只能处理一个线程，因此<strong>每个线程都需要一个单独的PC</strong>，因此是线程私有的</li><li>如果执行的是本地的方法，则此时PC的值是undefined</li></ul></li><li><p>不同数据区域的特性</p><ul><li>这些区域中，<strong>方法区和堆直接和执行引擎进行交互</strong>，是<strong>线程共享</strong>的</li><li>而虚拟机栈、本地方法栈和程序计数器直接合<strong>本地库接口进行交互</strong>，是线程之间独立的</li></ul></li></ul></li><li><p>直接内存 Direct Memory</p><ul><li>不是JVM中定义的内存区域，但是也被频繁使用</li><li>这是JDK后期引入的NIO类，基于通道和缓冲区的I/O方式，可以使用Native函数库直接分配堆外的内存，可以使用本地函数库直接分配对外内存，然后通过DirectByteBuffer对这些区域进行引用的需要<h4 id="2-2-1-Java的内存模式"><a href="#2-2-1-Java的内存模式" class="headerlink" title="2.2.1 Java的内存模式"></a>2.2.1 Java的内存模式</h4></li></ul></li><li><p>Java的内存模型将内存分为共享内存和本地内存，共享内存又称为堆内存，指的就是线程之间共享的内容，包含所有的实例、静态域和数组，每个线程有一个仅自己可见的<strong>本地内存</strong></p><ul><li>每个线程都有单独的本地内存，通过save和load操作和主内存之间通信</li></ul></li></ul><h3 id="2-3-Java的内存管理模型JMM"><a href="#2-3-Java的内存管理模型JMM" class="headerlink" title="2.3 Java的内存管理模型JMM"></a>2.3 Java的内存管理模型JMM</h3><ul><li>Java的内存模型主要定义了各个变量的访问规则，这里的变量包含了实例字段、静态字段和构成数组对象的元素，但是不包含局部变量和方法参数，因为这是线程私有的。</li><li>JMM规定了所有的变量都必须<strong>存储在主内存</strong>中，每个线程还有自己专用的工作内存，工作内存保存了该线程使用到的变量的副本拷贝<ul><li>线程对变量的所有操作都必须在工作内存中进行，并且不能直接读写主内存中的变量</li><li>volatile变量仍然有工作内存的拷贝，但是由于该关键字的特性，所以看起来像是直接在主内存中进行读写访问，不同的线程直接无法访问其他线程的工作内存中的变量，线程之间的值的传递都需要通过主内存来完成。</li></ul></li><li>JMM的三大特性：原子性、可见性和有序性<ul><li>原子性是指一个操作不能被打断，要不就彻底不执行，要不就完全执行</li><li>可见性：一个线程对共享变量进行修改之后其他线程立刻可以看到该变量的变化</li><li>有序性：多线程并发的程序中，一系列的操作按照一定的规则来进行，不会变的无序，Java中有volatile和synchronized两个关键字来保证操作的有序性</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021春招实习-设计模式</title>
      <link href="2021/05/16/intern2/"/>
      <url>2021/05/16/intern2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><ul><li>单例模式的<strong>类的对象只允许一个实例存在</strong>，比如服务器中的配置信息读取可以由单一对象完成</li><li>单例模式的实现主要通过以下两步：<ul><li>将该<strong>类的构造方法定义为private</strong>的，这样一来别的地方的代码就无法调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来访问该类产生的唯一一个对象</li><li>在该类内<strong>提供一个静态方法</strong>，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用</li></ul></li></ul><h3 id="1-1-优缺点"><a href="#1-1-优缺点" class="headerlink" title="1.1 优缺点"></a>1.1 优缺点</h3><ul><li>优点<ul><li>在内存中只有一个对象，节省内存空间；</li><li>避免频繁的创建销毁对象，可以提高性能；</li><li>避免对共享资源的多重占用，简化访问；</li><li>为整个系统提供一个全局访问点</li></ul></li><li>缺点：<ul><li>不适用于变化频繁的对象；</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li><li>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失</li></ul></li></ul><h3 id="实现方式1：饿汉式"><a href="#实现方式1：饿汉式" class="headerlink" title="实现方式1：饿汉式"></a>实现方式1：饿汉式</h3><ul><li>一个简单的实现方式的代码如下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> singleton1 <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">singleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">singleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> singleton1 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种写法比较简单，在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费<ul><li>这种写法不用担心线程同步的问题</li></ul></li></ul><h3 id="实现方式2：懒汉式"><a href="#实现方式2：懒汉式" class="headerlink" title="实现方式2：懒汉式"></a>实现方式2：懒汉式</h3><ul><li>对饿汉式的实现方式做出了一定的改进，在需要的时候才对其进行实例化，问题就是不支持多线程的操作，否则会产生多个实例</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> singleton1 <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">singleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> singleton1 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">singleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>为了解决线程安全问题，可以进行双重加锁。在new之前看看互斥锁有没有上锁</li></ul><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h2><ul><li>工厂模式可以分为简单工厂模式、工厂方法模式和抽象工厂模式<ul><li>在设计模式的分类中都属于<strong>创建型模式</strong>，三种模式依次从上到下逐渐抽象</li><li>创建型模式对类的实例化这一过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离</li><li>对象的实例化过程是通过工厂实现的，用工厂代替new操作，使用工厂模式就可以</li></ul></li></ul><h3 id="2-1-简单工厂模式"><a href="#2-1-简单工厂模式" class="headerlink" title="2.1 简单工厂模式"></a>2.1 简单工厂模式</h3><ul><li>简单的工厂模式就是用factory提供的方法来代替<strong>直接new一个新的product</strong>，对外部封装了产品生产的过程，比如A接口派生出了B和C类，我们可以定义一个A工厂类来帮助我们产生新的B和C类<ul><li>简单工厂的模式不符合开闭原则</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">A</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"new A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">B</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"new B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">C</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"new C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> factory <span class="token punctuation">&#123;</span>    <span class="token class-name">B</span> makeB <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token class-name">C</span> makeC <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-工厂方法模式"><a href="#2-2-工厂方法模式" class="headerlink" title="2.2 工厂方法模式"></a>2.2 工厂方法模式</h3><ul><li>工厂方法模式包含 4 个角色（要素）：<ul><li>Product：抽象产品，定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口</li><li>ConcreteProduct：具体产品，具体的Product接口的实现对象</li><li>Factory：工厂接口，也可以叫 Creator(创建器)，声明工厂方法，通常返回一个 Product 类型的实例对象</li><li>ConcreteFactory：工厂实现，或者叫 ConcreteCreator(创建器对象)，覆盖 Factory 定义的工厂方法，返回具体的 Product 实例</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">A</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"new A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">B</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"new B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">C</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"new C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">A</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">BFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@override</span>    <span class="token class-name">A</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-抽象工厂模式"><a href="#2-4-抽象工厂模式" class="headerlink" title="2.4 抽象工厂模式"></a>2.4 抽象工厂模式</h3><ul><li>可以创建多种类型的产品，抽象工厂模式通过在<strong>AbstarctFactory中增加创建产品的接口</strong>，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干</li></ul><h2 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><ul><li><p>建造者模式使用多个简单的对象一步步构建一个复杂的对象，这种设计模式也是创建型模式，提供了一种创建对象的方式，一个Builder类会一步步构造最终的对象，并且是独立于其他对象的</p><ul><li>这种设计模式的目的是将复杂的构造函数与其表示相分离，使得同样的构建过程可以创建不同的表示</li><li>主要解决了一些基本部件不变而其组合方式进场会变化的类的创建问题<ul><li>需要将变和不变分离开</li><li>Java中的StringBuilder就是使用建造者模式设计的</li></ul></li></ul></li><li><p>使用场景：生成的对象有复杂的内部结构，需要生成的对象的内部属性本身就互相依赖</p><h3 id="3-2-建造者模式的实例"><a href="#3-2-建造者模式的实例" class="headerlink" title="3.2 建造者模式的实例"></a>3.2 建造者模式的实例</h3></li><li><p>这是一个汉堡店套餐的类的设计模式，item是所有菜品的抽象，派生出了burger和drink等子类，然后meal类中有一个item的数组和若干方法，mealbuilder被用来创建不同的meal，具体的代码实现如下：</p></li><li><p>基本的食物类和“包装”类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Item</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token class-name">Packing</span> <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Burger</span> <span class="token keyword">implements</span> <span class="token class-name">Item</span> <span class="token punctuation">&#123;</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">Packing</span> <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ColdDrink</span> <span class="token keyword">implements</span> <span class="token class-name">Item</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Packing</span> <span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bottle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VegBurger</span> <span class="token keyword">extends</span> <span class="token class-name">Burger</span> <span class="token punctuation">&#123;</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token number">25.0f</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token string">"Veg Burger"</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coke</span> <span class="token keyword">extends</span> <span class="token class-name">ColdDrink</span> <span class="token punctuation">&#123;</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token number">30.0f</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token string">"Coke"</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Packing</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wrapper</span> <span class="token keyword">implements</span> <span class="token class-name">Packing</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token string">"Wrapper"</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bottle</span> <span class="token keyword">implements</span> <span class="token class-name">Packing</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token string">"Bottle"</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构建一个meal类，可以表示不同的套餐</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Meal</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span><span class="token punctuation">></span></span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addItem</span><span class="token punctuation">(</span><span class="token class-name">Item</span> item<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getCost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">float</span> cost <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Item</span> item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         cost <span class="token operator">+=</span> item<span class="token punctuation">.</span><span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>              <span class="token keyword">return</span> cost<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Item</span> item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Item : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">", Packing : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">packing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">", Price : "</span><span class="token operator">+</span>item<span class="token punctuation">.</span><span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>           <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最后构建一个meal的builder，用于构造不同内容的meal</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MealBuilder</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Meal</span> prepareVegMeal <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token class-name">Meal</span> meal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Meal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VegBurger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Coke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> meal<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>       <span class="token keyword">public</span> <span class="token class-name">Meal</span> prepareNonVegMeal <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token class-name">Meal</span> meal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Meal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChickenBurger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      meal<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pepsi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> meal<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>这种设计模式下，虽然套餐有很多种，但是组成的内容无非是若干种汉堡和饮料，而套餐的形式固定了下来，当有套餐需要添加或者删除修改的时候，<strong>只需要修改、添加builder类的构造方法</strong>就可以了。</p></li></ul><h2 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a>4. 原型模式</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><ul><li>原型模式Prototype Pattern是用于创建重复的对象，同时又能保证性能，也是创建型的设计模式，它提供了一种创建对象的方式。<ul><li>这种模式是实现了一个<strong>原型接口</strong>，该接口用于创建<strong>当时对象的克隆</strong></li></ul></li><li>原型模式允许用原型实例创建指定对象的种类，并且通过拷贝这些原型创建新的对象。<ul><li>实现原型模式的关键在于实现clone操作，使得对象变成可拷贝的</li><li>原型模式同样用于隔离类对象的使用者和具体类型之间的耦合关系，同样要求这些易变类有稳定的结构</li></ul></li><li>原型模式使得代码的性能提高，经常用于资源优化的场景<h3 id="4-2-实例"><a href="#4-2-实例" class="headerlink" title="4.2 实例"></a>4.2 实例</h3></li><li>在实现了shape接口和三种具体类之后可以创建一个ShapeCache来保存一系列的shape<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShapeCache</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Hashtable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Shape</span><span class="token punctuation">></span></span> shapeMap       <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Shape</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Shape</span> <span class="token function">getShape</span><span class="token punctuation">(</span><span class="token class-name">String</span> shapeId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">Shape</span> cachedShape <span class="token operator">=</span> shapeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>shapeId<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Shape</span><span class="token punctuation">)</span> cachedShape<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">Circle</span> circle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      circle<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      shapeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>circle<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>circle<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">Square</span> square <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      square<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      shapeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>square<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>square<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">Rectangle</span> rectangle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      rectangle<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      shapeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>rectangle<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rectangle<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrototypePatternDemo</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">ShapeCache</span><span class="token punctuation">.</span><span class="token function">loadCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先装载各类和对应的id</span>      <span class="token class-name">Shape</span> clonedShape <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Shape</span><span class="token punctuation">)</span> <span class="token class-name">ShapeCache</span><span class="token punctuation">.</span><span class="token function">getShape</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Shape : "</span> <span class="token operator">+</span> clonedShape<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token class-name">Shape</span> clonedShape2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Shape</span><span class="token punctuation">)</span> <span class="token class-name">ShapeCache</span><span class="token punctuation">.</span><span class="token function">getShape</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Shape : "</span> <span class="token operator">+</span> clonedShape2<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token class-name">Shape</span> clonedShape3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Shape</span><span class="token punctuation">)</span> <span class="token class-name">ShapeCache</span><span class="token punctuation">.</span><span class="token function">getShape</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Shape : "</span> <span class="token operator">+</span> clonedShape3<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="5-适配器模式"><a href="#5-适配器模式" class="headerlink" title="5. 适配器模式"></a>5. 适配器模式</h2><h3 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h3><ul><li>适配器模式是作为<strong>两个不兼容的接口之间的桥梁</strong>，这是一种结构型模式，结合了两个独立接口的功能<ul><li>目的是将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原来由于接口不兼容而不能工作的类可以一起工作</li><li>主要的实现方式是继承或者依赖</li></ul></li><li>一个接口可能有多个实现方法，但是不需要继承一个接口全部的实现所有的方法，而是用一个抽象类继承接口，然后再选择性地继承和覆盖其中一些方法就可以</li><li>一个很经典的例子就是Java中中的JDBC就是一个Java和数据库的适配器<h3 id="5-2-实例"><a href="#5-2-实例" class="headerlink" title="5.2 实例"></a>5.2 实例</h3></li><li>上面这个就是一个适配器模式的设计，为了使AudioPlayer可以使用advance中的功能，可以设计一个adapter类供player使用<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediaAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">MediaPlayer</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">AdvancedMediaPlayer</span> advancedMusicPlayer<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MediaAdapter</span><span class="token punctuation">(</span><span class="token class-name">String</span> audioType<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>audioType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"vlc"</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         advancedMusicPlayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VlcPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>audioType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"mp4"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         advancedMusicPlayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mp4Player</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token class-name">String</span> audioType<span class="token punctuation">,</span> <span class="token class-name">String</span> fileName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>audioType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"vlc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         advancedMusicPlayer<span class="token punctuation">.</span><span class="token function">playVlc</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>audioType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"mp4"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         advancedMusicPlayer<span class="token punctuation">.</span><span class="token function">playMp4</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AudioPlayer</span> <span class="token keyword">implements</span> <span class="token class-name">MediaPlayer</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">MediaAdapter</span> mediaAdapter<span class="token punctuation">;</span>     <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token class-name">String</span> audioType<span class="token punctuation">,</span> <span class="token class-name">String</span> fileName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token comment">//播放 mp3 音乐文件的内置支持</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>audioType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"mp3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Playing mp3 file. Name: "</span><span class="token operator">+</span> fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>       <span class="token comment">//mediaAdapter 提供了播放其他文件格式的支持</span>      <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>audioType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"vlc"</span><span class="token punctuation">)</span>          <span class="token operator">||</span> audioType<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"mp4"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         mediaAdapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MediaAdapter</span><span class="token punctuation">(</span>audioType<span class="token punctuation">)</span><span class="token punctuation">;</span>         mediaAdapter<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span>audioType<span class="token punctuation">,</span> fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">else</span><span class="token punctuation">&#123;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Invalid media. "</span><span class="token operator">+</span>            audioType <span class="token operator">+</span> <span class="token string">" format not supported"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="6-组合模式"><a href="#6-组合模式" class="headerlink" title="6. 组合模式"></a>6. 组合模式</h2><ul><li>又叫整体部分模式，其实就是类之间的组合，将一个类拆分成若干更具体的类的组合然后分别实现，按照一定的层次组合起来，这种设计模式属于结构型模式，说是模式其实是非常常用的模式。</li><li>具体的就不用多说了</li></ul><h2 id="7-装饰器模式"><a href="#7-装饰器模式" class="headerlink" title="7. 装饰器模式"></a>7. 装饰器模式</h2><ul><li>装饰器模式允许像一个现有的对象添加新的功能同时又不改变其原本的结构，这种设计模式是结构型模式，其实就是对现有的类进行一次包装。</li><li>装饰类和被装饰类都可以独立扩展，不会相互耦合，装饰器模式比生成一个子类更为灵活。<ul><li>具体步骤是先抽象出总的装饰器类，再继承出一个具体的装饰器<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ShapeDecorator</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">protected</span> <span class="token class-name">Shape</span> decoratedShape<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ShapeDecorator</span><span class="token punctuation">(</span><span class="token class-name">Shape</span> decoratedShape<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>decoratedShape <span class="token operator">=</span> decoratedShape<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      decoratedShape<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedShapeDecorator</span> <span class="token keyword">extends</span> <span class="token class-name">ShapeDecorator</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">RedShapeDecorator</span><span class="token punctuation">(</span><span class="token class-name">Shape</span> decoratedShape<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">super</span><span class="token punctuation">(</span>decoratedShape<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      decoratedShape<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token function">setRedBorder</span><span class="token punctuation">(</span>decoratedShape<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setRedBorder</span><span class="token punctuation">(</span><span class="token class-name">Shape</span> decoratedShape<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Border Color: Red"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="8-观察者模式"><a href="#8-观察者模式" class="headerlink" title="8. 观察者模式"></a>8. 观察者模式</h2><ul><li><p>假设A对B的某个属性的变化非常敏感，当B的这个属性发生变化的时候A也需要相应地作出一些反映，这个时候就需要使用观察者模式，这里A就是观察者，B就是被观察者，当B中的属性发生变化的时候会立即通知与B关联的A对象。</p></li><li><p>实现的关键在于在抽象类里面存放一系列的观察者。</p></li><li><p>举例：使用三个类Subject、Observer和Client来实现观察者模式，其中Subject对象带有绑定观察者到client对象和从client对象中解绑观察者的方法，具体的代码如下：</p></li><li><p>Subject类有一个状态state，同时有一系列的观察者</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Observer</span><span class="token punctuation">></span></span> observers       <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Observer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> state<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">int</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>      <span class="token function">notifyAllObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span><span class="token class-name">Observer</span> observer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyAllObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Observer</span> observer <span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         observer<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后实现一个抽象类Observer，对Subject类进行一步封装</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">protected</span> <span class="token class-name">Subject</span> subject<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后实现具体的Observer类，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinaryObserver</span> <span class="token keyword">extends</span> <span class="token class-name">Observer</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">BinaryObserver</span><span class="token punctuation">(</span><span class="token class-name">Subject</span> subject<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>subject <span class="token operator">=</span> subject<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>subject<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"Binary String: "</span>       <span class="token operator">+</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span> subject<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实习/工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021春招实习-MySQL知识整理</title>
      <link href="2021/05/16/intern1/"/>
      <url>2021/05/16/intern1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据库索引与B-树"><a href="#1-数据库索引与B-树" class="headerlink" title="1. 数据库索引与B+树"></a>1. 数据库索引与B+树</h2><ul><li><p>索引是一种数据结构用于在大量的数据中快速定位到我们想要的数据，mysql数据库中的索引主要有B+树索引、Hash索引和全文索引</p><h3 id="1-1-二叉搜索树和平衡树"><a href="#1-1-二叉搜索树和平衡树" class="headerlink" title="1.1 二叉搜索树和平衡树"></a>1.1 二叉搜索树和平衡树</h3></li><li><p>B+树是由二叉搜索树和平衡树发展而来的，<strong>二叉搜索树</strong>是一种最简单的索引，但是在一定的条件下会退化成一个链表，造成索引的性能下降的问题，而平衡树可以解决这一问题，平衡树会根据一定的规则自适应地调整树的节点和高度，使得索引尽可能保持一个平衡的树形结构，常见的有AVL树、Splay树和红黑树等</p><ul><li>平衡树相比于普通的二叉搜索树查找效率更稳定，总体的查询速度也更快</li></ul></li><li><p>一般来说数据库中的数据规模都比较大，所以内存很容易放不下这么多数据和索引，因此通常会把索引和数据存储在磁盘之类的外围设备中，但是和内存相比，磁盘IO的效率非常低，并且是按block存取的，因此应该尽可能将要查询的数据放在一个磁盘中，也就是说要让<strong>树的节点多存放一些数据</strong></p><h3 id="1-2-B树与B-树"><a href="#1-2-B树与B-树" class="headerlink" title="1.2 B树与B+树"></a>1.2 B树与B+树</h3></li><li><p>B树相比于平衡二叉树，每个节点存储了更多的key和data，B+树相比于B树做出了一些改进，最重要的一点就是<strong>非叶节点不存储数据</strong>，而是只存储一系列的key用于索引，相比于B树磁盘IO的代价更低了。</p><ul><li>同时节点中还有类似于<strong>bucket的结构</strong>，用于容纳更多的数据</li></ul></li><li><p>这么做的原因是因为数据库中一个节点的大小被固定成了磁盘的一个block的大小，常见的一般是4096KB，这样一来一个节点可以存储非常多的数据，因此B+树的阶数也就非常大，ads中一般都是3阶或者4阶的B+树而数据库系统的索引模块构建的B+树很可能有几百阶和几千阶，因此<strong>需要磁盘IO的次数非常少</strong></p><ul><li>Mysql的InnoDB引擎中使用的就是B+树的索引</li></ul></li></ul><h3 id="1-3-聚集索引和非聚集索引"><a href="#1-3-聚集索引和非聚集索引" class="headerlink" title="1.3 聚集索引和非聚集索引"></a>1.3 聚集索引和非聚集索引</h3><ul><li>在MySQL中，B+树索引按照存储方式的不同分为<strong>聚集索引</strong>和<strong>非聚集索引</strong></li><li><strong>聚集索引</strong>（聚簇索引）：以innodb作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这是因为<strong>innodb是把数据存放在B+树中的</strong>，而B+树的键值就是主键，在B+树的叶子节点中，存储了表中所有的数据。这种<strong>以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引</strong><ul><li><strong>其实就是说B+树中如果叶节点存储了整条数据的，那就是聚集索引</strong></li><li><strong>innodb主要就是聚集索引</strong></li></ul></li><li><strong>非聚集索引</strong>（非聚簇索引）：以<strong>主键以外的列值作为键值构建的B+树索引</strong>，我们称之为非聚集索引。非聚集索引与聚集索引的区别在于非聚集索引的<strong>叶节点不存储表中的数据</strong>，而是存储<strong>对应的主键</strong>，想要查找数据我们还需要<strong>根据主键再去聚集索引中进行查找</strong>，这个再根据聚集索引查找数据的过程，我们称为<strong>回表</strong>。<ul><li>等于说非聚集索引需要配合聚集索引使用</li><li>Innodb中每个表一定会被创建一个聚集索引，就算建表的时候没有创建主键，也会自动创建一个然后建立聚集索引，非聚集索引需要用到聚集索引来帮助查找元素</li></ul></li></ul><h2 id="2-数据库范式"><a href="#2-数据库范式" class="headerlink" title="2. 数据库范式"></a>2. 数据库范式</h2><ul><li><p>数据库的范式是对数据库和数据表的设计原则，要求存储信息的时候没有不必要的冗余，使得信息检索的效率提高，常见的范式有第一范式和BCNF范式</p><h3 id="2-1-第一范式与第二范式"><a href="#2-1-第一范式与第二范式" class="headerlink" title="2.1 第一范式与第二范式"></a>2.1 第一范式与第二范式</h3></li><li><p>第一范式是最简单的范式，要求数据表的设计具有<strong>原子性</strong>，不能再向下继续拆分</p><ul><li>第一范式存在冗余，并且数据的更新非常复杂，难以处理null-value<h4 id="2-1-1-数据库的四种键"><a href="#2-1-1-数据库的四种键" class="headerlink" title="2.1.1 数据库的四种键"></a>2.1.1 数据库的四种键</h4></li></ul></li><li><p>super key超键：能够<strong>唯一标识</strong>元组的属性集，即对于每一条关系而言超键的值是唯一的</p><ul><li>超键可以是多个属性的组合</li><li>如果A是关系R的一个超键，那么(A, B)也是关系R的一个超键</li><li>超键的“唯一标识”各个元组是可以有冗余信息的</li></ul></li><li><p>candidate key候选键：<strong>不含多余属性</strong>的超键</p><ul><li>如果K是R的一个超键，而任何K的真子集不是R的一个超键，那么K就是R的一个候选键</li></ul></li><li><p>primary key主键：</p><ul><li>数据库管理员<strong>指定</strong>的元组标识的一个候选键，不能是null值</li></ul></li><li><p>foreign key外键：用来描述两个表之间的关系，可以有空值</p><ul><li>如果关系模式R1中的一个属性是另一个关系模式R2中的一个<strong>主键</strong>，那么这个属性就是R1的一个外键<ul><li>a foreign key from r1 referencing r2<h4 id="2-1-2-函数依赖"><a href="#2-1-2-函数依赖" class="headerlink" title="2.1.2 函数依赖"></a>2.1.2 函数依赖</h4></li></ul></li></ul></li><li><p>对于一个关系模式R，如果$\alpha \subset R$ 并且$\beta\subset R$ 则<strong>函数依赖</strong>$\alpha \rightarrow\beta$ 定义在R上，当且仅当对于R的任意关系r(R)  当其中的任意两个元组t1和t2，如果他们的$\alpha$属性值相同可以推出他们的$\beta$属性值也相同</p><h4 id="2-1-3-第二范式"><a href="#2-1-3-第二范式" class="headerlink" title="2.1.3 第二范式"></a>2.1.3 第二范式</h4></li><li><p>第二范式的定义：如果某个关系R属于第一范式，并且每个非主属性完全<strong>函数依赖</strong>于另一个候选键，那就是第二范式</p><h3 id="2-2-BC范式"><a href="#2-2-BC范式" class="headerlink" title="2.2 BC范式"></a>2.2 BC范式</h3></li><li><p>BC范式的条件是：闭包$F^+$中的所有函数依赖$\alpha \rightarrow \beta$ 至少满足下面的一条</p><ul><li>$\alpha \rightarrow \beta$ 是平凡的(也就是β是α的子集)</li><li>α是关系模式R的一个<strong>超键</strong>，即$\alpha \rightarrow R$</li></ul></li></ul><h2 id="3-数据库的锁与并发"><a href="#3-数据库的锁与并发" class="headerlink" title="3. 数据库的锁与并发"></a>3. 数据库的锁与并发</h2><h3 id="3-1-普通锁"><a href="#3-1-普通锁" class="headerlink" title="3.1 普通锁"></a>3.1 普通锁</h3><ul><li><p>普通锁分为共享锁和排他锁，共享锁S允许多个事务持有读取同一个记录的权限，排他锁X使得多个事务中每次只能有<strong>一个事务拥有对一条记录写和修改的权限</strong></p><ul><li>这两种锁的作用是为了提高数据库的并发性</li><li>当一条记录的排他锁被占用的时候，不能分配共享锁或者排他锁给其他的事务，即X与X和S都冲突，而共享锁可以在一段时间内分出去多个</li></ul></li><li><p>值得注意的是普通锁都是行级的，即对一条记录有效</p><h3 id="3-2-意向锁"><a href="#3-2-意向锁" class="headerlink" title="3.2 意向锁"></a>3.2 意向锁</h3></li><li><p>InnoDB中有<strong>多种粒度的锁</strong>，<strong>普通锁是行级的</strong>，而<strong>意向锁是表级的</strong>，用来表明一个事务正在持有锁或者正在申请一个锁。</p></li><li><p>共享意向锁（IS）：表示事务<strong>持有表中行的共享锁或者打算获取行的共享锁</strong>，事务在<strong>获取S锁之前必须要获取IS锁</strong>，即表明自己的意向，可以理解为投名状</p></li><li><p>共享排他锁（IX）：表示事务<strong>持有表中行的排他锁或者打算获取行的排他锁</strong>，事务在获取X锁之前必须要或许IX锁</p><h3 id="3-3-记录锁"><a href="#3-3-记录锁" class="headerlink" title="3.3 记录锁"></a>3.3 记录锁</h3></li><li><p>记录锁是对<strong>索引记录</strong>的锁定，换句话说就是，记录锁只会锁定索引。每一个表必定会有一个主键索引（用户定义的主键、唯一索引、隐式生成），而该主键索引中的非叶子节点中的记录就是使用该记录锁进行锁定</p></li><li><p>InnoDB中还有二级索引，二级索引跟主键索引一样，在使用二级索引作为查询条件时，<strong>会将符合条件的二级索引的记录使用记录锁进行锁定，然后再回表将对应的主键索引也使用记录锁进行锁定</strong></p><h3 id="3-4-间隙锁"><a href="#3-4-间隙锁" class="headerlink" title="3.4 间隙锁"></a>3.4 间隙锁</h3></li><li><p>间隙锁（简称为 Gap）是对<strong>索引记录之间的间隙的锁</strong>定，或者是对第一条索引记录之前的间隙和对最后一条记录之后的间隙的锁。间隙锁是防止幻读的主要手段之一。</p></li><li><p>其他的像是Next-Key锁、插入意向锁和AUTO-INC锁感觉比较冷门就先不管了。</p></li></ul><h2 id="4-事务处理、日志与故障恢复"><a href="#4-事务处理、日志与故障恢复" class="headerlink" title="4. 事务处理、日志与故障恢复"></a>4. 事务处理、日志与故障恢复</h2><h3 id="4-1-事务的特性"><a href="#4-1-事务的特性" class="headerlink" title="4.1 事务的特性"></a>4.1 事务的特性</h3><ul><li>数据库中的事务具有ACDI四个特性，分别是原子性，持久性，一致性和独立性<ul><li>原子性要求事务在处理的过程中不能被打断，要不就完成，要不就不执行事务</li><li>持久性要求更新之后如果软硬件出了问题，数据也还是要存在</li><li>一致性要求多个事务并发的时候数据要保持一致</li><li>独立性要求事务的执行不能被其他的事务感知，必须独立执行，执行的过程对外隐藏</li></ul></li><li>事务的状态：<ul><li>active 初始状态，执行中的事务都处于这个状态 </li><li>partially committed 在最后一句指令被执行之后 </li><li>failed 在发现执行失败之后 </li><li>aborted 回滚结束，会选择是重新执行事务还是结束 </li><li>committed 事务被完整的执行</li></ul></li></ul><h3 id="4-2-日志与事务恢复"><a href="#4-2-日志与事务恢复" class="headerlink" title="4.2 日志与事务恢复"></a>4.2 日志与事务恢复</h3><ul><li>数据库需要在发生故障的时候进行恢复，而恢复需要基于日志进行，日志需要写在稳定的存储中，比如磁盘，而一般事务开始需要写入start，进行操作修改值的时候需要写入修改的情况，结束或者中止的时候需要写入abort或者commit<ul><li>日志的写入需要比实际操作早，先写日志再进行实际的操作</li></ul></li><li>事务在恢复的过程中需要进行一系列的<strong>undo或者redo</strong>，undo就是将进行到一半的事务撤销，redo就是重复一次做过的事务</li></ul><h2 id="5-MySQL相关的概念"><a href="#5-MySQL相关的概念" class="headerlink" title="5. MySQL相关的概念"></a>5. MySQL相关的概念</h2><h3 id="5-1-一致性读写的相关概念"><a href="#5-1-一致性读写的相关概念" class="headerlink" title="5.1 一致性读写的相关概念"></a>5.1 一致性读写的相关概念</h3><ul><li><p>脏读：另一个事务修改了数据，但尚未提交并写到硬盘中，但是日志中已经有了修改记录，而本事务中会读<strong>到这些未被提交的数据</strong></p><ul><li>也就是<strong>读了别人还没提交的数据</strong></li></ul></li><li><p>不重复读：解决了脏读后，会遇到，同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致</p><ul><li>多次读同一个数据的不同结果，脏读读取到的是未提交的数据，而不可重复度读到的是提交了的数据</li></ul></li><li><p>幻读：解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务<strong>同时提交了新数据</strong>，本事务再更新时，就会“惊奇的”发现了这些新数据，貌似之前读到的数据是“鬼影”一样的幻觉</p><ul><li>事务<strong>不独立执行</strong>的后果，一起修改导致发生幻觉</li><li>比如两个事务同时执行，一个事务在修改表中的值，另一个事务直接插入了一条新的记录，这时候第一个事务会发现中间出现了一行自己没有修改过的记录，就好像发生了幻觉一样<h3 id="5-2-InnoDB的四个隔离级别"><a href="#5-2-InnoDB的四个隔离级别" class="headerlink" title="5.2 InnoDB的四个隔离级别"></a>5.2 InnoDB的四个隔离级别</h3></li></ul></li><li><p>未提交读（READ UNCOMMITTED）。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）( 隔离级别最低，并发性能高 )</p><ul><li>即就算没有提交也要进行另一个可能涉及到这部分数据的事务。</li><li>不能解决脏读、不可重复度和幻读的问题，但是并发性能很好</li></ul></li><li><p>提交读（READ COMMITTED）。保证本事务读取到的是<strong>最新的数据</strong>（一定是其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不重复读）。会出现不可重复读、幻读问题（锁定正在读取的行）</p><ul><li>可以防止脏读的发生</li></ul></li><li><p>可重复读（REPEATABLEREAD）。在同一个事务里，SELECT的结果是<strong>事务开始时时间点的状态</strong>，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</p><ul><li>可以防止脏读，不可重复读的发生</li><li>每个事务在执行的过程中不允许其他事务update，但是允许进行insert</li><li>mysql默认的事务隔离级别就是<strong>可重复读</strong></li></ul></li><li><p>串行化（SERIALIZABLE）。读操作会隐式获取共享锁，可以保证不同事务间的互斥（锁表）</p><ul><li>事务的并发性能最低</li></ul></li></ul><h3 id="5-3-MySQL引擎特点"><a href="#5-3-MySQL引擎特点" class="headerlink" title="5.3 MySQL引擎特点"></a>5.3 MySQL引擎特点</h3><ul><li>MySQL的引擎分为两种，早期用的是MyISAM，后来逐渐变成了InnoDB，二者的主要区别在于：<ul><li><strong>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务</strong></li><li><strong>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</strong></li><li>InnoDB是<strong>聚集索引</strong>，使用B+Tree作为索引结构，<strong>数据文件是和（主键）索引绑在一起的</strong>（表数据文件本身就是按B+Tree组织的一个索引结构），<strong>必须要有主键</strong>，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大<ul><li>Innodb的数据和索引是一起存储的</li></ul></li><li>MyISAM是<strong>非聚集索引</strong>，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的</li><li><strong>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）</strong></li><li>** Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了**</li><li><strong>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong></li><li><strong>InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键）</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实习/工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络9：三层CNN</title>
      <link href="2021/05/15/coding9/"/>
      <url>2021/05/15/coding9/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络9：三层CNN"><a href="#手写神经网络9：三层CNN" class="headerlink" title="手写神经网络9：三层CNN"></a>手写神经网络9：三层CNN</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p><p>限于个人水平实在有限，我尽量减少参考网上代码的次数</p></blockquote><h2 id="1-三层CNN的架构"><a href="#1-三层CNN的架构" class="headerlink" title="1.三层CNN的架构"></a>1.三层CNN的架构</h2><ul><li>写了这么久我们终于来到了手写CNN的环节，当然我们前面写的一些东西比较naive，不堪大用，只能用于理解和学习CNN中各个层的作用，因此CS231N的assignment2为我们提供了一些写好的层，将原来的一些层进行了组合，比如<code>affine_relu_forward</code>，<code>conv_relu_forward</code>和<code>conv_bn_relu_forward</code>，其实也只是在我们写好的layers上面封装了一层函数，将全连接层+ReLU，卷积层+ReLU组合成了完整的一个层</li><li>CNN通常来说是这样的架构：</li></ul><img src="image-20210514131337907.png" alt="CNN架构图" style="zoom:67%;" /><ul><li>而我们需要实现的三层CNN的架构就是：<code>conv - relu - 2x2 max pool - affine - relu - affine - softmax</code> 和上面的图基本一致。</li></ul><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><h3 id="2-1初始化"><a href="#2-1初始化" class="headerlink" title="2.1初始化"></a>2.1初始化</h3><ul><li><p>我们定义了一个类<code>ThreeLayerConvNet</code>，并需要实现类的初始化和前向反向传播</p></li><li><p>初始化和前面的全连接神经网络基本一致，这里需要注意的就是，我们需要实现的三层神经网络架构中的参数主要有：</p><ul><li>卷积层的卷积核W1和偏差b1</li><li>第一个全连接层的参数W2和b2</li><li>第二个全连接层的参数W3和b3</li></ul></li><li><p>以上这些参数都要按照正态分布的规则进行随机初始化，这一部分代码比较简单，就不放出来了。</p></li></ul><h3 id="2-2前向传播和反向传播"><a href="#2-2前向传播和反向传播" class="headerlink" title="2.2前向传播和反向传播"></a>2.2前向传播和反向传播</h3><ul><li>我们需要在loss函数中实现前向传播和反向传播，并求出所有参数的梯度和总的损失函数</li><li>前向传播的过程比较简单，就是用现成的api一层层计算下去：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">loss</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Evaluate loss and gradient for the three-layer convolutional network.        Input / output: Same API as TwoLayerNet in fc_net.py.        """</span>        W1<span class="token punctuation">,</span> b1 <span class="token operator">=</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">"W1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">"b1"</span><span class="token punctuation">]</span>        W2<span class="token punctuation">,</span> b2 <span class="token operator">=</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">"W2"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">"b2"</span><span class="token punctuation">]</span>        W3<span class="token punctuation">,</span> b3 <span class="token operator">=</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">"W3"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">"b3"</span><span class="token punctuation">]</span>        <span class="token comment"># pass conv_param to the forward pass for the convolutional layer</span>        <span class="token comment"># Padding and stride chosen to preserve the input spatial size</span>        filter_size <span class="token operator">=</span> W1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        conv_param <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"stride"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"pad"</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>filter_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>        <span class="token comment"># pass pool_param to the forward pass for the max-pooling layer</span>        pool_param <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"pool_height"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"pool_width"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"stride"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>        scores <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token comment"># 逐层实现反向传播</span>        out1<span class="token punctuation">,</span> cache1 <span class="token operator">=</span> conv_relu_pool_forward<span class="token punctuation">(</span>X<span class="token punctuation">,</span> W1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> conv_param<span class="token punctuation">,</span> pool_param<span class="token punctuation">)</span>        out2<span class="token punctuation">,</span> cache2 <span class="token operator">=</span> affine_relu_forward<span class="token punctuation">(</span>out1<span class="token punctuation">,</span> W2<span class="token punctuation">,</span> b2<span class="token punctuation">)</span>        scores<span class="token punctuation">,</span> cache3 <span class="token operator">=</span> affine_forward<span class="token punctuation">(</span>out2<span class="token punctuation">,</span> W3<span class="token punctuation">,</span> b3<span class="token punctuation">)</span>        <span class="token keyword">if</span> y <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> scores<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>然后反向传播就是用已经写好的单层反向传播组合起来，同时也可以算出loss函数，注意最后要加上正则项</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss<span class="token punctuation">,</span> grads <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>     loss<span class="token punctuation">,</span> dout <span class="token operator">=</span> softmax_loss<span class="token punctuation">(</span>scores<span class="token punctuation">,</span> y<span class="token punctuation">)</span>   dout3<span class="token punctuation">,</span> grads<span class="token punctuation">[</span><span class="token string">'W3'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> grads<span class="token punctuation">[</span><span class="token string">'b3'</span><span class="token punctuation">]</span> <span class="token operator">=</span> affine_backward<span class="token punctuation">(</span>dout<span class="token punctuation">,</span> cache3<span class="token punctuation">)</span>   dout2<span class="token punctuation">,</span> grads<span class="token punctuation">[</span><span class="token string">'W2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> grads<span class="token punctuation">[</span><span class="token string">'b2'</span><span class="token punctuation">]</span> <span class="token operator">=</span> affine_relu_backward<span class="token punctuation">(</span>dout3<span class="token punctuation">,</span> cache2<span class="token punctuation">)</span>   dout1<span class="token punctuation">,</span> grads<span class="token punctuation">[</span><span class="token string">'W1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> grads<span class="token punctuation">[</span><span class="token string">'b1'</span><span class="token punctuation">]</span> <span class="token operator">=</span> conv_relu_pool_backward<span class="token punctuation">(</span>dout2<span class="token punctuation">,</span> cache1<span class="token punctuation">)</span>   <span class="token comment"># 加上正则项</span>   loss <span class="token operator">+=</span> <span class="token number">0.5</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>reg <span class="token operator">*</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>W1 <span class="token operator">*</span> W1<span class="token punctuation">)</span> <span class="token operator">+</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>W2 <span class="token operator">*</span> W2<span class="token punctuation">)</span> <span class="token operator">+</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>W3 <span class="token operator">*</span> W3<span class="token punctuation">)</span><span class="token punctuation">)</span>   grads<span class="token punctuation">[</span><span class="token string">'W3'</span><span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>reg <span class="token operator">*</span> W3   grads<span class="token punctuation">[</span><span class="token string">'W2'</span><span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>reg <span class="token operator">*</span> W2   grads<span class="token punctuation">[</span><span class="token string">'W1'</span><span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>reg <span class="token operator">*</span> W1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>最后这个自己搭建的简单三层神经网络在CIFAR数据集上的表现如下图所示，可以看到在训练集上的表现非常不错，但是在测试集上的表现比较糟糕，原因也很简单，就是因为神经网络训练过程中过拟合了，如果考虑使用标准化层和DropOut可能表现效果会更好一点。</li></ul><p><img src="/2021/05/15/coding9/image-20210515001728149.png" alt="简易三层CNN的loss曲线和预测准确度"></p><h2 id="3-三层CNN的Pytorch实现"><a href="#3-三层CNN的Pytorch实现" class="headerlink" title="3.三层CNN的Pytorch实现"></a>3.三层CNN的Pytorch实现</h2><ul><li>这部分作业的最后也要求我们用Pytorch实现一个架构和上面相同的CNN，而Pytorch框架有自动求梯度的功能，相比之下搭建神经网络就简单了很多。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ThreeLayerConvNet</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> in_channel<span class="token punctuation">,</span> channel_1<span class="token punctuation">,</span> channel_2<span class="token punctuation">,</span> num_classes<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channel<span class="token punctuation">,</span> channel_1<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>kaiming_normal_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv1<span class="token punctuation">.</span>weight<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>channel_1<span class="token punctuation">,</span> channel_2<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>kaiming_normal_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv2<span class="token punctuation">.</span>weight<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>channel_2 <span class="token operator">*</span> <span class="token number">32</span> <span class="token operator">*</span> <span class="token number">32</span><span class="token punctuation">,</span> num_classes<span class="token punctuation">)</span>        nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>kaiming_normal_<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc<span class="token punctuation">.</span>weight<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        scores <span class="token operator">=</span> Nonex <span class="token operator">=</span> self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>conv2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> flatten<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment"># 这是一个另外定义的将张量压缩成一维的函数</span>        scores <span class="token operator">=</span> self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> scores<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们用这样几行代码就做好了一个简单的三层神经网络，使用Pytorch的<code>nn.Module API</code>搭建神经网络的时候只需要继承<code>nn.Module</code>类，并在init函数中定义好所需要的层，在forward函数中定义神经网络的计算过程就可以了</li><li>模型的训练也很简单，只需要定义优化器和编写简单的每个epoch代码，Pytorch就会自动完成求梯度和反向传播的过程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习代码实现3：KNN算法</title>
      <link href="2021/05/14/coding-ml3/"/>
      <url>2021/05/14/coding-ml3/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习代码实现3：KNN算法"><a href="#机器学习代码实现3：KNN算法" class="headerlink" title="机器学习代码实现3：KNN算法"></a>机器学习代码实现3：KNN算法</h1><blockquote><p>这一专题的内容主要是我在进行统计机器学习的算法的代码实践的过程中的一些记录，包括公式的推导，算法的实现与数据集的实验结果。</p><p>这部分工作我比较早之前就已经开始做了，现在刚好趁此机会整理一下之前写过的所有小demo，汇总成一个完成的库</p></blockquote><h2 id="1-KNN算法"><a href="#1-KNN算法" class="headerlink" title="1.KNN算法"></a>1.KNN算法</h2><ul><li>KNN算法是一种常见的监督学习算法，常用于分类问题，KNN算法的核心思想是用跟<strong>输入数据最接近</strong>的K个点的类别来预测输入数据的类别，这就决定了这个算法的关键在于：<ul><li>如何定义最接近？需要计算点与点之间的距离，我们一般会用L2距离，也叫欧几里德距离，来表示点与点之间的距离</li><li>K如何选定：K的大小会直接影响算法求解的效率</li><li>怎么用K个数据的类来预测输入数据的类：一般采用投票法，选择K个点的类别中出现次数最多的类别作为预测结果</li></ul></li><li>KNN算法的过程：<ul><li>训练阶段：保存训练集中的数据点和对应的标签</li><li>预测阶段：输入一个点之后，计算其与所有的训练集中的数据点的具体，按大小排序选出最小的K个并统计其类别的分布情况，选择出现次数的那个类别作为预测的结果</li></ul></li></ul><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><ul><li>这里的代码框架取自CS231N的assignment1的KNN，首先我们可以实现一种最naive的实现方式，通过<strong>两层循环</strong>来实现距离的计算：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compute_distances_two_loops</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Compute the distance between each test point in X and each training point        in self.X_train using a nested loop over both the training data and the        test data.        Inputs:        - X: A numpy array of shape (num_test, D) containing test data.        Returns:        - dists: A numpy array of shape (num_test, num_train) where dists[i, j]          is the Euclidean distance between the ith test point and the jth training          point.        """</span>        num_test <span class="token operator">=</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        num_train <span class="token operator">=</span> self<span class="token punctuation">.</span>X_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        dists <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>num_test<span class="token punctuation">,</span> num_train<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_test<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_train<span class="token punctuation">)</span><span class="token punctuation">:</span>                dists<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>X_train<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于测试集中的每一个$x_i$和训练集中的每一个$t_i$，KNN需要计算每一个对应的</li></ul><p>$$<br>||x_i-t_{j}||_2=\sqrt{||x_i||^2_2+||t_j||^2_2-2||x_i||_2||t_j||_2}<br>$$</p><ul><li>上面的代码<code>compute_distances_two_loops</code>就是通过两层循环实现了这样的计算，但是python中的numpy支持<strong>向量化的运算</strong>来大幅度提升矩阵和向量预算的效率，我们可以利用numpy库中的<strong>广播机制</strong>来进行向量化的运算：</li></ul><p>$$<br>||X-T||_2=\sqrt{||X||_2^2+||T||_2^2-2||XT||_2}<br>$$</p><ul><li>向量化的KNN实现方式如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compute_distances_no_loops</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Compute the distance between each test point in X and each training point    in self.X_train using no explicit loops.    采用向量化的形式来计算样本之间的距离，是效率最高的计算方式    Input / Output: Same as compute_distances_two_loops    """</span>    num_test <span class="token operator">=</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    dists <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>      np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>X <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">[</span>num_test<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span>      np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>X_train <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span>      <span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>X_train<span class="token punctuation">.</span>T<span class="token punctuation">)</span>     <span class="token punctuation">)</span>    <span class="token keyword">return</span> dists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用了一个比较大的数据集来跑KNN，几种不同实现方式的测试如下：</li></ul><table><thead><tr><th>算法</th><th>效率</th></tr></thead><tbody><tr><td>两层循环</td><td>33.422726s</td></tr><tr><td>一层循环</td><td>26.862319</td></tr><tr><td>向量化</td><td>0.152312</td></tr></tbody></table><h2 id="3-K的选取和可视化"><a href="#3-K的选取和可视化" class="headerlink" title="3.K的选取和可视化"></a>3.K的选取和可视化</h2><ul><li>我们采用了一个二维的随机数的数据集来对KNN算法的分类边界进行可视化，选取了K=1，10，100多种值，得到的结果如下：</li></ul><img src="image-20210514103706165.png" alt="k=1" style="zoom: 25%;" /><img src="image-20210514103744902.png" alt="k=10" style="zoom:25%;" /><img src="image-20210514103826512.png" alt="k=100" style="zoom:25%;" /><ul><li>我们发现k越大，KNN算法的分类边界就越“粗犷”，而当K比较小的时候因为采样的个数太少，很容易发生过拟合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络8：池化层</title>
      <link href="2021/05/13/coding8/"/>
      <url>2021/05/13/coding8/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络8：池化层"><a href="#手写神经网络8：池化层" class="headerlink" title="手写神经网络8：池化层"></a>手写神经网络8：池化层</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p><p>限于个人水平实在有限，我尽量减少参考网上代码的次数</p></blockquote><h2 id="1-什么是池化层"><a href="#1-什么是池化层" class="headerlink" title="1.什么是池化层"></a>1.什么是池化层</h2><ul><li>当我们发现了一个特征之后，这个特征相对于其他特征的位置相比于这个特征的值而言更为重要，很明显的一个例子就是计算机视觉中的目标检测任务，我们要检测的目标所处周围环境的特点更能帮助我们检测出真的目标，这就是池化层的idea的来源，池化层是CNN架构中提出的另一种特殊层，起到了<strong>降采样</strong>的作用。</li><li>池化就是通过一种非线性的变换，对特征进行进一步的<strong>抽象和降维</strong>，常见的有最大池化，平均池化等等，就是按照池化窗口的大小将矩阵分成若干个区域，在每个区域中进行池化操作(求最大，均值等等)，生成一个维度更小的feature map，同时池化层也可以起到防止过拟合的作用。</li><li>池化层同样也有长宽和步长等参数</li></ul><h2 id="2-池化层的前向传播"><a href="#2-池化层的前向传播" class="headerlink" title="2.池化层的前向传播"></a>2.池化层的前向传播</h2><ul><li>池化层的前向传播也是通过一系列for循环进行对应的池化操作，这里我们以最大池化为例，实现了函数<code>max_pool_forward_naive</code> </li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">max_pool_forward_naive</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> pool_param<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""A naive implementation of the forward pass for a max-pooling layer.    Inputs:    - x: Input data, of shape (N, C, H, W)    - pool_param: dictionary with the following keys:      - 'pool_height': The height of each pooling region      - 'pool_width': The width of each pooling region      - 'stride': The distance between adjacent pooling regions    No padding is necessary here, eg you can assume:      - (H - pool_height) % stride == 0      - (W - pool_width) % stride == 0    Returns a tuple of:    - out: Output data, of shape (N, C, H', W') where H' and W' are given by      H' = 1 + (H - pool_height) / stride      W' = 1 + (W - pool_width) / stride    - cache: (x, pool_param)    """</span>    out <span class="token operator">=</span> <span class="token boolean">None</span>    N<span class="token punctuation">,</span> C<span class="token punctuation">,</span> H<span class="token punctuation">,</span> W <span class="token operator">=</span> x<span class="token punctuation">.</span>shape    h<span class="token punctuation">,</span> w<span class="token punctuation">,</span> stride <span class="token operator">=</span> pool_param<span class="token punctuation">[</span><span class="token string">"pool_height"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pool_param<span class="token punctuation">[</span><span class="token string">"pool_width"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pool_param<span class="token punctuation">[</span><span class="token string">'stride'</span><span class="token punctuation">]</span>    new_H<span class="token punctuation">,</span> new_W <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>H <span class="token operator">-</span> h<span class="token punctuation">)</span> <span class="token operator">/</span> stride<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>W <span class="token operator">-</span> w<span class="token punctuation">)</span> <span class="token operator">/</span> stride<span class="token punctuation">)</span>    out <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> C<span class="token punctuation">,</span> new_H<span class="token punctuation">,</span> new_W<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>new_H<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>new_W<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token comment"># 按块取出最大值即可</span>                    max_pix <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span>n<span class="token punctuation">,</span> c<span class="token punctuation">,</span> i <span class="token operator">*</span> stride<span class="token punctuation">:</span> i <span class="token operator">*</span> stride <span class="token operator">+</span> h<span class="token punctuation">,</span> j <span class="token operator">*</span> stride<span class="token punctuation">:</span> j <span class="token operator">*</span> stride <span class="token operator">+</span> w<span class="token punctuation">]</span><span class="token punctuation">)</span>                    out<span class="token punctuation">[</span>n<span class="token punctuation">,</span> c<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> max_pix    cache <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> pool_param<span class="token punctuation">)</span>    <span class="token keyword">return</span> out<span class="token punctuation">,</span> cache    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-池化层的反向传播"><a href="#3-池化层的反向传播" class="headerlink" title="3.池化层的反向传播"></a>3.池化层的反向传播</h2><ul><li>反向传播涉及到池化层的求导问题，这里我们使用的是最大池化，因此也就是需要对max函数进行求导，而在ReLU层我们已经知道max函数的导数是分段的，小于0的部分是0，大于0的部分是1，而在池化层中也是一样的道理，对于进行池化操作的每个区域，最大的那个位置的梯度就是池化层向后传递的梯度，而其他地方都是0，我们可以在cache中记录原本矩阵的信息，并在池化层的反向传播过程中使用。</li><li>当然如果一个区域内有多个点的都是最大值的时候，可以把梯度进行平均分，这一过程在<code>max_pool_backward_naive</code>中通过一个<code>mask</code>矩阵来实现：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">max_pool_backward_naive</span><span class="token punctuation">(</span>dout<span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""A naive implementation of the backward pass for a max-pooling layer.    Inputs:    - dout: Upstream derivatives    - cache: A tuple of (x, pool_param) as in the forward pass.    Returns:    - dx: Gradient with respect to x    """</span>    dx <span class="token operator">=</span> <span class="token boolean">None</span>    x<span class="token punctuation">,</span> pool_param <span class="token operator">=</span> cache    h<span class="token punctuation">,</span> w<span class="token punctuation">,</span> stride <span class="token operator">=</span> pool_param<span class="token punctuation">[</span><span class="token string">"pool_height"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pool_param<span class="token punctuation">[</span><span class="token string">"pool_width"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pool_param<span class="token punctuation">[</span><span class="token string">'stride'</span><span class="token punctuation">]</span>    N<span class="token punctuation">,</span> C<span class="token punctuation">,</span> H<span class="token punctuation">,</span> W <span class="token operator">=</span> x<span class="token punctuation">.</span>shape    new_H<span class="token punctuation">,</span> new_W <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>H <span class="token operator">-</span> h<span class="token punctuation">)</span> <span class="token operator">/</span> stride<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>W <span class="token operator">-</span> w<span class="token punctuation">)</span> <span class="token operator">/</span> stride<span class="token punctuation">)</span>    dx <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>new_H<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>new_W<span class="token punctuation">)</span><span class="token punctuation">:</span>                    pool <span class="token operator">=</span> x<span class="token punctuation">[</span>n<span class="token punctuation">,</span> c<span class="token punctuation">,</span> i <span class="token operator">*</span> stride<span class="token punctuation">:</span> i <span class="token operator">*</span> stride <span class="token operator">+</span> h<span class="token punctuation">,</span> j <span class="token operator">*</span> stride<span class="token punctuation">:</span> j <span class="token operator">*</span> stride <span class="token operator">+</span> w<span class="token punctuation">]</span>                    mask <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>pool<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>                    mask<span class="token punctuation">[</span>pool <span class="token operator">==</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                    mask <span class="token operator">/=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>mask<span class="token punctuation">)</span>                    dx<span class="token punctuation">[</span>n<span class="token punctuation">,</span> c<span class="token punctuation">,</span> i <span class="token operator">*</span> stride<span class="token punctuation">:</span> i <span class="token operator">*</span> stride <span class="token operator">+</span> h<span class="token punctuation">,</span> j <span class="token operator">*</span> stride<span class="token punctuation">:</span> j <span class="token operator">*</span> stride <span class="token operator">+</span> w<span class="token punctuation">]</span> <span class="token operator">=</span> mask <span class="token operator">*</span> dout<span class="token punctuation">[</span>n<span class="token punctuation">,</span> c<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">]</span><span class="token keyword">return</span> dx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络7：卷积层</title>
      <link href="2021/05/13/coding7/"/>
      <url>2021/05/13/coding7/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络7：卷积层"><a href="#手写神经网络7：卷积层" class="headerlink" title="手写神经网络7：卷积层"></a>手写神经网络7：卷积层</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p><p>限于个人水平实在有限，我尽量减少参考网上代码的次数</p></blockquote><h2 id="1-什么是卷积层？"><a href="#1-什么是卷积层？" class="headerlink" title="1.什么是卷积层？"></a>1.什么是卷积层？</h2><h3 id="1-1卷积的计算公式"><a href="#1-1卷积的计算公式" class="headerlink" title="1.1卷积的计算公式"></a>1.1卷积的计算公式</h3><ul><li>卷积层是CNN中最核心的一个idea，通过卷积核(实质上就是一种滤波器)对输入的特征进行卷积运算，如果输入的数据是语音，那么数据是一维的，就可以进行一维卷积，如果输入的是矩阵，那么就可以进行二维的卷积，而CNN一般是用来处理图像的，图像是一种三维的数据(因为图像有颜色通道，每个通道上是一个二维矩阵，常见的RGB图像就是3颜色通道)，就需要用三维的卷积核对输入进行卷积操作。</li><li>假设一个卷积核的大小是$2M\times 2N$，那么 卷积的计算公式如下：</li></ul><p>$$<br>s\left[i,j\right]=(x*w)[i,j]=\sum_{m=-M}^M\sum_{n=-N}^Nx[i+m,j+n]w[m,n]<br>$$</p><p><img src="/2021/05/13/coding7/dl2.png" alt="卷积运算"></p><ul><li>比如上面这张图中，一个大小为32x32x3的图像使用一个5x5x3的卷积核进行卷积之后得到的就是28x28x3的新图像，我们称卷积之后得到的新的图像称为feature map</li></ul><h3 id="1-2步长Stride"><a href="#1-2步长Stride" class="headerlink" title="1.2步长Stride"></a>1.2步长Stride</h3><ul><li>卷积核的移动存在一个步长(stride)，卷积核移动的步长小于卷积核的边长时，变会出现卷积核与原始输入矩阵作用范围在区域上的<strong>重叠</strong>，卷积核移动的步长与卷积核的边长相一致时，不会出现重叠现象</li><li>因此卷积操作需要设定一个步长，步长也会决定得到的新的feature map的大小</li></ul><h3 id="1-3接受域Receptive-Field"><a href="#1-3接受域Receptive-Field" class="headerlink" title="1.3接受域Receptive Field"></a>1.3接受域Receptive Field</h3><ul><li>卷积核可以覆盖到的局部特征区域，比如一个3x3的卷积核可以包含一个3x3区域内的信息，那么其接收域就是3x3，随着层数的加深，接受域也在变大。大的步长也使得接受域的增大速度变快</li></ul><h3 id="1-4Padding操作"><a href="#1-4Padding操作" class="headerlink" title="1.4Padding操作"></a>1.4Padding操作</h3><ul><li>我们发现按照卷积的运算方式，处于图像的边缘处的像素点可能没有对应位置的像素点来计算其卷积(也就是说用上面的公式进行计算的时候，下标溢出了)，padding操作可以解决这一问题</li></ul><h3 id="1-5卷积层带来的突破"><a href="#1-5卷积层带来的突破" class="headerlink" title="1.5卷积层带来的突破"></a>1.5卷积层带来的突破</h3><ul><li>《深度学习（花书）》中提出卷积这一操作的引入带来的突破有：<ul><li>稀疏交互Sparse interactions<ul><li>传统的神经网络使用矩阵乘法来建立输入输出的连接关系，参数矩阵中的每一个参数都代表了输入和输出的交互关系，而卷积层的运算因为卷积核的大小一般是远小于图像的大小的，因此只需要较少的计算量就可以提取关键的图像信息(比如图像的边缘)</li><li>传统情况下，如果有m维度的输入和n维度的输出，那么参数矩阵就需要$m\times n$的规模，这种时候其实就是一种输入到输出的全连接，<strong>通过卷积运算，减少了从输入到输出的连接数量</strong></li></ul></li><li>参数共享Parameter Sharing<ul><li>参数共享是说可以在一个模型的多个函数中使用一样的参数，传统的神经网络中，当计算了一层的输入的时候，权重矩阵的每一个元素只能使用一次，也就是说网络中有绑定的权重</li><li>在CNN中，核的每个元素都作用在输入的每一个位置上，卷积运算的参数共享保证了只需要学习一个参数集合而不是对于每一个位置都需要学习一个单独的参数集合。</li></ul></li><li>等变表示Equivariant Representation<ul><li>如果一个函数满足输入改变，输出也以同样的方式改变，那么就可以称这个函数是等变的，如果对于函数f和g有$f(g(x))=g(f(x))$那么就称f和g具有等变性。</li><li>对于卷积而言，参数共享的特殊形式是的神经网络层具有对平移操作等变的性质，这里可以令g为平移函数，那么g就可以表示图像函数的变换函数。</li><li>简而言之这一性质表明，对于图像中一些需要提取的特征，<strong>即使图像发生了平移，这个特征依然存在只是发生了对应的平移而已，仍然可以用一样的方式提取出来</strong>。在处理时间序列数据的时候，这个性质意味着卷积可以得到一个由输入中出现不同特征的时刻所组成的时间轴。</li></ul></li></ul></li></ul><h2 id="2-卷积层的代码实现"><a href="#2-卷积层的代码实现" class="headerlink" title="2.卷积层的代码实现"></a>2.卷积层的代码实现</h2><ul><li>下面使用一个函数<code>conv_forward_naive</code>来实现一种非常naive的卷积层计算方法，事实上就是用多重循环将卷积的结果一个个算出来。注意这里的卷积运算有个bias，上面的公式没有提到</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">conv_forward_naive</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> conv_param<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token triple-quoted-string string">"""    - x: Input data of shape (N, C, H, W)    - w: Filter weights of shape (F, C, HH, WW)    - b: Biases, of shape (F,)    Returns a tuple of:    - out: Output data, of shape (N, F, H', W') where H' and W' are given by      H' = 1 + (H + 2 * pad - HH) / stride      W' = 1 + (W + 2 * pad - WW) / stride    - cache: (x, w, b, conv_param)    """</span>    out <span class="token operator">=</span> <span class="token boolean">None</span>    stride <span class="token operator">=</span> conv_param<span class="token punctuation">[</span><span class="token string">"stride"</span><span class="token punctuation">]</span>    pad <span class="token operator">=</span> conv_param<span class="token punctuation">[</span><span class="token string">"pad"</span><span class="token punctuation">]</span>    N<span class="token punctuation">,</span> C<span class="token punctuation">,</span> H<span class="token punctuation">,</span> W <span class="token operator">=</span> x<span class="token punctuation">.</span>shape    F<span class="token punctuation">,</span> C<span class="token punctuation">,</span> HH<span class="token punctuation">,</span> WW <span class="token operator">=</span> w<span class="token punctuation">.</span>shape    new_H<span class="token punctuation">,</span> new_W <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>H <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> pad <span class="token operator">-</span> HH<span class="token punctuation">)</span> <span class="token operator">/</span> stride<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>W <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> pad <span class="token operator">-</span> WW<span class="token punctuation">)</span> <span class="token operator">/</span> stride<span class="token punctuation">)</span>    out <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> F<span class="token punctuation">,</span> new_H<span class="token punctuation">,</span> new_W<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 对x进行zero-pad操作，得到一个扩充后的矩阵，这里只对x的第三四个维度(也就是像素值所在的维度)进行扩充</span>    x_pad <span class="token operator">=</span> np<span class="token punctuation">.</span>pad<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>pad<span class="token punctuation">,</span> pad<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>pad<span class="token punctuation">,</span> pad<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'constant'</span><span class="token punctuation">,</span> constant_values<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>        new_x <span class="token operator">=</span> x_pad<span class="token punctuation">[</span>n<span class="token punctuation">]</span>        <span class="token keyword">for</span> f <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 得到卷积核</span>            kernel <span class="token operator">=</span> w<span class="token punctuation">[</span>f<span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>new_H<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>new_W<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token comment"># 取出对应的卷积区域，并进行计算</span>                    conv_zone <span class="token operator">=</span> new_x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i <span class="token operator">*</span> stride<span class="token punctuation">:</span> i <span class="token operator">*</span> stride <span class="token operator">+</span> HH<span class="token punctuation">,</span> j <span class="token operator">*</span> stride<span class="token punctuation">:</span> j <span class="token operator">*</span> stride <span class="token operator">+</span> WW<span class="token punctuation">]</span>                    conv_res <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>conv_zone <span class="token operator">*</span> kernel<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>f<span class="token punctuation">]</span>                    out<span class="token punctuation">[</span>n<span class="token punctuation">,</span> f<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> conv_res    cache <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> conv_param<span class="token punctuation">)</span>    <span class="token keyword">return</span> out<span class="token punctuation">,</span> cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当然这种实现方式是非常naive的，只能用来测试自己是否理解了卷积操作，真的用来构建神经网络的话计算效率会非常低，CS231N的assignment2中给出了cpython加速的卷积操作的向量化实现，可以较大地提高计算的效率。</li></ul><h2 id="3-卷积层的反向传播"><a href="#3-卷积层的反向传播" class="headerlink" title="3.卷积层的反向传播"></a>3.卷积层的反向传播</h2><ul><li>卷积的反向传播比较简单，我们假设卷积核的大小是$2M\times 2N$，那么对于卷积后得到的feature map的一个像素点$s_{ij}$，我们根据上面的卷积公式可以得到：</li></ul><p>$$<br>\frac{\partial s_{ij}}{\partial x_{i+m,j+n}}=w_{mn}，m\in [-M,M],n\in [-N,N]<br>$$</p><p>$$<br>\frac{\partial s_{ij}}{\partial w_{mn}}=x_{i+m,j+n},，m\in [-M,M],n\in [-N,N]<br>$$</p><p>$$<br>\frac{\partial s_{ij}}{\partial b}=1^{2M\times 2N}<br>$$</p><ul><li>因此反向传播求dx的时候只要把feature map的每个像素点进行遍历，把权重加到原位置的点上就可以，并且还要乘上传递到这一层的梯度dout，具体的代码实现如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">conv_backward_naive</span><span class="token punctuation">(</span>dout<span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""A naive implementation of the backward pass for a convolutional layer.    Inputs:    - dout: Upstream derivatives.    - cache: A tuple of (x, w, b, conv_param) as in conv_forward_naive    Returns a tuple of:    - dx: Gradient with respect to x    - dw: Gradient with respect to w    - db: Gradient with respect to b    """</span>    dx<span class="token punctuation">,</span> dw<span class="token punctuation">,</span> db <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> Nonex<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> conv_param <span class="token operator">=</span> cache    stride <span class="token operator">=</span> conv_param<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'stride'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    pad <span class="token operator">=</span> conv_param<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'pad'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># 定义好梯度的大小</span>    dx <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float64<span class="token punctuation">)</span>    dw <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>w<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float64<span class="token punctuation">)</span>    db <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>b<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float64<span class="token punctuation">)</span>    N<span class="token punctuation">,</span> C<span class="token punctuation">,</span> H<span class="token punctuation">,</span> W <span class="token operator">=</span> x<span class="token punctuation">.</span>shape    F<span class="token punctuation">,</span> C_prime<span class="token punctuation">,</span> HH<span class="token punctuation">,</span> WW <span class="token operator">=</span> w<span class="token punctuation">.</span>shape    H_prime <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>H <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> pad <span class="token operator">-</span> HH<span class="token punctuation">)</span> <span class="token operator">/</span> stride<span class="token punctuation">)</span>    W_prime <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>W <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> pad <span class="token operator">-</span> WW<span class="token punctuation">)</span> <span class="token operator">/</span> stride<span class="token punctuation">)</span>    <span class="token comment"># 进行padding操作</span>    dx_pad <span class="token operator">=</span> np<span class="token punctuation">.</span>pad<span class="token punctuation">(</span>dx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>pad<span class="token punctuation">,</span> pad<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>pad<span class="token punctuation">,</span> pad<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'constant'</span><span class="token punctuation">,</span> constant_values<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    x_pad <span class="token operator">=</span> np<span class="token punctuation">.</span>pad<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>pad<span class="token punctuation">,</span> pad<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>pad<span class="token punctuation">,</span> pad<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'constant'</span><span class="token punctuation">,</span> constant_values<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>        x_i <span class="token operator">=</span> x_pad<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span><span class="token punctuation">:</span>            w_j <span class="token operator">=</span> w<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token keyword">for</span> h_now <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>H_prime<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> w_now <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>W_prime<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token comment"># 在原来的对应像素位置上，按照权重加上梯度</span>                    db<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dout<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> h_now<span class="token punctuation">,</span> w_now<span class="token punctuation">]</span>                    dx_pad<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> h_now <span class="token operator">*</span> stride<span class="token punctuation">:</span>h_now <span class="token operator">*</span> stride <span class="token operator">+</span> HH<span class="token punctuation">,</span> w_now <span class="token operator">*</span> stride<span class="token punctuation">:</span>w_now <span class="token operator">*</span> stride <span class="token operator">+</span> WW<span class="token punctuation">]</span> <span class="token operator">+=</span> dout<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> h_now<span class="token punctuation">,</span> w_now<span class="token punctuation">]</span> <span class="token operator">*</span> w_j                    dw<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dout<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> h_now<span class="token punctuation">,</span> w_now<span class="token punctuation">]</span> <span class="token operator">*</span> x_i<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> h_now <span class="token operator">*</span> stride<span class="token punctuation">:</span>h_now <span class="token operator">*</span> stride <span class="token operator">+</span> HH<span class="token punctuation">,</span> w_now <span class="token operator">*</span> stride<span class="token punctuation">:</span>w_now <span class="token operator">*</span> stride <span class="token operator">+</span> WW<span class="token punctuation">]</span>    dx <span class="token operator">=</span> dx_pad<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> pad<span class="token punctuation">:</span><span class="token operator">-</span>pad<span class="token punctuation">,</span> pad<span class="token punctuation">:</span><span class="token operator">-</span>pad<span class="token punctuation">]</span>    <span class="token keyword">return</span> dx<span class="token punctuation">,</span> dw<span class="token punctuation">,</span> db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络6：Normalization</title>
      <link href="2021/05/13/coding6/"/>
      <url>2021/05/13/coding6/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络6：Normalization层"><a href="#手写神经网络6：Normalization层" class="headerlink" title="手写神经网络6：Normalization层"></a>手写神经网络6：Normalization层</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p><p>限于个人水平实在有限，我尽量减少参考网上代码的次数</p></blockquote><h2 id="1-什么是Normalization？"><a href="#1-什么是Normalization？" class="headerlink" title="1.什么是Normalization？"></a>1.什么是Normalization？</h2><ul><li>Normalization是神经网络训练中的另一种trick，中文译名是标准化或者归一化，我比较喜欢前一种翻译。最早应该是在<a href="https://arxiv.org/pdf/1502.03167.pdf">这篇论文</a>中提出的，是一种提高神经网络训练效率和预测准确度的trick，有好几种不同的形式，比如批标准化(batch normalization)，层标准化(layer normalization)等等</li></ul><h2 id="2-批标准化Batch-Normalization"><a href="#2-批标准化Batch-Normalization" class="headerlink" title="2.批标准化Batch Normalization"></a>2.批标准化Batch Normalization</h2><h3 id="2-1概念"><a href="#2-1概念" class="headerlink" title="2.1概念"></a>2.1概念</h3><ul><li><p>批标准化在神经网络中通过一个批标准化层来实现，这个层一般都放在激活函数层之前，每次训练的时候选择一个小批量的数据集进行训练，然后将这样一个小批量的数据进行标准化处理，具体的处理包括：</p></li><li><p>先求出这个小批量数据集$\mathcal B$训练后的均值和方差：</p></li></ul><p>$$<br>\mu_{\mathcal B}=\frac 1m\sum_{i=1}^m x_i<br>$$</p><p>$$<br>\sigma^2_{\mathcal B}=\frac 1m\sum_{i=1}^m(x_i-\mu_{\mathcal B})^2<br>$$</p><ul><li>然后对每个x进行标准化：</li></ul><p>$$<br>\hat x_i =\frac{x_i-\mu_{\mathcal B}}{\sqrt{\sigma^2+\epsilon}}<br>$$</p><ul><li>然后再进行scale和shift，具体来说就是再对标准化后的$x$进行一个线性变换，得到结果$y$并输入到激活函数层</li></ul><p>$$<br>y_i=\gamma \hat x+\beta=\gamma\frac{x_i-\mu_{\mathcal B}}{\sqrt{\sigma^2+\epsilon}} +\beta<br>$$</p><h3 id="2-2实际训练中的动量优化"><a href="#2-2实际训练中的动量优化" class="headerlink" title="2.2实际训练中的动量优化"></a>2.2实际训练中的动量优化</h3><ul><li>批标准化的训练规模相对于数据样本总体而言是比较小的，因此在训练过程中会有很多批次，而这个时候直接使用一个批的统计信息(均值和方差)来标准化一批数据相对于总体而言可能会引入较大的bias，因此真正的批标准化会使用<code>running_mean</code>和<code>running_var</code>来记录训练过程中所有出现过的批数据的统计信息，同时使用一个动量<code>momentum</code>来规定均值和方差更新时候的更新率，具体的更新公式如下：</li></ul><p>$$<br>\mu_{running}=m\times \mu_{running}+(1-m)\times \mu_{batch}<br>$$</p><p>$$<br>\sigma^2_{running}=m\times \sigma^2_{running}+(1-m)\times \sigma^2_{batch}<br>$$</p><ul><li>但是在测试模式的时候不用测试数据来更新<code>running_mean</code>和<code>running_var</code>，而是直接使用<code>running_mean</code>和<code>running_var</code>作为标准化时候所用的参数</li></ul><h3 id="2-3前向传播的代码实现"><a href="#2-3前向传播的代码实现" class="headerlink" title="2.3前向传播的代码实现"></a>2.3前向传播的代码实现</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">batchnorm_forward</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> gamma<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> bn_param<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Forward pass for batch normalization.    Input:    - x: Data of shape (N, D)    - gamma: Scale parameter of shape (D,)    - beta: Shift parameter of shape (D,)    - bn_param: Dictionary with the following keys:      - mode: 'train' or 'test'; required      - eps: Constant for numeric stability      - momentum: Constant for running mean / variance.      - running_mean: Array of shape (D,) giving running mean of features      - running_var Array of shape (D,) giving running variance of features    Returns a tuple of:    - out: of shape (N, D)    - cache: A tuple of values needed in the backward pass    """</span>    mode <span class="token operator">=</span> bn_param<span class="token punctuation">[</span><span class="token string">"mode"</span><span class="token punctuation">]</span>    eps <span class="token operator">=</span> bn_param<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"eps"</span><span class="token punctuation">,</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span>    momentum <span class="token operator">=</span> bn_param<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"momentum"</span><span class="token punctuation">,</span> <span class="token number">0.9</span><span class="token punctuation">)</span>    N<span class="token punctuation">,</span> D <span class="token operator">=</span> x<span class="token punctuation">.</span>shape    running_mean <span class="token operator">=</span> bn_param<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"running_mean"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>D<span class="token punctuation">,</span> dtype<span class="token operator">=</span>x<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token punctuation">)</span>    running_var <span class="token operator">=</span> bn_param<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"running_var"</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>D<span class="token punctuation">,</span> dtype<span class="token operator">=</span>x<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token punctuation">)</span>    out<span class="token punctuation">,</span> cache <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span>    <span class="token keyword">if</span> mode <span class="token operator">==</span> <span class="token string">"train"</span><span class="token punctuation">:</span>        sample_mean <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>x<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        sample_var <span class="token operator">=</span> np<span class="token punctuation">.</span>var<span class="token punctuation">(</span>x<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        x_hat <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> sample_mean<span class="token punctuation">)</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>sample_var <span class="token operator">+</span> eps<span class="token punctuation">)</span>        out <span class="token operator">=</span> gamma <span class="token operator">*</span> x_hat <span class="token operator">+</span> beta        cache <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> gamma<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> x_hat<span class="token punctuation">,</span> sample_mean<span class="token punctuation">,</span> sample_var<span class="token punctuation">,</span> eps<span class="token punctuation">)</span>        <span class="token comment"># 更新running mean和variance</span>        running_mean <span class="token operator">=</span> momentum <span class="token operator">*</span> running_mean <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> momentum<span class="token punctuation">)</span> <span class="token operator">*</span> sample_mean        running_var <span class="token operator">=</span> momentum <span class="token operator">*</span> running_var <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> momentum<span class="token punctuation">)</span> <span class="token operator">*</span> sample_var    <span class="token keyword">elif</span> mode <span class="token operator">==</span> <span class="token string">"test"</span><span class="token punctuation">:</span>        hat_x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> running_mean<span class="token punctuation">)</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>running_var <span class="token operator">+</span> eps<span class="token punctuation">)</span>        out <span class="token operator">=</span> gamma <span class="token operator">*</span> hat_x <span class="token operator">+</span> beta    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'Invalid forward batch norm mode "%s"'</span> <span class="token operator">%</span> mode<span class="token punctuation">)</span>    <span class="token comment"># Store the updated running means back into bn_param</span>    bn_param<span class="token punctuation">[</span><span class="token string">"running_mean"</span><span class="token punctuation">]</span> <span class="token operator">=</span> running_mean    bn_param<span class="token punctuation">[</span><span class="token string">"running_var"</span><span class="token punctuation">]</span> <span class="token operator">=</span> running_var    <span class="token keyword">return</span> out<span class="token punctuation">,</span> cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4反向传播的推导"><a href="#2-4反向传播的推导" class="headerlink" title="2.4反向传播的推导"></a>2.4反向传播的推导</h3><ul><li>这一部分实际上是批标准化过程中最麻烦的一部分，<del>因为我求导经常出问题</del>，首先我们知道最终输出结果是关于样本、均值，方差三者的函数，即：</li></ul><p>$$<br>y_i=\gamma f(x_i,\mu,\sigma^2)+\beta<br>$$</p><ul><li>我们如果假设反向传递到这一层的梯度是<code>dout</code>，那么我们就需要求出$y_i$相对于$\gamma,\beta, x_i$三者的导数并用于梯度的更新，而相对于$\gamma,\beta$的导数是比较容易求的，主要的问题在于求出关于$x_i$的导数，我们不妨假设输出层处的损失函数是L，那么我们有：</li></ul><p>$$<br>\frac{\partial L}{\partial \gamma}=\sum_{i=1}^m \left(\frac{\partial L}{\partial y_i}\times \hat x_i\right )=\sum_{i=1}^m \text{dout}_i \times x_i<br>$$</p><p>$$<br>\frac{\partial L}{\partial \beta}=\sum_{i=1}^m \left(\frac{\partial L}{\partial y_i}\right )=\sum_{i=1}^m \text{dout}_i<br>$$</p><ul><li>下面我们重点来推导$y_i$关于$x_i$的导数，首先根据微积分中的基本知识，我们知道：</li></ul><p>$$<br>\frac{\partial L}{\partial x_i}=\frac{\partial L}{\partial y_i}\times \frac{\partial y_i}{\partial x_i}=\text{dout}_i\times\gamma\times \frac{\partial \hat x_i}{\partial x_i}<br>$$</p><p>$$<br>\frac{\partial \hat x_i}{\partial x_i}=\frac{\partial \hat x_i}{\partial \mu_i}\times \frac{\partial \mu_i}{\partial x_i}+\frac{\partial \hat x_i}{\partial \sigma^2_i}\times \frac{\partial \sigma^2_i}{\partial x_i}+\frac{\partial \hat x_i}{\partial x_i}<br>$$</p><ul><li>下面我们按部就班一个个来求导即可：</li></ul><p>$$<br>\frac{\partial\mu }{\partial x_i}=\frac 1m<br>$$</p><p>$$<br>\frac{\partial \sigma^2}{\partial x_i}=\frac 2m(x_i-\mu)<br>$$</p><p>$$<br>\frac{\partial \hat x_i}{\partial x_i}=\frac {1}{\sqrt{\sigma^2+\epsilon}}<br>$$</p><p>$$<br>\frac{\partial \hat x_i}{\partial \sigma^2}=-\frac 12(x_i-\mu)(\sigma^2+\epsilon)^{-\frac 32}<br>$$</p><p>$$<br>\frac{\partial \hat x_i}{\partial \mu}=-\frac {1}{\sqrt{\sigma^2+\epsilon}}+\frac{\partial \hat x_i}{\partial \sigma^2}\times -\frac 2m(x_i-\mu)<br>$$</p><ul><li>最终的梯度结果将上面的偏导数分别求出然后按照规则组合起来就可以</li></ul><h3 id="2-5反向传播的代码实现"><a href="#2-5反向传播的代码实现" class="headerlink" title="2.5反向传播的代码实现"></a>2.5反向传播的代码实现</h3><ul><li>这里我们使用函数<code>batchnorm_backward_alt</code>实现了批标准化的反向传播</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">batchnorm_backward_alt</span><span class="token punctuation">(</span>dout<span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">:</span>    dx<span class="token punctuation">,</span> dgamma<span class="token punctuation">,</span> dbeta <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span>    x<span class="token punctuation">,</span> gamma<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> x_hat<span class="token punctuation">,</span> mu<span class="token punctuation">,</span> var<span class="token punctuation">,</span> eps <span class="token operator">=</span> cache    M <span class="token operator">=</span> x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 先求出比较简单的gamma和dbeta的梯度</span>    dgamma <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>x_hat <span class="token operator">*</span> dout<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    dbeta <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dout<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># 求出dx，首先计算一个系数</span>    dx_hat <span class="token operator">=</span> dout <span class="token operator">*</span> gamma    <span class="token comment"># 求出关于方差的导数</span>    d_var <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dx_hat <span class="token operator">*</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> mu<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">0.5</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>var <span class="token operator">+</span> eps<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token operator">-</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># 求出关于均值的导数</span>    d_mean <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dx_hat <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>var <span class="token operator">+</span> eps<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> d_var <span class="token operator">*</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> mu<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># 最终的计算结果</span>    dx <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>var <span class="token operator">+</span> eps<span class="token punctuation">)</span> <span class="token operator">*</span> dx_hat <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> d_var <span class="token operator">/</span> M <span class="token operator">*</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> mu<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">/</span> M <span class="token operator">*</span> d_mean    <span class="token keyword">return</span> dx<span class="token punctuation">,</span> dgamma<span class="token punctuation">,</span> dbeta<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>要注意和公式一一对应</li></ul><h2 id="3-层标准化Layer-Normalization"><a href="#3-层标准化Layer-Normalization" class="headerlink" title="3.层标准化Layer Normalization"></a>3.层标准化Layer Normalization</h2><ul><li>层标准化是另一种标准化的方式，其core idea是将每个样本的d维特征的值进行标准化，实际上就是换了一个维度的批标准化，代码实现也比较容易，基本和上面的代码完全一致，只不过把axis改成1表示换了一个维度，其他的内容基本一致，这里代码就不放出来了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络5：DropOut层</title>
      <link href="2021/05/12/coding5/"/>
      <url>2021/05/12/coding5/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络5：DropOut层"><a href="#手写神经网络5：DropOut层" class="headerlink" title="手写神经网络5：DropOut层"></a>手写神经网络5：DropOut层</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p><p>限于个人水平实在有限，我尽量减少参考网上代码的次数</p></blockquote><h2 id="1-DropOut层的概念"><a href="#1-DropOut层的概念" class="headerlink" title="1.DropOut层的概念"></a>1.DropOut层的概念</h2><ul><li>DropOut的原意为“退学”，是一种在神经网络的<strong>训练中用的比较多的trick</strong>，DropOut最早是在<a href="http://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf">这篇论文</a>中提出的一个概念，用来解决神经网络训练过程中的过拟合问题</li><li>DropOut的基本想法就是设定一个DropOut的概率$p$，当某一层的神经元被设定了这个概率$p$之后，就会出现以下两种情况：<ul><li>训练的时候，对每个神经元而言，它有$p$的概率保持正常的工作状态，而有$1-p$的概率“休息”，也就是不参与到神经网络的前向传播和反向传播过程中</li><li>测试的时候所有的神经元都参与到结果的预测中去</li></ul></li></ul><img src="image-20210512194051723.png" alt="训练时的DropOut" style="zoom: 67%;" /><h2 id="2-DropOut为什么有效"><a href="#2-DropOut为什么有效" class="headerlink" title="2.DropOut为什么有效"></a>2.DropOut为什么有效</h2><ul><li>论文中解释到，这是因为神经网络的训练本质上是将神经元训练出一种“协同作战”的能力，即神经元共同参与到最终的决策中，因此神经元之间的相互依赖性是比较强的，如果这个时候出现了一些表现不好的神经元，就会把所有的神经元<strong>带偏</strong>，并且随着放大效应逐渐累积。</li><li>而DropOut使得每次训练的过程中只有一部分神经元参与到训练中，并且每次参与的神经元的组合还很有可能不一样(因为设定了概率p)，这使得神经网络中的神经元形成了“小团队协作”的能力，<strong>增强了神经网络中单个神经元的预测能力</strong>(因为训练的时候神经元个数减少意味着一个神经元需要负责学习更多的知识)，这样一来预测的准确度也就随之提高了</li><li>当然这样的说法并没有严格的数学证明，可是原论文在经过多种实验之后发现效果确实有所提升。</li></ul><h2 id="3-DropOut的代码实现"><a href="#3-DropOut的代码实现" class="headerlink" title="3.DropOut的代码实现"></a>3.DropOut的代码实现</h2><ul><li>前向传播用一个函数<code>dropout_forward</code>来表示</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dropout_forward</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> dropout_param<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Forward pass for inverted dropout:    - x: Input data, of any shape    - dropout_param: A dictionary with the following keys:      - p: Dropout parameter. We keep each neuron output with probability p.      - mode: 'test' or 'train'. If the mode is train, then perform dropout;        if the mode is test, then just return the input.      - seed: Seed for the random number generator. Passing seed makes this        function deterministic, which is needed for gradient checking but not        in real networks.    Outputs:    - out: Array of the same shape as x.    - cache: tuple (dropout_param, mask). In training mode, mask is the dropout      mask that was used to multiply the input; in test mode, mask is None.    """</span>    p<span class="token punctuation">,</span> mode <span class="token operator">=</span> dropout_param<span class="token punctuation">[</span><span class="token string">"p"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dropout_param<span class="token punctuation">[</span><span class="token string">"mode"</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token string">"seed"</span> <span class="token keyword">in</span> dropout_param<span class="token punctuation">:</span>        np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span>dropout_param<span class="token punctuation">[</span><span class="token string">"seed"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    mask <span class="token operator">=</span> <span class="token boolean">None</span>    out <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token comment"># 按概率p生成一个0-1分布，并和原本的输入数据相乘</span>    <span class="token comment"># mask中某一位为0表示对应神经元不参与到下一层的传播中</span>    <span class="token keyword">if</span> mode <span class="token operator">==</span> <span class="token string">"train"</span><span class="token punctuation">:</span>        mask <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token operator">*</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token operator">&lt;</span> p        out <span class="token operator">=</span> x <span class="token operator">*</span> mask<span class="token punctuation">.</span>astype<span class="token punctuation">(</span>x<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>    <span class="token comment"># 测试模式下不用管DropOut</span>    <span class="token keyword">elif</span> mode <span class="token operator">==</span> <span class="token string">"test"</span><span class="token punctuation">:</span>        out <span class="token operator">=</span> x    cache <span class="token operator">=</span> <span class="token punctuation">(</span>dropout_param<span class="token punctuation">,</span> mask<span class="token punctuation">)</span>    out <span class="token operator">=</span> out<span class="token punctuation">.</span>astype<span class="token punctuation">(</span>x<span class="token punctuation">.</span>dtype<span class="token punctuation">,</span> copy<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> out<span class="token punctuation">,</span> cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>反向传播的过程的代码如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dropout_backward</span><span class="token punctuation">(</span>dout<span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Backward pass for inverted dropout.    Inputs:    - dout: Upstream derivatives, of any shape    - cache: (dropout_param, mask) from dropout_forward.    """</span>    dropout_param<span class="token punctuation">,</span> mask <span class="token operator">=</span> cache    mode <span class="token operator">=</span> dropout_param<span class="token punctuation">[</span><span class="token string">"mode"</span><span class="token punctuation">]</span>    dx <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token comment"># 反向传播的时候更简单，只要把mask和dout相乘即可，也就是没有参与的神经元不更新其参数</span>    <span class="token keyword">if</span> mode <span class="token operator">==</span> <span class="token string">"train"</span><span class="token punctuation">:</span>        dx <span class="token operator">=</span> dout <span class="token operator">*</span> mask    <span class="token keyword">elif</span> mode <span class="token operator">==</span> <span class="token string">"test"</span><span class="token punctuation">:</span>        dx <span class="token operator">=</span> dout    <span class="token keyword">return</span> dx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习代码实现2：贝叶斯定理与参数估计</title>
      <link href="2021/05/10/coding-ml2/"/>
      <url>2021/05/10/coding-ml2/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习代码实现2：贝叶斯模型"><a href="#机器学习代码实现2：贝叶斯模型" class="headerlink" title="机器学习代码实现2：贝叶斯模型"></a>机器学习代码实现2：贝叶斯模型</h1><blockquote><p>这一专题的内容主要是我在进行统计机器学习的算法的代码实践的过程中的一些记录，包括公式的推导，算法的实现与数据集的实验结果。</p><p>这部分工作我比较早之前就已经开始做了，现在刚好趁此机会整理一下之前写过的所有小demo，汇总成一个完成的库</p></blockquote><h2 id="1-贝叶斯定理"><a href="#1-贝叶斯定理" class="headerlink" title="1.贝叶斯定理"></a>1.贝叶斯定理</h2><ul><li>贝叶斯定理主要是用来判断一个数据样本$x$是否属于类别$y$，其理论主要就是基于下面的公式：</li></ul><p>$$<br>p(y|x)=\frac{p(x|y)p(y)}{P(x)}<br>$$</p><ul><li>这里的$p(y)$称为先验概率，也就是目前已经知道的类别$y$的分布情况，而$p(x|y)$叫做似然likelihood，表示的是当前已知的属于类别$y$的$x$的情况，也就是说我们要判断一个样本$x$是否属于类别$y$，我们需要先得到已经属于类别$y$的同类$x$的概率和类别$y$本身出现的概率，这样就可以估计当前的$x$属于类别$y$的概率</li><li>当有C个类别$\omega_i$的时候，贝叶斯定理可以表示为：</li></ul><p>$$<br>P(\omega_j|x_i)=\frac{P(x_i|\omega_j)P(\omega_j)}{P(x_i)}=\frac{P(x_i|\omega_j)P(\omega_j)}{\sum_{k=1}^C P(x_i|\omega_k)P(\omega_k)}<br>$$</p><ul><li>计算出结果之后，根据极大似然的规则，让可能性最高的$y$作为样本类别的预测结果。</li><li>因此在训练一个贝叶斯分类器的时候，我们要得到一个类别-特征的分布矩阵，我们可以假设可能的预测结果有$C$类，而不同的特征可能取值有$N$种，这样一来，我们就可以得到一个$C\times N$的矩阵$W$，矩阵中的每一个元素代表了某一种特征情况输入这一类别的概率(或者出现的次数也可以，需要再进一步处理)</li></ul><h2 id="2-贝叶斯定理代码实现"><a href="#2-贝叶斯定理代码实现" class="headerlink" title="2.贝叶斯定理代码实现"></a>2.贝叶斯定理代码实现</h2><ul><li>代码实现中我们重点需要关注$P(x_i|\omega_j)$和$P(\omega_j)$的计算，对于$P(\omega_j)$，我们可以对矩阵$W$先按行求和，得到训练集中每种样本的出现数量，然后除以样本总数就可以得到每种类别对应的概率分布，然后$P(x_i|\omega_j)$是对于矩阵$W$的每一行中的元素分别乘以该行的元素总量之和</li><li>最终的贝叶斯定理代码实现如下所示：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Bayes</span><span class="token punctuation">:</span>  <span class="token comment"># 计算似然，也就是P(x_i|\omega_j)的值</span>    <span class="token keyword">def</span> <span class="token function">likelihood</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">:</span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        计算数据集的似然        :param X: 输入的数据集，表示不同类别的特征分布情况，大小是C*N，其中C是类别的个数，N是特征的个数        :return: 数据集的似然        """</span>        self<span class="token punctuation">.</span>C<span class="token punctuation">,</span> self<span class="token punctuation">.</span>N <span class="token operator">=</span> X<span class="token punctuation">.</span>shape        self<span class="token punctuation">.</span>likelihood <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>        class_sum <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>likelihood<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> X<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">/</span> class_sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>likelihood     <span class="token comment"># 计算后验概率，当然这里写的比较naive没有向量化</span>    <span class="token keyword">def</span> <span class="token function">posterior</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">:</span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>C<span class="token punctuation">,</span> self<span class="token punctuation">.</span>N <span class="token operator">=</span> X<span class="token punctuation">.</span>shape        self<span class="token punctuation">.</span>p <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>        likelihood <span class="token operator">=</span> self<span class="token punctuation">.</span>likelihood<span class="token punctuation">(</span>X<span class="token punctuation">)</span>        prior <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span>        p_X <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>self<span class="token punctuation">.</span>N<span class="token punctuation">)</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>                p_X<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> likelihood<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">*</span> prior<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>p<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> likelihood<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">*</span> prior<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> p_X<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-数据集实验"><a href="#3-数据集实验" class="headerlink" title="3.数据集实验"></a>3.数据集实验</h2><ul><li><p>这里使用的数据集来自浙江大学蔡登教授开设的《机器学习》课程，这里的数据集仅有1维特征和标签，比较简单。我们分别对仅使用似然和使用后验概率来进行预测的结果进行了可视化，得到的结果是：</p><ul><li>似然：</li></ul><img src="image-20210510215345124.png" alt="似然分布情况" style="zoom: 50%;" /><ul><li>后验概率：</li></ul><img src="image-20210510215408910.png" alt="后验概率分布情况" style="zoom:50%;" /></li></ul><h2 id="4-参数估计与代码实现"><a href="#4-参数估计与代码实现" class="headerlink" title="4.参数估计与代码实现"></a>4.参数估计与代码实现</h2><ul><li>事实上我们也发现了贝叶斯定理的核心问题在于如何计算$P(x|y)$，这里我们可以使用正态分布作为工具，多远正态分布的定义式是：</li></ul><p>$$<br>P(\boldsymbol x|\mu,\Sigma)=\mathcal{N}(x|\mu,\Sigma^2)=\frac{1}{({2\pi})^{\frac{d}{2}}|\Sigma|^{\frac{1}{2}}}\exp[-\frac{1}{2}(\boldsymbol x-\mu)^{T}\Sigma^{-1}(\boldsymbol x-\mu)]<br>$$</p><ul><li>而正态分布模型的参数估计的表达式是：</li></ul><p>$$<br>\mu=\frac 1N \sum_{i=1}^N x_i<br>$$</p><p>$$<br>\sigma^2=\frac 1N\sum_{i=1}^N(x_i-\mu)^2<br>$$</p><ul><li>我们可以用样本数据集X来估计出正态分布模型的参数，然后用这个正态分布模型来计算likelihood，再根据贝叶斯定理算出后验概率，最后按照最大的概率作为决策。</li><li>参数估计的代码实现如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">gaussian_pos_prob</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Mu<span class="token punctuation">,</span> Sigma<span class="token punctuation">,</span> Phi<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    GAUSSIAN_POS_PROB Posterior probability of GDA.    Compute the posterior probability of given N data points X    using Gaussian Discriminant Analysis where the K gaussian distributions    are specified by Mu, Sigma and Phi.    Inputs:        'X'     - M-by-N numpy array, N data points of dimension M.        'Mu'    - M-by-K numpy array, mean of K Gaussian distributions.        'Sigma' - M-by-M-by-K  numpy array (yes, a 3D matrix), variance matrix of                  K Gaussian distributions.        'Phi'   - 1-by-K  numpy array, prior of K Gaussian distributions.    Outputs:        'p'     - N-by-K  numpy array, posterior probability of N data points                with in K Gaussian distribsubplots_adjustutions.    """</span>    N <span class="token operator">=</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    K <span class="token operator">=</span> Phi<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    p <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> K<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 先计算likelihood</span>    likelihood <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> K<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>        p_x <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">:</span>            x_minus_mu <span class="token operator">=</span> X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">-</span> Mu<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> j<span class="token punctuation">]</span>            sigma <span class="token operator">=</span> Sigma<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> j<span class="token punctuation">]</span>            <span class="token comment"># 估计参数，并构造一个高斯函数</span>            det_sigma <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>det<span class="token punctuation">(</span>sigma<span class="token punctuation">)</span>            inv_sigma <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>inv<span class="token punctuation">(</span>sigma<span class="token punctuation">)</span>            base <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi <span class="token operator">*</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>det_sigma<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            exponent <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>x_minus_mu<span class="token punctuation">.</span>T<span class="token punctuation">,</span> inv_sigma<span class="token punctuation">)</span><span class="token punctuation">,</span> x_minus_mu<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">0.5</span>            <span class="token comment"># 计算似然</span>            likelihood<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> base <span class="token operator">*</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>exponent<span class="token punctuation">)</span>            p_x <span class="token operator">+=</span> likelihood<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">*</span> Phi<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> likelihood<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">*</span> Phi<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">/</span> p_x    <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络4：两层神经网络</title>
      <link href="2021/05/10/coding4/"/>
      <url>2021/05/10/coding4/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络4：两层神经网络"><a href="#手写神经网络4：两层神经网络" class="headerlink" title="手写神经网络4：两层神经网络"></a>手写神经网络4：两层神经网络</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p></blockquote><h2 id="1-神经网络的初始化"><a href="#1-神经网络的初始化" class="headerlink" title="1.神经网络的初始化"></a>1.神经网络的初始化</h2><ul><li>两层的神经网络包含了输入层、隐层和输出层，其计算的过程包括<code>affine - relu - affine - softmax</code> 因此神经网络中的模型有四个参数W1，W2，b1，b2，因此神经网络的初始化中需要对这四个参数进行初始化，具体的实现代码如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TwoLayerNet</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>        self<span class="token punctuation">,</span>        input_dim<span class="token operator">=</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token number">32</span> <span class="token operator">*</span> <span class="token number">32</span><span class="token punctuation">,</span>        hidden_dim<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>        num_classes<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>        weight_scale<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span>        reg<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize a new network.        Inputs:        - input_dim: An integer giving the size of the input        - hidden_dim: An integer giving the size of the hidden layer        - num_classes: An integer giving the number of classes to classify        - weight_scale: Scalar giving the standard deviation for random          initialization of the weights.        - reg: Scalar giving L2 regularization strength.        """</span>        self<span class="token punctuation">.</span>params <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        self<span class="token punctuation">.</span>reg <span class="token operator">=</span> reg        self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">'b1'</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>hidden_dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">'b2'</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_classes<span class="token punctuation">)</span>        <span class="token comment"># 用正态分布对全连接层的权重矩阵W1与W2进行随机初始化，并且均值为0，方差为weight_scale</span>        self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">'W1'</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> scale<span class="token operator">=</span>weight_scale<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span>input_dim<span class="token punctuation">,</span> hidden_dim<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">'W2'</span><span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> scale<span class="token operator">=</span>weight_scale<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span>hidden_dim<span class="token punctuation">,</span> num_classes<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-损失函数与梯度的计算"><a href="#2-损失函数与梯度的计算" class="headerlink" title="2.损失函数与梯度的计算"></a>2.损失函数与梯度的计算</h2><ul><li>在二层神经网络初始化完成之后就可以进行计算，我们这里实现的类<code>TwoLayerNet</code> 并不进行梯度下降的优化，而是在另一个Solver类中完成。</li><li>这里的损失函数和梯度函数的计算有两种情况，一种是训练的时候参数中包含了标签，这时候就需要计算梯度和loss，而预测的时候则不需要计算梯度，直接求解预测结果就可以</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">loss</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        scores <span class="token operator">=</span> <span class="token boolean">None</span> <span class="token comment"># 先进行一个前向传播，下面三行代码分别对应了第一层全连接层，ReLU层和第二层连接层</span>        out0<span class="token punctuation">,</span> cache0 <span class="token operator">=</span> affine_forward<span class="token punctuation">(</span>X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">"W1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">"b1"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        out1<span class="token punctuation">,</span> cache1 <span class="token operator">=</span> relu_forward<span class="token punctuation">(</span>out0<span class="token punctuation">)</span>        scores<span class="token punctuation">,</span> cache2 <span class="token operator">=</span> affine_forward<span class="token punctuation">(</span>out1<span class="token punctuation">,</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">"W2"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">"b2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 在输入测试集的时候直接返回scores就可以</span>        <span class="token keyword">if</span> y <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> scores        loss<span class="token punctuation">,</span> grads <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment"># 计算loss函数并加上正则项</span>        loss<span class="token punctuation">,</span> dout <span class="token operator">=</span> softmax_loss<span class="token punctuation">(</span>out<span class="token punctuation">,</span> y<span class="token punctuation">)</span>        loss <span class="token operator">+=</span> <span class="token number">0.5</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>reg <span class="token operator">*</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">'W1'</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">'W2'</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 使用loss函数进行反向传播的梯度计算</span>        dout<span class="token punctuation">,</span> dw<span class="token punctuation">,</span> db <span class="token operator">=</span> affine_backward<span class="token punctuation">(</span>dout<span class="token punctuation">,</span> cache2<span class="token punctuation">)</span>        grads<span class="token punctuation">[</span><span class="token string">'W2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> grads<span class="token punctuation">[</span><span class="token string">'b2'</span><span class="token punctuation">]</span> <span class="token operator">=</span> dw <span class="token operator">+</span> self<span class="token punctuation">.</span>reg <span class="token operator">*</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">'W2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> db        dout<span class="token punctuation">,</span> dw<span class="token punctuation">,</span> db <span class="token operator">=</span> affine_relu_backward<span class="token punctuation">(</span>dout<span class="token punctuation">,</span> cache1<span class="token punctuation">)</span>        grads<span class="token punctuation">[</span><span class="token string">'W1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> grads<span class="token punctuation">[</span><span class="token string">'b1'</span><span class="token punctuation">]</span> <span class="token operator">=</span> dw <span class="token operator">+</span> self<span class="token punctuation">.</span>reg <span class="token operator">*</span> self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">'W1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> db        <span class="token keyword">return</span> loss<span class="token punctuation">,</span> grads<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-solver和优化器"><a href="#3-solver和优化器" class="headerlink" title="3.solver和优化器"></a>3.solver和优化器</h2><ul><li>solver类是CS231N的<strong>作业直接给出</strong>的，用于更新两层神经网络模型的参数，并使用随机梯度下降算法作为优化算法，其使用方式如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>      <span class="token string">'X_train'</span><span class="token punctuation">:</span> <span class="token comment"># training data</span>      <span class="token string">'y_train'</span><span class="token punctuation">:</span> <span class="token comment"># training labels</span>      <span class="token string">'X_val'</span><span class="token punctuation">:</span> <span class="token comment"># validation data</span>      <span class="token string">'y_val'</span><span class="token punctuation">:</span> <span class="token comment"># validation labels</span><span class="token punctuation">&#125;</span>model <span class="token operator">=</span> MyAwesomeModel<span class="token punctuation">(</span>hidden_size<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> reg<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>solver <span class="token operator">=</span> Solver<span class="token punctuation">(</span>model<span class="token punctuation">,</span> data<span class="token punctuation">,</span>                update_rule<span class="token operator">=</span><span class="token string">'sgd'</span><span class="token punctuation">,</span>                optim_config<span class="token operator">=</span><span class="token punctuation">&#123;</span>                  <span class="token string">'learning_rate'</span><span class="token punctuation">:</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                lr_decay<span class="token operator">=</span><span class="token number">0.95</span><span class="token punctuation">,</span>                num_epochs<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>                print_every<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>solver<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>train函数的具体代码实现我们就不去关注了，要读懂还是挺麻烦的，这里使用的优化器SGD其实就是随机梯度下降的一种实现，随机梯度下降是每次选择一个小batch size的数据对其求梯度并更新到参数矩阵中去，实现SGD的代码如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sgd</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> dw<span class="token punctuation">,</span> config<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Performs vanilla stochastic gradient descent.    config format:    - learning_rate: Scalar learning rate.    """</span>    <span class="token keyword">if</span> config <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        config <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    config<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">"learning_rate"</span><span class="token punctuation">,</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>    w <span class="token operator">=</span> w <span class="token operator">-</span> dw <span class="token operator">*</span> config<span class="token punctuation">[</span><span class="token string">"learning_rate"</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> w<span class="token punctuation">,</span> config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>后面我们还会实现<strong>动量法，Adam算法等优化算法</strong>，这里暂且不表，最后在测试中loss的变化趋势如下：</li></ul><p><img src="/2021/05/10/coding4/image-20210510203915450.png" alt="loss曲线"></p>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习代码实现1:线性回归与岭回归</title>
      <link href="2021/05/10/coding-ml1/"/>
      <url>2021/05/10/coding-ml1/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习代码实现1：线性回归和岭回归"><a href="#机器学习代码实现1：线性回归和岭回归" class="headerlink" title="机器学习代码实现1：线性回归和岭回归"></a>机器学习代码实现1：线性回归和岭回归</h1><blockquote><p>这一专题的内容主要是我在进行统计机器学习的算法的代码实践的过程中的一些记录，包括公式的推导，算法的实现与数据集的实验结果。</p><p>这部分工作我比较早之前就已经开始做了，现在刚好趁此机会整理一下之前写过的所有小demo，汇总成一个完成的库</p></blockquote><h2 id="1-线性回归模型"><a href="#1-线性回归模型" class="headerlink" title="1.线性回归模型"></a>1.线性回归模型</h2><ul><li>线性回归模型是最简单的一种线性模型，模型的形式就是：</li></ul><p>$$<br>y=W^Tx+b<br>$$</p><ul><li>我们可以通过对<strong>原本的输入向量x扩增一个为1的维度</strong>将参数$W$和$b$统一成一个参数$W$，即模型变成了</li></ul><p>$$<br>y=W^{T}x<br>$$</p><ul><li>这里的$W$是原本两个参数合并之后的而其损失函数的形式是残差平方损失RSS</li></ul><p>$$<br>L=\frac {1}{2m}\sum_{i=1}^m(W^Tx_i-y_i)^2=\frac {1}{2m}(W^TX-y)^T(W^TX-y)<br>$$</p><ul><li>我们很容易就可以通过求导得到线性回归模型的关于$W$的梯度</li></ul><p>$$<br>\nabla_{W}L=\frac{1}{m}\sum_{i=1}^m(W^Tx_i-y_i)x_i=\frac 1m X^T(W^TX-y)<br>$$</p><p>这样一来我们就可以通过梯度下降的方式来训练参数$W$，可以用下面的公式表示[大概是这样，我也没有]：<br>$$<br>W:= W-\alpha\frac 1m X^T(W^TX-y)<br>$$</p><ul><li>但实际上线性模型的参数$W$可以直接求解出，即：</li></ul><p>$$<br>W=(X^TX)^{-1}X^Ty<br>$$</p><h2 id="2-线性回归的编程实现"><a href="#2-线性回归的编程实现" class="headerlink" title="2.线性回归的编程实现"></a>2.线性回归的编程实现</h2><ul><li>具体代码中的参数的形式可能和上面的公式推导略有区别，我们实现了一个LinearRegression的类，包含fit，predict和loss三个主要的方法，fit方法就是求解线性模型的过程，这里我们直接使用了正规方程来解</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">LinearRegression</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">:</span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">,</span> y<span class="token punctuation">:</span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">float</span><span class="token punctuation">:</span>        N<span class="token punctuation">,</span> D <span class="token operator">=</span> X<span class="token punctuation">.</span>shape        <span class="token comment"># 将每个样本的特征增加一个维度，用1表示，使得bias和weight可以一起计算</span>        <span class="token comment"># 这里在输入的样本矩阵X末尾增加一列来给每个样本的特征向量增加一个维度</span>        <span class="token comment"># 现在X变成了N*(D+1)维的矩阵了</span>        expand_X <span class="token operator">=</span> np<span class="token punctuation">.</span>column_stack<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>w <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>inv<span class="token punctuation">(</span>np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>expand_X<span class="token punctuation">.</span>T<span class="token punctuation">,</span> expand_X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> expand_X<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>loss<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>predict实际上就是将输入的矩阵X放到模型中进行计算得到对应的结果，loss给出了损失函数的计算方式：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">loss</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">:</span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">,</span> y<span class="token punctuation">:</span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        线性回归模型使用的是RSS损失函数        :param X:需要预测的特征矩阵X，维度是N*D        :param y:标签label        :return:        """</span>        delta <span class="token operator">=</span> y <span class="token operator">-</span> self<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span>        total_loss <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>delta <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> total_loss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-岭回归Ridge-Regression与代码实现"><a href="#3-岭回归Ridge-Regression与代码实现" class="headerlink" title="3.岭回归Ridge Regression与代码实现"></a>3.岭回归Ridge Regression与代码实现</h2><ul><li>岭回归实际上就是一种使用了正则项的线性回归模型，也就是在损失函数上加上了正则项来控制参数的规模，即：</li></ul><p>$$<br>L=\frac {1}{2m}\sum_{i=1}^m(W^Tx_i-y_i)^2+\lambda ||W||_2=\frac {1}{2m}(W^TX-y)^T(W^TX-y)+\lambda W^TW<br>$$</p><ul><li>因此最终的模型的正规方程就变成了：</li></ul><p>$$<br>W=(X^TX+\lambda I)^{-1}X^Ty<br>$$</p><ul><li>这里的$\lambda$是待定的正则项参数，可以根据情况选定，岭回归模型训练的具体代码如下</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">RidgeRegression</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">:</span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">,</span> y<span class="token punctuation">:</span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">)</span><span class="token punctuation">:</span>        N<span class="token punctuation">,</span> D <span class="token operator">=</span> X<span class="token punctuation">.</span>shape        I <span class="token operator">=</span> np<span class="token punctuation">.</span>identity<span class="token punctuation">(</span>D <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        I<span class="token punctuation">[</span>D<span class="token punctuation">]</span><span class="token punctuation">[</span>D<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        expand_X <span class="token operator">=</span> np<span class="token punctuation">.</span>column_stack<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>W <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>inv<span class="token punctuation">(</span>np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>expand_X<span class="token punctuation">.</span>T<span class="token punctuation">,</span> expand_X<span class="token punctuation">)</span>                                                    <span class="token operator">+</span> self<span class="token punctuation">.</span>reg <span class="token operator">*</span> I<span class="token punctuation">)</span><span class="token punctuation">,</span> expand_X<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>loss<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-数据集实验"><a href="#4-数据集实验" class="headerlink" title="4.数据集实验"></a>4.数据集实验</h2><ul><li>这里使用了随机生成的二位数据点来对线性模型进行测试，测试结果如下：</li></ul><p><img src="/2021/05/10/coding-ml1/image-20210510101134809.png" alt="线性模型测试结果"></p><ul><li>岭回归也使用同样的代码进行测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络3：Softmax损失函数</title>
      <link href="2021/05/09/coding3/"/>
      <url>2021/05/09/coding3/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络3：Softmax损失函数"><a href="#手写神经网络3：Softmax损失函数" class="headerlink" title="手写神经网络3：Softmax损失函数"></a>手写神经网络3：Softmax损失函数</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p></blockquote><h2 id="1-softmax函数的定义"><a href="#1-softmax函数的定义" class="headerlink" title="1.softmax函数的定义"></a>1.softmax函数的定义</h2><ul><li><p>CNN卷积神经网络的输出层之前往往会有一个softmax层，我们假设CNN进行的分类问题有$M$个可能的类别，那么CNN的一系列计算得到的应该是一个$M$维的向量，每个维度$k$上的值对应着当前输入样本的是第$k$类的概率，而最后的预测结果就是这$M$个维度中的值最大的那个就是预测结果。</p></li><li><p>但我们很容易发现神经网络一层层算下来，你不能保证输出的$M$维向量的值处于0-1的范围内(因为要看成是概率)，这个时候就可以用softmax函数将其标准化成一个0-1的概率分布，softmax函数的形式如下：</p></li></ul><p>$$<br>f(s_k)=\frac{\exp(s_k)}{\sum_{i=1}^M \exp(s_i)}<br>$$</p><ul><li>softmax函数的运算就可以保证最后将M维的向量转化成概率分布$ y=[f(s_1),\dots,f(s_M)]$</li></ul><h2 id="2-softmax-loss的定义"><a href="#2-softmax-loss的定义" class="headerlink" title="2.softmax loss的定义"></a>2.softmax loss的定义</h2><ul><li>softmax loss是一种常见的CNN损失函数，实际上就是交叉熵的变体，其计算方式为：</li></ul><p>$$<br>L = -\frac 1 N\sum_{i=1}^N \log (y_i)=-\frac 1 N\sum_{i=1}^N \frac{\exp(s_i)}{\sum_{k=1}^M \exp(s_k)}<br>$$</p><p>这里的$y$表示的是softmax层的输出结果，N是样本的个数，对每个样本的softmax损失求平均值就是数据集的损失函数</p><h2 id="3-数值计算的稳定性"><a href="#3-数值计算的稳定性" class="headerlink" title="3.数值计算的稳定性"></a>3.数值计算的稳定性</h2><ul><li>为了保证数值计算的稳定性，可以对softmax函数进行如下trick</li></ul><p>$$<br>f(s_k)=\frac{\exp(s_k)}{\sum_{i=1}^M \exp(s_i)}=\frac{C\times \exp(s_k)}{C\times \sum_{i=1}^M \exp(s_i)}=\frac{\exp(s_k+\log C)}{\sum_{i=1}^M \exp(s_i+\log C)}<br>$$</p><p>这里加上一个常数$\log C$之后可以提高数值计算过程中softmax函数的稳定性，而这个数可以选为最大的那个$s_k$</p><h2 id="4-正则化"><a href="#4-正则化" class="headerlink" title="4.正则化"></a>4.正则化</h2><ul><li>为了防止过拟合，可以给softmax损失函数加上正则项，这里一般用L2正则项，而加上正则化项之后的损失函数就变成了：</li></ul><p>$$<br>L=-\frac 1 N\sum_{i=1}^N \log (y_i)+\lambda||W||<br>$$</p><ul><li>这里的$w$指的就是前一层全连接层的权重矩阵，因此CNN最靠近输出的几个层应该分别是全连接层–softmax层–输出层</li></ul><h2 id="5-反向传播求梯度"><a href="#5-反向传播求梯度" class="headerlink" title="5.反向传播求梯度"></a>5.反向传播求梯度</h2><ul><li>我们可以根据方向传播的算法求出最后一个全连接层的梯度更新公式，如下所示：</li></ul><p>$$<br>\frac{\partial L}{\partial W_{j}}=\sum_i\frac{\partial L}{\partial L_i}\times \frac{\partial L_i}{\partial s_j}\times \frac{\partial s_j}{\partial W_{j}}<br>$$</p><p>下面我们分别来计算每个部分的梯度，首先：<br>$$<br>\frac{\partial L}{\partial y_i}=-\frac 1N<br>$$<br>而softmax的求导需要分成两部分来讨论，当$i$和$j$不相等的时候：<br>$$<br>\frac{\partial y_i}{\partial s_j}=- y_i y_j<br>$$<br>而当$i=j$的时候梯度就变成了：<br>$$<br>\frac{\partial  y_i}{\partial s_i}=\hat y_i(1- y_i) = y_i- y_i^2<br>$$<br>实际上就是比两个下标不相等的时候多了一个$\hat y_i$，又因为$s=XW$(这里和代码保持一致)，所以<br>$$<br>\frac{\partial L}{\partial W_{j}}=-\frac 1N\sum_{i=1}^Nx_i^T(\hat y_i-y_i)+2\lambda W_j<br>$$</p><h2 id="6-代码编写"><a href="#6-代码编写" class="headerlink" title="6.代码编写"></a>6.代码编写</h2><ul><li>最后编写出的代码就变成了如下形式</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">softmax_loss_naive</span><span class="token punctuation">(</span>W<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> reg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Softmax loss function, naive implementation (with loops)    Inputs have dimension D, there are C classes, and we operate on minibatches    of N examples.    Inputs:    - W: A numpy array of shape (D, C) containing weights.    - X: A numpy array of shape (N, D) containing a minibatch of data.    - y: A numpy array of shape (N,) containing training labels; y[i] = c means      that X[i] has label c, where 0 &lt;= c &lt; C.    - reg: (float) regularization strength    Returns a tuple of:    - loss as single float    - gradient with respect to weights W; an array of same shape as W    """</span>    <span class="token comment"># Initialize the loss and gradient to zero.</span>    loss <span class="token operator">=</span> <span class="token number">0.0</span>    dW <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>W<span class="token punctuation">)</span> <span class="token comment">#dW的大小是D*C</span>    scores <span class="token operator">=</span> X<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>W<span class="token punctuation">)</span> <span class="token comment"># N * C</span>    num_train <span class="token operator">=</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    num_classes <span class="token operator">=</span> W<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment"># Softmax Loss</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_train<span class="token punctuation">)</span><span class="token punctuation">:</span>      f <span class="token operator">=</span> scores<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>scores<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 提高数值计算的稳定性，f的大小是C</span>      softmax <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token operator">/</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># softmax的大小是C</span>      loss <span class="token operator">+=</span> <span class="token operator">-</span>np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>softmax<span class="token punctuation">[</span>y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 对N个softmax求和</span>      <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_classes<span class="token punctuation">)</span><span class="token punctuation">:</span>        dW<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> X<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> softmax<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token comment"># D*1</span>      dW<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> X<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token comment"># 求一下均值，因为有N个样本</span>    loss <span class="token operator">/=</span> num_train    dW <span class="token operator">/=</span> num_train    <span class="token comment"># 加上正则项</span>    loss <span class="token operator">+=</span> reg <span class="token operator">*</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>W <span class="token operator">*</span> W<span class="token punctuation">)</span>    dW <span class="token operator">+=</span> reg <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> W     <span class="token keyword">return</span> loss<span class="token punctuation">,</span> dW<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>也可以用<strong>向量化的形式</strong>来编写softmax损失函数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">softmax_loss_vectorized</span><span class="token punctuation">(</span>W<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> reg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Softmax loss function, vectorized version.    Inputs and outputs are the same as softmax_loss_naive.    """</span>    <span class="token comment"># Initialize the loss and gradient to zero.</span>    loss <span class="token operator">=</span> <span class="token number">0.0</span>    dW <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>W<span class="token punctuation">)</span>    num_train <span class="token operator">=</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    scores <span class="token operator">=</span> X<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>W<span class="token punctuation">)</span>    scores <span class="token operator">=</span> scores <span class="token operator">-</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>scores<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> keepdims<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment"># Softmax Loss</span>    sum_exp_scores <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> keepdims<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    softmax_matrix <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>scores<span class="token punctuation">)</span> <span class="token operator">/</span> sum_exp_scores    loss <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token operator">-</span>np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>softmax_matrix<span class="token punctuation">[</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>num_train<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>    <span class="token comment"># Weight Gradient</span>    softmax_matrix<span class="token punctuation">[</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>num_train<span class="token punctuation">)</span><span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>    dW <span class="token operator">=</span> X<span class="token punctuation">.</span>T<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>softmax_matrix<span class="token punctuation">)</span>    <span class="token comment"># Average</span>    loss <span class="token operator">/=</span> num_train    dW <span class="token operator">/=</span> num_train    <span class="token comment"># Regularization</span>    loss <span class="token operator">+=</span> reg <span class="token operator">*</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>W <span class="token operator">*</span> W<span class="token punctuation">)</span>    dW <span class="token operator">+=</span> reg <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> W     <span class="token keyword">return</span> loss<span class="token punctuation">,</span> dW<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络2：ReLU层</title>
      <link href="2021/05/08/coding2/"/>
      <url>2021/05/08/coding2/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络2：ReLU层"><a href="#手写神经网络2：ReLU层" class="headerlink" title="手写神经网络2：ReLU层"></a>手写神经网络2：ReLU层</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程</p></blockquote><p>ReLU层是CNN中非常常用的激活层，ReLU函数的定义为：<br>$$<br>\mathrm{ReLU}(x)=\max (0, x)<br>$$<br>我们知道全连接层进行的运算都是线性的变化，激活层的目的是就<strong>赋予这些计算的结果非线性的特征</strong>，使得神经网络可以拟合某个特定的目标函数，有理论研究表明，只要神经网络中采用了具有“挤压”性质的激活函数，神经网络在层数足够的情况下可以拟合任何函数到任意精度。其他常见的激活函数还有Sigmoid函数和tanh函数</p><h2 id="1-1前向传播"><a href="#1-1前向传播" class="headerlink" title="1.1前向传播"></a>1.1前向传播</h2><p>ReLU层的前向传播比较简单，主要就是对上一层输入的x进行ReLU函数的运算，具体的代码可以用一个函数<code>relu_forward</code>来表示</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">relu_forward</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Computes the forward pass for a layer of rectified linear units (ReLUs).    Input:    - x: Inputs, of any shape    Returns a tuple of:    - out: Output, of the same shape as x    - cache: x    """</span>    out <span class="token operator">=</span> <span class="token boolean">None</span>        out <span class="token operator">=</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    cache <span class="token operator">=</span> x        <span class="token keyword">return</span> out<span class="token punctuation">,</span> cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2反向传播"><a href="#1-2反向传播" class="headerlink" title="1.2反向传播"></a>1.2反向传播</h2><p>反向传播的时候我们还是假设从最顶层流到当前ReLU层的关于ReLU函数的梯度是dout，我们只需要在这里层求出ReLU函数关于x的导数就可以，而ReLU函数是一个分段函数，一段是常数0因此梯度就为0，一段是线性的x因此梯度就是1，因此ReLU函数关于x的梯度就是大于0的时候为1，否则为0，因此反向传播的时候用<code>relu_backward</code>函数来计算dx：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">relu_backward</span><span class="token punctuation">(</span>dout<span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Computes the backward pass for a layer of rectified linear units (ReLUs).    Input:    - dout: Upstream derivatives, of any shape    - cache: Input x, of same shape as dout    Returns:    - dx: Gradient with respect to x    """</span>    dx<span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> cache    x<span class="token punctuation">[</span>x <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>    x<span class="token punctuation">[</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    dx <span class="token operator">=</span> x <span class="token operator">*</span> dout    <span class="token keyword">return</span> dx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写神经网络1：全连接层</title>
      <link href="2021/05/07/coding1/"/>
      <url>2021/05/07/coding1/</url>
      
        <content type="html"><![CDATA[<h1 id="手写神经网络1：全连接层"><a href="#手写神经网络1：全连接层" class="headerlink" title="手写神经网络1：全连接层"></a>手写神经网络1：全连接层</h1><blockquote><p>这个系列是我在完成斯坦福公开课CS231N的作业时候所做的一些记录，这门课程是公认的深度学习入门的神课，其作业也非常硬核，需要从底层实现各种神经网络模型，包括前馈神经网络、卷积神经网络和循环神经网络，LSTM等等。</p><p>作业不仅要求掌握numpy等python库的api用法，更要对神经网络的数学理论和公式推导有非常深的理解，实现起来难度比较大，因此我也将在这个系列的博客中记录自己推导和coding的过程。</p></blockquote><p>神经网络又输入层输出层和中间的若干个隐层组成，这些隐层就是构成神经网络的基本组件。全连接层Fully Connected Layer是最简单的一种神经网络组件，也叫做仿射层。</p><h2 id="1-1正向传播"><a href="#1-1正向传播" class="headerlink" title="1.1正向传播"></a>1.1正向传播</h2><p>全连接层也就是<strong>将所有的输入神经元和所有输出神经元进行连接</strong>，彼此之间有一个权重，我们假设输入神经元的是$d$维向量$x$，输出的是$n$维的向量，那么全连接层的权重矩阵$W$就是一个$n\times d$维的矩阵，而bias就是一个$n$维的向量$b$，因此全连接层的正向传播的过程可以表示为：<br>$$<br>f(x)=Wx+b<br>$$<br>这一过程时间上就是对输入的向量x进行了一个线性的变换。这一部分比较简单，也没什么好多说的。具体的代码实现如下，用一个函数<code>affine_forward</code>来表示一个全连接层前向传播时的操作：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">affine_forward</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Computes the forward pass for an affine (fully-connected) layer.    The input x has shape (N, d_1, ..., d_k) and contains a minibatch of N    examples, where each example x[i] has shape (d_1, ..., d_k). We will    reshape each input into a vector of dimension D = d_1 * ... * d_k, and    then transform it to an output vector of dimension M.    Inputs:    - x: A numpy array containing input data, of shape (N, d_1, ..., d_k)    - w: A numpy array of weights, of shape (D, M)    - b: A numpy array of biases, of shape (M,)    Returns a tuple of:    - out: output, of shape (N, M)    - cache: (x, w, b)    """</span>    out <span class="token operator">=</span> <span class="token boolean">None</span>    D <span class="token operator">=</span> np<span class="token punctuation">.</span>prod<span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>    new_x <span class="token operator">=</span> x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">)</span>    out <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>new_x<span class="token punctuation">,</span> w<span class="token punctuation">)</span> <span class="token operator">+</span> b    cache <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">)</span>    <span class="token keyword">return</span> out<span class="token punctuation">,</span> cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2反向传播"><a href="#1-2反向传播" class="headerlink" title="1.2反向传播"></a>1.2反向传播</h2><p>反向传播也就是根据损失函数来优化各个参数W，x和b，我们可以假设从输出层传递到当前全连接层的结果是dout，那么根据反向传播算法和梯度的链式法则，我们需要求出的就是函数f对于W，x和b三者的导数。<br>$$<br>\frac {\partial f}{\partial x}=W^T<br>$$</p><p>$$<br>\frac {\partial f}{\partial b}= 1^{d\times 1}<br>$$</p><p>$$<br>\frac {\partial f}{\partial W}=x^T<br>$$</p><p><strong>结合W，x，b各自的维度特征</strong>，反向传播的这个过程可以用下面的函数<code>affine_backward</code>来表示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">affine_backward</span><span class="token punctuation">(</span>dout<span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Computes the backward pass for an affine layer.    Inputs:    - dout: Upstream derivative, of shape (N, M)    - cache: Tuple of:      - x: Input data, of shape (N, d_1, ... d_k)      - w: Weights, of shape (D, M)      - b: Biases, of shape (M,)    Returns a tuple of:    - dx: Gradient with respect to x, of shape (N, d1, ..., d_k)    - dw: Gradient with respect to w, of shape (D, M)    - db: Gradient with respect to b, of shape (M,)    """</span>    x<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b <span class="token operator">=</span> cache    dx<span class="token punctuation">,</span> dw<span class="token punctuation">,</span> db <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span>    N<span class="token punctuation">,</span> D <span class="token operator">=</span> x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    dx <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>dout<span class="token punctuation">,</span> w<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    dw <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>N<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">.</span>T<span class="token punctuation">,</span> dout<span class="token punctuation">)</span>    db <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dout<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> dx<span class="token punctuation">,</span> dw<span class="token punctuation">,</span> db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上我也没搞懂为什么导数会是这样的形式，但是根据矩阵和向量的维度来看应该需要这么写。</p>]]></content>
      
      
      <categories>
          
          <category> 代码实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图机器学习1:导论&amp;传统的图学习方法</title>
      <link href="2021/05/05/gml1/"/>
      <url>2021/05/05/gml1/</url>
      
        <content type="html"><![CDATA[<p>这个系列的笔记是我在学习斯坦福大学公开课程CS224W：Machine Learning For Graph的过程中完成的笔记。<br><img src="/2021/05/05/gml1/0004.jpg"><br><img src="/2021/05/05/gml1/0005.jpg"><br><img src="/2021/05/05/gml1/0006.jpg"><br><img src="/2021/05/05/gml1/0007.jpg"><br><img src="/2021/05/05/gml1/0008.jpg"><br><img src="/2021/05/05/gml1/0009.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 图机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理5:LSTM</title>
      <link href="2021/05/05/nlp5/"/>
      <url>2021/05/05/nlp5/</url>
      
        <content type="html"><![CDATA[<p>这个专题的笔记是我在学习斯坦福大学的公开课程CS224N:Deep Learning For Nature Language Processing时所做的一些课程笔记。<br>这一节的主要内容是长短期记忆(LSTM)。<br><img src="/2021/05/05/nlp5/0026.jpg"><br><img src="/2021/05/05/nlp5/0027.jpg"><br><img src="/2021/05/05/nlp5/0028.jpg"><br><img src="/2021/05/05/nlp5/0029.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理4:RNN</title>
      <link href="2021/05/05/nlp4/"/>
      <url>2021/05/05/nlp4/</url>
      
        <content type="html"><![CDATA[<p>这个专题的笔记是我在学习斯坦福大学的公开课程CS224N:Deep Learning For Nature Language Processing时所做的一些课程笔记。<br>这一节的主要内容是循环神经网络(RNN)。<br><img src="/2021/05/05/nlp4/0019.jpg"><br><img src="/2021/05/05/nlp4/0020.jpg"><br><img src="/2021/05/05/nlp4/0021.jpg"><br><img src="/2021/05/05/nlp4/0022.jpg"><br><img src="/2021/05/05/nlp4/0023.jpg"><br><img src="/2021/05/05/nlp4/0024.jpg"><br><img src="/2021/05/05/nlp4/0025.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理3:依赖性解析</title>
      <link href="2021/05/05/nlp3/"/>
      <url>2021/05/05/nlp3/</url>
      
        <content type="html"><![CDATA[<p>这个专题的笔记是我在学习斯坦福大学的公开课程CS224N:Deep Learning For Nature Language Processing时所做的一些课程笔记。<br>这一节的主要内容是依赖性解析。<br><img src="/2021/05/05/nlp3/0017.jpg"><br><img src="/2021/05/05/nlp3/0018.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理2:词向量II-Word2Vec</title>
      <link href="2021/05/05/nlp2/"/>
      <url>2021/05/05/nlp2/</url>
      
        <content type="html"><![CDATA[<p>这个专题的笔记是我在学习斯坦福大学的公开课程CS224N:Deep Learning For Nature Language Processing时所做的一些课程笔记。<br>这是第二部分，主要内容是Word2Vec模型。<br><img src="/2021/05/05/nlp2/0009.jpg"><br><img src="/2021/05/05/nlp2/0010.jpg"><br><img src="/2021/05/05/nlp2/0011.jpg"><br><img src="/2021/05/05/nlp2/0012.jpg"><br><img src="/2021/05/05/nlp2/0013.jpg"><br><img src="/2021/05/05/nlp2/0014.jpg"><br><img src="/2021/05/05/nlp2/0015.jpg"><br><img src="/2021/05/05/nlp2/0016.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理1：导论+词向量I</title>
      <link href="2021/05/05/nlp1/"/>
      <url>2021/05/05/nlp1/</url>
      
        <content type="html"><![CDATA[<p>这个专题的笔记是我在学习斯坦福大学的公开课程CS224N:Deep Learning For Nature Language Processing时所做的一些课程笔记，同时我也完成了一些课程的assignments，在仔细整理之后也会写在博客上。<br><img src="/2021/05/05/nlp1/0006.jpg"><br><img src="/2021/05/05/nlp1/0007.jpg"><br><img src="/2021/05/05/nlp1/0008.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021春招暑期实习面经</title>
      <link href="2021/05/04/intern/"/>
      <url>2021/05/04/intern/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里云基础平台开发面经"><a href="#阿里云基础平台开发面经" class="headerlink" title="阿里云基础平台开发面经"></a>阿里云基础平台开发面经</h1><ul><li>之前在<a href="https://www.cc98.org/topic/5054107">这个帖子</a> 里发了凉经，后来被另一个部门捞了起来重新面，一共面了三轮面试，面到最后才了解到是阿里云的基础平台研发部门</li><li>以下内容仅供参考，请勿转发至外网</li></ul><h2 id="一面4-10-25min"><a href="#一面4-10-25min" class="headerlink" title="一面4.10 25min"></a>一面4.10 25min</h2><ul><li>自我介绍，然后让我简单介绍一下简历上的若干项目中自己做的工作<ul><li>你觉得自己做的项目可以有哪些地方能进一步改进<h4 id="八股文："><a href="#八股文：" class="headerlink" title="八股文："></a>八股文：</h4></li><li>进程和线程的区别</li><li>linux的进程分成几个段</li><li>TCP和UDP的区别</li><li>项目中哪些地方用到了并发编程和并行编程</li></ul></li><li>没有考代码题</li></ul><h2 id="二面4-12-45min"><a href="#二面4-12-45min" class="headerlink" title="二面4.12 45min"></a>二面4.12 45min</h2><ul><li>自我介绍</li><li>简述TCP的三次握手的过程</li><li>线程之间如何进行通信？信号量是什么，有什么作用？</li><li>解释一下线程池是什么东西，解释完之后又问了可不可以类比一下推测连接池是什么</li><li>自己印象最深的一个项目是什么，做完之后有什么样的收获</li><li>你如何看待软件工程中的各个环节？你认为最重要的环节是哪一个</li><li>项目过程中有没有性能调优的经历，详细讲讲</li><li>C++中的虚函数是怎么实现的，内存泄漏是指什么？</li><li>还问了个人未来发展规划，其他的一些问题有的忘记了，没有考代码题</li><li>反问环节：问了部门里在做哪些具体的业务</li></ul><h2 id="三面4-14-25min"><a href="#三面4-14-25min" class="headerlink" title="三面4.14 25min"></a>三面4.14 25min</h2><ul><li><p>进了线上会议室才知道是hr面</p></li><li><p>随便聊了聊，聊到未来发展规划，对着简历上的项目瞎吹了一通，反正hr大约不太懂</p></li><li><p>hr问到你认为项目能做哪些改进？答了可以把minisql做成一个分布式系统云云，然后被问你认为这样的一个分布式数据库有哪些应用场景</p></li><li><p>你对整个面试环节有什么评价？</p></li><li><p>参加过阿里的笔试之后，面试过程(五轮)中再也没手撕过代码，我觉得也挺离奇的</p></li></ul><p>面试完之后第二天晚上收到了意向书，才知道捞我的具体部门是哪个，<del>比较惊喜的同时次日的字节三面就挂了。</del></p><h1 id="字节教育业务服务端开发凉经"><a href="#字节教育业务服务端开发凉经" class="headerlink" title="字节教育业务服务端开发凉经"></a>字节教育业务服务端开发凉经</h1><ul><li>有的题目可能已经忘记了，这里只是部分内容</li></ul><h2 id="一面4-9-50min"><a href="#一面4-9-50min" class="headerlink" title="一面4.9    50min"></a>一面4.9    50min</h2><ul><li>自我介绍</li><li>问项目，minisql相关，介绍一下有哪些模块，自己负责了哪一部分<h4 id="数据库-项目："><a href="#数据库-项目：" class="headerlink" title="数据库+项目："></a>数据库+项目：</h4><ul><li>B+树索引：怎么实现的，插入删除怎么操作，为什么用B+树</li><li>聚集索引和非聚集索引<h4 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h4></li><li>进程和线程的区别，Linux中进程用什么数据结构表示<h4 id="计网："><a href="#计网：" class="headerlink" title="计网："></a>计网：</h4></li><li>TCP和UDP的区别</li><li>TCP怎么保证传输的安全可靠？</li><li>浏览器输入一个网址发生了什么？<h4 id="代码题："><a href="#代码题：" class="headerlink" title="代码题："></a>代码题：</h4></li><li>二叉树的最大宽度，写了个用层序遍历的解法</li></ul></li></ul><h2 id="二面4-13-50min"><a href="#二面4-13-50min" class="headerlink" title="二面4.13 50min"></a>二面4.13 50min</h2><ul><li>自我介绍<h4 id="问项目"><a href="#问项目" class="headerlink" title="问项目"></a>问项目</h4><ul><li>minisql的总体架构和自己完成的工作</li><li>你们的minisql怎么发现SQL语句中的错误</li></ul></li><li>问了个git指令，怎么回退到上一次commit<h4 id="操作系统：-1"><a href="#操作系统：-1" class="headerlink" title="操作系统："></a>操作系统：</h4><ul><li>平时用的比较多的操作系统是什么，用过Linux操作系统吗？</li><li>进程和线程的区别，并行和并发要注意什么</li><li>进程间通信方式，线程之间的通信方式</li><li>场景题：开10个线程读取一个大文件，每个线程读特定的一段，怎么保证线程互相之间不会读到别的线程需要读的内容——这个我真没搞懂是什么意思<h4 id="设计题-代码题：两个栈实现一个队列"><a href="#设计题-代码题：两个栈实现一个队列" class="headerlink" title="设计题/代码题：两个栈实现一个队列"></a>设计题/代码题：两个栈实现一个队列</h4><h4 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h4></li><li>解释一下ACID分别代表什么</li><li>mysql有哪几个隔离级别，默认的隔离级别是什么<h4 id="计网：-1"><a href="#计网：-1" class="headerlink" title="计网："></a>计网：</h4></li><li>TCP三次握手的过程，和UDP的区别</li><li>HTTP状态码有哪几种，分别代表了什么，401代表什么意思——401代表什么忘了<h4 id="代码题：-1"><a href="#代码题：-1" class="headerlink" title="代码题："></a>代码题：</h4></li><li>反转链表的后K个元素<h4 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h4></li><li>问了字节为什么会选择go</li></ul></li></ul><h2 id="三面4-16-50min"><a href="#三面4-16-50min" class="headerlink" title="三面4.16 50min"></a>三面4.16 50min</h2><ul><li>自我介绍</li><li>介绍项目，还是minisql(感觉他们对我写的其他项目都没什么感兴趣的)<h4 id="数据库-项目"><a href="#数据库-项目" class="headerlink" title="数据库+项目"></a>数据库+项目</h4><ul><li>有没有参考mysql的架构设计，有没有读过mysql的源代码</li><li>你认为数据库要解决的最主要问题是什么</li><li>你认为数据库的设计最重要的是什么<h4 id="操作系统：-2"><a href="#操作系统：-2" class="headerlink" title="操作系统："></a>操作系统：</h4></li><li>介绍一下常见的进程调度算法</li><li>你认为评估进程调度算法的指标可以是什么<h4 id="计网：-2"><a href="#计网：-2" class="headerlink" title="计网："></a>计网：</h4></li><li>场景题：现在视频面试的过程中如何建立连接，视频和音频怎么样在网络中传输</li><li>HTTP和HTTPs的区别<h4 id="脑筋急转弯：概率题"><a href="#脑筋急转弯：概率题" class="headerlink" title="脑筋急转弯：概率题"></a>脑筋急转弯：概率题</h4></li><li>A和B轮流抛硬币，出现正反面的概率相等，谁先抛出正面谁就赢，求A先抛硬币的时候A赢的概率</li><li>你认为这个游戏公平吗？如何设计一个公平的游戏规则<h4 id="代码题：-2"><a href="#代码题：-2" class="headerlink" title="代码题："></a>代码题：</h4></li><li>给定一个整数，求出“下一个排列”</li><li>只有十分钟时间，来不及写了，思路也不太清晰</li></ul></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​字节三面发挥比较糟糕，最后挂了，lz春招一共投了字节阿里两个地方的暑期实习，最后拿到了阿里的意向书，看起来似乎没得选择了，最近几周隔天一场面试有点累了，就先这样吧。面试后的感想。面试之后意识到刷题确实很重要，字节那边挂了大约还是因为最后一道代码题没写出来。感觉大部分面试官都比较关注大二数据库系统课上写的minisql项目，对于其他的基本不太会问到，建议多准备该项目的相关内容<br>此外字节的八股文并没有想象中那么套路化，还是有很多比较细节和需要理解的点的</p>]]></content>
      
      
      <categories>
          
          <category> 实习/工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 实习 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习12:线性判别分析</title>
      <link href="2021/05/04/ml12/"/>
      <url>2021/05/04/ml12/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml12/0053.jpg"><br><img src="/2021/05/04/ml12/0054.jpg"><br><img src="/2021/05/04/ml12/0055.jpg"><br><img src="/2021/05/04/ml12/0056.jpg"><br><img src="/2021/05/04/ml12/0057.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习11:主成分分析</title>
      <link href="2021/05/04/ml11/"/>
      <url>2021/05/04/ml11/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml11/0050.jpg"><br><img src="/2021/05/04/ml11/0051.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习10:EM算法与GMM</title>
      <link href="2021/05/04/ml10/"/>
      <url>2021/05/04/ml10/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml10/0047.jpg"><br><img src="/2021/05/04/ml10/0048.jpg"><br><img src="/2021/05/04/ml10/0049.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习9:Boosting与Ensemble方法</title>
      <link href="2021/05/04/ml9/"/>
      <url>2021/05/04/ml9/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml9/0043.jpg"><br><img src="/2021/05/04/ml9/0044.jpg"><br><img src="/2021/05/04/ml9/0045.jpg"><br><img src="/2021/05/04/ml9/0046.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习8:聚类</title>
      <link href="2021/05/04/ml8/"/>
      <url>2021/05/04/ml8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml8/0037.jpg"><br><img src="/2021/05/04/ml8/0038.jpg"><br><img src="/2021/05/04/ml8/0039.jpg"><br><img src="/2021/05/04/ml8/0040.jpg"><br><img src="/2021/05/04/ml8/0041.jpg"><br><img src="/2021/05/04/ml8/0042.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习7:决策树</title>
      <link href="2021/05/04/ml7/"/>
      <url>2021/05/04/ml7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml7/0031.jpg"><br><img src="/2021/05/04/ml7/0032.jpg"><br><img src="/2021/05/04/ml7/0033.jpg"><br><img src="/2021/05/04/ml7/0034.jpg"><br><img src="/2021/05/04/ml7/0035.jpg"><br><img src="/2021/05/04/ml7/0036.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习6:kNN算法</title>
      <link href="2021/05/04/ml6/"/>
      <url>2021/05/04/ml6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml6/0029.jpg"><br><img src="/2021/05/04/ml6/0030.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习5:支持向量机SVM</title>
      <link href="2021/05/04/ml5/"/>
      <url>2021/05/04/ml5/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml5/0025.jpg"><br><img src="/2021/05/04/ml5/0026.jpg"><br><img src="/2021/05/04/ml5/0027.jpg"><br><img src="/2021/05/04/ml5/0028.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习4:感知机</title>
      <link href="2021/05/04/ml4/"/>
      <url>2021/05/04/ml4/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml4/0023.jpg"><br><img src="/2021/05/04/ml4/0024.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习3:线性模型</title>
      <link href="2021/05/04/ml3/"/>
      <url>2021/05/04/ml3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml3/0018.jpg"><br><img src="/2021/05/04/ml3/0019.jpg"><br><img src="/2021/05/04/ml3/0020.jpg"><br><img src="/2021/05/04/ml3/0021.jpg"><br><img src="/2021/05/04/ml3/0022.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习2:贝叶斯定理</title>
      <link href="2021/05/04/ml2/"/>
      <url>2021/05/04/ml2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml2/0011.jpg"><br><img src="/2021/05/04/ml2/0012.jpg"><br><img src="/2021/05/04/ml2/0013.jpg"><br><img src="/2021/05/04/ml2/0014.jpg"><br><img src="/2021/05/04/ml2/0015.jpg"><br><img src="/2021/05/04/ml2/0016.jpg"><br><img src="/2021/05/04/ml2/0017.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计机器学习1:机器学习中的基本概念</title>
      <link href="2021/05/04/ml1/"/>
      <url>2021/05/04/ml1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/04/ml1/0006.jpg"><br><img src="/2021/05/04/ml1/0007.jpg"><br><img src="/2021/05/04/ml1/0008.jpg"><br><img src="/2021/05/04/ml1/0009.jpg"><br><img src="/2021/05/04/ml1/0010.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 统计机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java应用技术3:高级语法</title>
      <link href="2021/05/04/java3/"/>
      <url>2021/05/04/java3/</url>
      
        <content type="html"><![CDATA[<h1 id="Java应用技术3：高级语法特性"><a href="#Java应用技术3：高级语法特性" class="headerlink" title="Java应用技术3：高级语法特性"></a>Java应用技术3：高级语法特性</h1><h2 id="4-Java高级语法特性"><a href="#4-Java高级语法特性" class="headerlink" title="4. Java高级语法特性"></a>4. Java高级语法特性</h2><h3 id="4-1-异常处理"><a href="#4-1-异常处理" class="headerlink" title="4.1 异常处理"></a>4.1 异常处理</h3><ul><li><p>Java中的异常类型</p><ul><li>注意异常和错误的区别，系统错误是JVM抛出的，异常是由程序引起的，可以被检测出来</li></ul><img src="image-20201109161600386.png" alt="image-20201109161600386" style="zoom:50%;" /></li><li><p>异常类型</p><ul><li>Unchecked Exceptions 不可恢复的逻辑错误，包括RuntimeException和Error<ul><li>比如NullPointerException和IndexOutOfBoundsException</li><li>Java不需要对unchecked exceptions进行检查</li></ul></li><li>checked exceptions 需要进行catch</li></ul></li><li><p>Declaring Exceptions 方法需要声明检查的异常的种类，关键字为throws</p></li><li><p>Throwing Exceptions </p><ul><li>当发现了错误类型的时候可以创建一个合适的错误类型将其抛出</li><li>语法是<code>throw new TheException()</code> </li><li>try-catch语句</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">try&#123;statements;&#x2F;&#x2F;Statementsthatmaythrowexceptions&#125;catch(Exception1 exVar1)&#123;handler for exception1;&#125;catch(Exception2 exVar2)&#123;handler for exception2;&#125;catch(ExceptionN exVar3)&#123;handler for exceptionN;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>tyr-catch语句块中可以加入finally子句，<strong>不管有没有找到错误都会被执行</strong> <ul><li>抛出异常之后如果没有finally就不会再往下执行，有finally的时候抛出异常之后还会执行finally中的语句</li></ul></li></ul></li><li><p>Java的异常检查使用规范</p><ul><li>不要忽略check exception：捕获就必须要处理</li><li>不要捕获unchecked exception</li><li>不要一次捕获所有的异常</li><li>使用finally语句块释放资源，但是final块不能抛出异常</li><li>抛出自定义异常异常时带上原始异常信息</li><li>打印异常的时候带上异常堆栈</li><li>不要同时使用异常机制和返回值</li><li>try不要太庞大，不然代码的可读性会降低</li><li>守护线程中需要catch runtime exception</li></ul></li></ul><h3 id="4-2-Assertion-断言"><a href="#4-2-Assertion-断言" class="headerlink" title="4.2 Assertion 断言"></a>4.2 Assertion 断言</h3><ul><li><p>包含一个在程序运行过程中一定是真的布尔表达式，用<code>assert assertion</code>进行定义</p><ul><li>当断言被创建的时候，Java会计算这个表达式，如果结果是false就会抛出AssertionsError这个异常</li><li>AssertionError有多种构造函数，用于匹配message的data type</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class AssertionDemo &#123;public static void main(String[] args) &#123;int i; int sum &#x3D; 0;for (i &#x3D; 0; i &lt; 10; i++) &#123;sum +&#x3D; i;&#125;assert i &#x3D;&#x3D; 10;assert sum &gt; 10 &amp;&amp; sum &lt; 5 * 10 : &quot;sum is &quot; + sum;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>不要在public的方法中使用assertion而应该使用exception handling</p></li></ul><h3 id="4-3-文本读写"><a href="#4-3-文本读写" class="headerlink" title="4.3 文本读写"></a>4.3 文本读写</h3><ul><li><p>File 类：一个由文件名和路径组成的包装类，提供了一系列文件信息和修改操作</p><ul><li>不包含读写文件内容的方法</li><li>文件读写需要Scanner和PrintWriter</li></ul></li><li><p>PrintWriter 用于写入文件</p><ul><li>提供了一系列重载的print和println方法</li><li>构造函数需要文件名作为变量，可以指定编码方式，比如UTF-8</li></ul></li><li><p>Scanner 用于读文件</p><ul><li>初始化之后和标准输入一样使用nextXXX来读写</li><li>Scanner的构造方式<ul><li>错误方式 <code>Scanner in = new Scanner(&quot;file.txt&quot;);</code> 构造了一个带字符串参数的Scanner</li><li>正确方式<code>Scanner in = new Scanner(new File(&quot;file.txt&quot;), &quot;UTF-8&quot;);</code> <ul><li>需要用File对象进行构造</li></ul></li></ul></li></ul></li><li><p>URL类：从web中读取信息</p><ul><li>构造方式<code>URL url = new URL(&quot;www.xxxxxxx&quot;);</code></li><li>完成构造之后可以用openStream打开一个输入流，用Scanner进行读取<ul><li><code>Scanner input = new Scanner(url.openStream);</code> </li></ul></li></ul></li></ul><h3 id="4-4-二进制读写"><a href="#4-4-二进制读写" class="headerlink" title="4.4 二进制读写"></a>4.4 二进制读写</h3><ul><li><p>文本读写是人能看懂的，二进制读写是机器可以看懂的，文本读写事实上是需要编码和解码的，但是二进制读写不需要编解码二可以直接被机器识别</p></li><li><p>Java通过输入输出流的形式来进行二进制文件的读写，二进制读写的一系列类的关系如下：</p><img src="image-20201202110558016.png" alt="image-20201202110558016" style="zoom: 33%;" /><ul><li>其中File的输入输出流需要一个文件作为读写的对象</li><li>Filter的输入输出流不仅可以读写二进制字符，也可以将int，double等类型的转化成二进制字符进行读写</li><li>对于string类型，Java使用的是2个字节的Unicode编码，ASCII编码是Unicode的子集，String中存储的实际上是文字的Unicode序列<ul><li>读写的流水线：外部文件–文件输入流–数据输入流–数据读入进行操作，要写的数据–数据输出流–文件输出流–外部文件</li></ul></li><li>对象读写流：直接读入一个对象</li></ul></li><li><p>序列化和反序列化：可以被写入输入输出流的对象被称为是可序列化的。</p><ul><li>实现Serializable的接口，可以进行对象的序列化和反序列化</li><li>序列化后的对象不需要再次调用 构造器重新生成，但是在实际中，我们会希望对象的某一部分不需要被 序列化，或者说一个对象被还原之后，其内部的某些子对象需要重新创 建，从而不必将该子对象序列化</li><li>反序列化之后得到的对象和原来的不是同一个，因此是深拷贝</li></ul></li><li><p>高级的文本I/O</p><img src="image-20201202115828956.png" alt="image-20201202115828956" style="zoom: 33%;" /></li></ul><h3 id="4-5-Generics-泛型"><a href="#4-5-Generics-泛型" class="headerlink" title="4.5 Generics 泛型"></a>4.5 Generics 泛型</h3><ul><li>是一种<strong>对变量类型进行参数化的</strong>功能，类似于C++中的模板<ul><li>优点是能在编译期就发现一些错误而不是运行时</li><li>一个泛型类或者方法可以声明类名和函数名作为变量</li></ul></li></ul><h4 id="4-5-1-泛型方法"><a href="#4-5-1-泛型方法" class="headerlink" title="4.5.1 泛型方法"></a>4.5.1 泛型方法</h4><ul><li><p>泛型方法的类型参数声明要卸载返回值类型前面，用尖括号括起来，比如</p><ul><li><code>public static &lt;E&gt; void printArray(E[] input);</code></li><li>类型参数可以有多个参数，有逗号隔开，类型参数可以被用来声明返回值类型</li><li><strong>有界限的</strong>类型参数：可以让类型参数有一定的范围<ul><li>用extends关键字+类型的上界来控制类型的范围</li><li>比如<code>&lt;T extends Comparable&lt;T&gt;&gt;</code> 表示T必须是可以比较大小的类型</li></ul></li><li>JDK7之后后面一个类型可以省略，由Java编译器自己推断</li></ul></li><li><p>判断函数中的范型参数能否被接受：画范型的继承关系，比如下面这样：</p><ul><li>这张图中，上层的可以容纳下层的对象</li></ul><img src="image-20201230102245681.png" alt="image-20201230102245681" style="zoom:33%;" /></li></ul><h4 id="4-5-2-泛型类"><a href="#4-5-2-泛型类" class="headerlink" title="4.5.2 泛型类"></a>4.5.2 泛型类</h4><ul><li><p>类型参数的声明添加在<strong>类名的后面</strong></p></li><li><p>参数化类型<strong>没有实际类型参数的继承关系</strong></p><ul><li>比如<code>List&lt;Integer&gt; list = new List&lt;Object&gt;</code>会编译错误，把两个参数类型反过来也是编译错误</li><li>泛型的继承关系需要通过通配符<ul><li>使用？代替具体类型参数，比如List&lt;?&gt;可以代表所有具体类型List的父类</li><li>比如<code>List&lt;? extends Number&gt;</code>表示参数的泛型上限为Number类型</li><li><code>List&lt;? super Number&gt;</code>表示参数的泛型下限为Number类型</li></ul></li></ul></li><li><p>不允许用泛型类型来创建泛型数组</p></li><li><p>范型的实现方式：</p><ul><li>范型使用一种叫做类型擦除的方法来实现，编译器编译的时候使用范型类型来编译代码，随后将其删除，因此范型信息在运行时是不可知的，这个方法使得范型可以向后兼容旧代码。</li></ul><p><img src="/2021/05/04/java3/image-20201230103159673.png" alt="image-20201230103159673"></p><ul><li>泛型类的所有实例都有相同的运行时类，所以泛型类的静态变量和方法是被它的所有实例共享的。所以在静态方法、数据域或初始化语句中，为了类而引用泛型参数是非法的</li></ul></li></ul><h3 id="4-6-Collection-框架"><a href="#4-6-Collection-框架" class="headerlink" title="4.6 Collection 框架"></a>4.6 Collection 框架</h3><ul><li><p>Java的一系列范型容器，主要支持的类型是集合、列表和映射</p><ul><li><p>其中Set和List是Collection接口的子接口，set是内容无序的，而list是有序的</p><img src="image-20201230105441871.png" alt="image-20201230105441871" style="zoom:33%;" /></li><li><p>而Map是一种key-value的映射</p><img src="image-20201230105539284.png" alt="image-20201230105539284" style="zoom: 33%;" /></li><li><p>hashcode的使用方式：在接口中定义的hashcode是里面所有元素的映射，可以通过维护hashcode来方便对象之间进行的比较，比如equals等方法，只需要比较hashcode就可以</p></li></ul></li><li><p>LinkedHashSet相比普通的HashSet，也使用hashcode来决定元素的存储位置，并用链表维护元素的顺序，所以性能比HashSet要差</p><img src="image-20201230111417175.png" alt="image-20201230111417175" style="zoom:33%;" /><img src="image-20201230111620049.png" alt="image-20201230111620049" style="zoom: 33%;" /><img src="image-20201230112153297.png" alt="image-20201230112153297" style="zoom:33%;" /></li><li><p>迭代器陷阱：迭代过程中不能发生结构上的变化，比如插入删除，否则会出问题</p><ul><li>因为迭代器是根据位置来进行的，会维护索引相关的数据，这一部分数据不能发生变化，否则会出问题</li></ul></li><li><p>Collection还有Vector、Stack、Queue、PriorityQueue等list结构，map可以</p></li><li><p>枚举集合和枚举map</p><ul><li>EnumSet提供了非常方便的方法来创建枚举集合，枚举集合中的所有元素必须都来自于单个枚举类型</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java应用技术2:类和对象</title>
      <link href="2021/05/04/java2/"/>
      <url>2021/05/04/java2/</url>
      
        <content type="html"><![CDATA[<h1 id="Java应用技术2：类和对象"><a href="#Java应用技术2：类和对象" class="headerlink" title="Java应用技术2：类和对象"></a>Java应用技术2：类和对象</h1><h4 id="RandomStar"><a href="#RandomStar" class="headerlink" title="RandomStar"></a>RandomStar</h4><h2 id="Chapter-3-Java-OOP"><a href="#Chapter-3-Java-OOP" class="headerlink" title="Chapter 3. Java OOP"></a>Chapter 3. Java OOP</h2><h3 id="3-1-类和对象"><a href="#3-1-类和对象" class="headerlink" title="3.1 类和对象"></a>3.1 类和对象</h3><h4 id="3-1-1-类的定义和初始化"><a href="#3-1-1-类的定义和初始化" class="headerlink" title="3.1.1 类的定义和初始化"></a>3.1.1 类的定义和初始化</h4><ul><li><p>一个对象拥有状态(state)和行为(behavior)两个属性，状态定义了对象的内容，表现定义了对象可以进行哪些操作，类就是用于定义同一类对象的</p><ul><li>Java中用变量定义状态，用方法定义行为</li><li>Java中的类也有<strong>构造函数</strong>，在对象构造的时候调用，但是对象的定义也可以不需要构造函数，当类定义里<strong>没有显式声明的构造函数</strong>时Java编译器会自动调用一个default constructor</li></ul></li><li><p>Java中方法和成员变量的引用方式：<code>objectRefVar.methodName(arguments)</code> </p><ul><li><p>Reference Data Fields有<strong>默认值</strong> </p><ul><li>String类型是null，数值类型是0，布尔类型是false，char类型是<code>\u0000</code> ，但是Java对于<strong>方法中的局部变量</strong>不会赋予默认值</li><li>比如<code>int x</code> 后直接对其进行print会发生编译错误，因为变量没有初始化</li></ul></li><li><p>和C++的区别</p><ul><li>Java编译器会为这些数据成员进行默认初始化，实际上是把刚分配的对象内存都置0</li><li>在对象里定义一个引用，并且没有初始化的时候，默认为null</li><li>Java中<strong>在默认的初始化动作之后才进行指定初始化</strong>，比如下面这段代码中，创建一个对象的时候变量i先变成0在被赋值为999<ul><li>也就是说一定会有用默认值去初始化类成员变量的这个过程</li><li>并且C++不支持直接在类定义里给成员变量赋值，但是Java可以</li></ul></li></ul></li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Value &#123;    int i &#x3D; 999;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>Java中数据成员的初始化过程是</p><ul><li>先进行<strong>默认的初始化</strong></li><li>在进行<strong>类定义里的初始化</strong></li><li>构造函数初始化</li></ul></li><li><p>对象和基本变量类型的区别</p><ul><li>基本变量类型在拷贝的时候只是拷贝一个值</li><li>对象在拷贝中改变的是变量对于对象的<strong>引用</strong> <ul><li>比如c1=c2的赋值导致c1也指向了c2指向的对象，而c1指向的对象不再被引用，会触发JVM的<strong>垃圾回收</strong>机制 </li></ul></li><li>对于不需要使用的对象可以给它赋值为null，这样就会触发JVM的垃圾回收机制释放内存空间</li></ul></li></ul><h4 id="⭐3-1-2-JVM–垃圾回收机制"><a href="#⭐3-1-2-JVM–垃圾回收机制" class="headerlink" title="⭐3.1.2 JVM–垃圾回收机制"></a>⭐3.1.2 JVM–垃圾回收机制</h4><ul><li><p><strong>Java的垃圾回收机制</strong> </p><ul><li><p>对于不再被引用的对象和被赋值为null的对象就会触发Java的垃圾回收机制</p></li><li><p>一般而言如果类自己管理内存，程序员就应该警惕<strong>内存泄漏</strong>的问题</p><ul><li><p>内存泄漏是指没有指针/引用指向一段存内存，导致这部分内存无法被调用和修改</p></li><li><p>内存泄漏的另一个常见的来源是缓存，把对象引用到了缓存中就容易内存泄漏</p></li><li><p>缓存可以用<strong>软引用</strong>来实现</p><ul><li><p>Java提供了强引用，软引用，弱引用和虚引用4种引用方式</p></li><li><p>平时我们用的是<strong>强引用</strong>，强引用<strong>只要存在就不会被当作垃圾回收</strong>，真不行了就抛出OOM异常</p><ul><li><code>object = null;</code> 就会导致原本是强引用被垃圾回收</li></ul></li><li><p>用软引用关联的对象在即将发生内存异常之前会被列入垃圾回收的范围而被回收，如果内存还是不够才会抛出内存异常(OOM, out of memory)的问题</p></li><li><p>软引用主要应用于内存敏感的高速缓存，在安卓系统中经常用到</p></li></ul></li></ul></li></ul></li></ul><h4 id="3-1-3-其他特性"><a href="#3-1-3-其他特性" class="headerlink" title="3.1.3 其他特性"></a>3.1.3 其他特性</h4><ul><li><p>instance 和 staic——和C++相同</p><ul><li>instance是变量的实例，instance variable属于特定的实例，instance method由类的一个实例调用</li><li>static类型的变量和方法被一个类的所有成员<strong>共享</strong> </li></ul></li><li><p>值传递和引用传递</p><ul><li>Java本质上是一种值传递</li><li>对象中的一个数组实际上是一个reference variable的数组</li></ul></li><li><p>不可变类 Immutable class</p><ul><li><p>Java自带了很多不可变的类，比如String和一些基本的<strong>包装类</strong> </p><ul><li>不可变类的优点：更加容易设计，实现和使用，更加安全</li></ul></li><li><p>编写不可变类的原则</p><ul><li>不提供可以修改对象状态的方法(mutator)</li><li>保证类不会被扩展，具体的做法是声明为<code>final</code> 类型<ul><li>不可变类使所有的state都是final和private的</li></ul></li><li>确保对于任何可变组件的互斥访问</li><li>必要时可以进行拷贝保护</li></ul></li><li><p>不可变对象，只有一种状态，也就是在创建的时候的状态</p><ul><li>本质上是<strong>线程安全</strong>的</li><li>可以提供<strong>静态工厂</strong>，把频繁被请求的实例缓存起来</li><li><strong>缺点</strong>是对于每一个不同的值都需要一个单独的对象</li></ul></li><li><p>为了确保不可变性，类不允许自己被子类化，除了使类成为final之外，还可以让类的所有构造函数都变为私有的或者**包级私有的(protected)**，并添加公共的静态工厂来代替公有的constructor </p><ul><li>用到了<strong>常量池技术</strong> </li></ul></li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Complex &#123;    private final double re;    private final double im;    private Complex(double re, double im) &#123;        this.re &#x3D; re;        this.im &#x3D; im;    &#125;    public static Complex valueOf(double re, double im) &#123;        return new Complex(re, im);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>this关键字：和C++相同</p><ul><li>是<strong>对象本身的引用</strong>的名字，用于访问hidden data fields</li><li>一个常见的用法是在类的constructor中去调用其他的constructor</li></ul></li><li><p>对象构建的TIPS</p><ul><li>基于Builder构造<ul><li>遇到多个constructor参数时可以考虑用Builder，可以解决类定义中的参数过多导致需要重载很多次的问题(导致代码的可读性变差，代码质量也下降)<ul><li>另一种方案是设置无参数的构造方法，通过setter方法来设置参数，但是这样不能保证对象的一致性</li><li>这种方法也使得类不能设置为不可变类</li></ul></li></ul></li><li>静态工厂方法代替构造器：代码的可读性更高，不必再每次调用的时候创建一个新的对象，可以返回原类型的任何子类型对象</li><li>单例对象构建：通常用于那些本质上唯一的对象，如文件系统、窗口管理器等<ul><li>有特权的客户端可以通过反射机制调用私有构造器，要抵御这种攻击可以修改构造器，要求创建第二个实例的时候抛出异常</li><li>枚举类方法：编写包含单个元素的枚举</li></ul></li></ul></li></ul><h4 id="⭐3-1-4-包-Package-和包管理"><a href="#⭐3-1-4-包-Package-和包管理" class="headerlink" title="⭐3.1.4 包(Package)和包管理"></a>⭐3.1.4 包(Package)和包管理</h4><ul><li><p>package可以方便管理和组织java文件的目录结构，防止不同文件之间的命名冲突</p><ul><li>作为Java代码源文件的第一条语句，如果缺省则指定为无名包</li><li>编译器在编译源文件阶段不检查目录结构</li></ul></li><li><p>类的导入</p><ul><li>可以在每个类前面添加完整的包名</li><li>也可以使用import语句导入整个包，比如<code>import java.time.*</code> </li><li>也可以只导入包中的特定类</li></ul></li><li><p>package静态导入</p><ul><li>不仅可以导入类，也可以导入静态的方法和静态域，比如<code>import static java.lang.System.*;</code>之后就可以使用<code>out.println</code> </li></ul></li><li><p>Java的import和C++的include的<strong>区别</strong></p><ul><li>C++中要用#include把外部声明加载进来，C++编译器只能查看正在编译的文件和#include的文件，Java编译器可以查看其他文件，只是告诉编译器要去哪里查看</li><li>Java中显式地给出包名的时候不需要import，而C++要引用别的文件一定要#include</li><li>package和import更类似于namespace和using</li></ul></li></ul><h3 id="3-2-包装类"><a href="#3-2-包装类" class="headerlink" title="3.2 包装类"></a>3.2 包装类</h3><ul><li>类和类之间的关系<ul><li>Association 关联</li><li>Aggregation 聚合</li><li>Composition 组合<ul><li>组合的关系比聚合更加紧密</li></ul></li></ul></li><li>Wrapper class 包装类<ul><li>实现了对Java中的各类基本数据类型的包装</li><li>对象是immutable的，创建之后就不能改变</li><li>包装类的构造函数有多种<ul><li>比如整型的包装类Integer可以用一个int类型来构造，也可以用String类型来构造</li></ul></li><li>数值包装类<ul><li>每个<strong>数值型</strong>的包装类中有常数<code>MAX_VALUE</code>和<code>MIN_VALUE</code> 分别代表这个数据类型中的<strong>可能的最大值和最小值</strong></li><li>所有的<strong>数值型包装类</strong>实现了向其他数值类型转换的方法，比如doubleValue，intValue等等<ul><li>静态方法valueOf：参数是一个字符串，产生对应的数值类型的值</li><li>JDK1.5以上的版本允许包装类和原本的内置类型进行自动转换</li></ul></li></ul></li><li>BigInteger类和BigDecimal类<ul><li>用于处理大数值的包装类</li></ul></li><li><strong>String类</strong>的语法特性<ul><li><code>immutable</code> 不可修改类，需要通过<code>charAt( )</code>方法访问字符串中的单个元素<ul><li>比如<code>String s = &quot;Hello&quot;; s = &quot;Java&quot;;</code> 此时只是新构造出了一个“Java”的String对象并让s指向这个对象，原来的“Hello”对象并没有消失</li></ul></li><li>有连接，比较，获取子串，查找元素和子串等多种操作</li></ul></li><li>自动装箱：AutoBoxing<ul><li>基本类型在运算的时候，JVM会将其装箱成安全的包装类来使用</li></ul></li></ul></li></ul><h3 id="3-3-Constant-Pool-常量池"><a href="#3-3-Constant-Pool-常量池" class="headerlink" title="3.3 Constant Pool 常量池"></a>3.3 Constant Pool 常量池</h3><ul><li><p>Java Constant Pool <strong>常量池</strong>技术</p><ul><li><p>可以方便快捷地创建某些对象，当需要的时候就从池里取出来，常量池实际上就是一个<strong>内存空间</strong>存在于方法区中</p></li><li><p>JVM将源代码编译成class文件之后，会用一部分字节分类存储常量，集中在class中的一个区域存放，包含了关于类方法接口中的常量，也包括字符串常量</p><ul><li>比如<code>String s = &quot;java&quot;</code> 则在编译期可以识别为和java是同一个字符串的，都会自动优化成常量，也就是说如果有多个字符串的值为java则他们都会引用自同一String对象</li></ul></li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">String s1 &#x3D; &quot;Hello&quot;;String s2 &#x3D; &quot;Hello&quot;;String s3 &#x3D; &quot;Hel&quot; + &quot;lo&quot;;String s4 &#x3D; &quot;Hel&quot; + new String(&quot;lo&quot;);String s5 &#x3D; new String(&quot;Hello&quot;);String s6 &#x3D; s5.intern();String s7 &#x3D; &quot;H&quot;, s8 &#x3D; &quot;ello&quot;;String s9 &#x3D; s7 + s8;s1 &#x3D;&#x3D; s2 true;s1 &#x3D;&#x3D; s3 true; &#x2F;&#x2F; 编译期进行了一定的优化s1 &#x3D;&#x3D; s4 false;s1 &#x3D;&#x3D; s5 false;s1 &#x3D;&#x3D; s9 false; &#x2F;&#x2F; s9是两个变量拼起来的s1 &#x3D;&#x3D; s6 true;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>- 对于上面这一段代码，s1，s2和s3是相同的(因为常量池技术)而s1和s4是不同的，s1和s9也是不同的，因为s4和s9不是常量，在编译期没有确定是不是常量     - 而s1和s6是相等的，和s5是不同的，因为s5位于堆中，**intern方法会试图将Hello这个值加入常量池中**，而此时常量池中已经有了Hello所以直接返回了其地址</code></pre><ul><li><p>Java中定义的<strong>包装类大部分实现了常量池技术</strong>，只有<strong>浮点数类型的包装类没有实现</strong></p><ul><li><p>其中Byte,Short,Integer,Long,Character只对-128-127的对象使用常量池 </p><ul><li>Double类型是没有缓存的，所以就会有如下结果</li></ul></li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Double x &#x3D; 1.1;Double y &#x3D; 1.1;x &#x3D;&#x3D; y &#x2F;&#x2F; -&gt; false!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>- Integer利用**缓存**机制实现了常量池，缓存了256个对象，主要是常用的证书</code></pre><h3 id="3-4-String的语法特性"><a href="#3-4-String的语法特性" class="headerlink" title="3.4 String的语法特性"></a>3.4 String的语法特性</h3><ul><li>String的intern方法<ul><li>需要1.7以上的JDK</li><li>intern方法设计的初衷就是要重用String对象，节约内存消耗</li><li>Java的运行时Data Area<ul><li>堆heap中存放创建的实例对象</li><li>方法区中存储了已经被JVM加载的类的信息和静态变量，编译器编译的代码</li><li>JDK1.7之后常量池被放入到堆空间中，导致intern的功能发生了变化</li></ul></li><li>这里有一部分比较重要的，等开学之后再看</li></ul></li><li>String的其他语法<ul><li>String的匹配，代替和分割split，支持正则表达式匹配</li><li>包装类大多都有<code>toString()</code>的<strong>静态方法</strong>用来将其转换成String类型</li><li>String的format方法：根据指定的格式生成String，比如<code>String s = String.format(“%7.2f%6d-4s”,45.556, 14, “AB”);</code> </li><li>关于Java中string的一些细节<ul><li>Java中的String**不是以空字符’\0’**结尾的</li><li>Java中的String不可改变，是<strong>final类型</strong></li><li>在String池中维护</li><li>比较是否相同的时候要用equals方法，不要用==</li><li>使用indexOf等方法去查询元素的位置</li><li>使用subString方法去获取子串，因为==比较的是引用的对象，equals比较的是String所代表的值</li><li>+运算完成了对String的重载</li><li>使用trim方法删除首尾空格</li><li>split方法支持正则表达式</li><li>不要<strong>存储敏感信息</strong>在String中</li></ul></li></ul></li></ul><h4 id="⭐StringBuilder和StringBuffer"><a href="#⭐StringBuilder和StringBuffer" class="headerlink" title="⭐StringBuilder和StringBuffer"></a>⭐StringBuilder和StringBuffer</h4><ul><li>是String的以一种替代品，String可以使用的地方一定也能用这两个，但是更加灵活<ul><li>Builder和Buffer拥有toString，capacity，length，setLength和charAt等方法</li></ul></li><li>三者的比较<ul><li>在执行速度上，<code>StringBuilder&gt;StringBuffer&gt;String</code> <ul><li>比如对于String s = “abcd”，如果我们执行s = s + 1实际上执行之后的<strong>s跟原本的s不是同一个对象</strong>而是生成了一个新的对象(因为String是不可变的)，<strong>原来的对象被垃圾回收了</strong>，导致String的执行效率非常低</li></ul></li><li>线程安全<ul><li>Builder是<strong>线程非安全</strong>的，Buffer是线程安全的，当有多个线程区使用某个字符串时，StringBuilder不安全</li></ul></li></ul></li></ul><p>⭐正则表达式</p><p><img src="/static/image-20201022162510596.png" alt="image-20201022162510596"></p><ul><li>其实我只记得*和+这几个符号</li></ul><h3 id="3-5-枚举类-Enum"><a href="#3-5-枚举类-Enum" class="headerlink" title="3.5 枚举类 Enum"></a>3.5 枚举类 Enum</h3><ul><li>JDK1.5才有的新类型，采用enum关键字定义，所有的枚举类型都继承自Enum类型<ul><li>通常常量用<code>public final static </code>来定义，在枚举类中可以用如下方式定义</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Light</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> RED <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> GREEN <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> YELLOW <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>Java的枚举<strong>本质上是int值</strong></p><ul><li>通过公有的final静态域为每个枚举常量导出实例的类</li><li>由于没有constructor，枚举类型是真正的final，是实例受控的，是单例的泛型化</li><li>比如上面这个枚举类的定义，如果定义了一个Light类型的变量，那么任何非空对象一定属于Light的三个值之一</li></ul></li><li><p>枚举类的特性</p><ul><li>枚举类是final，不能被继承</li><li>含有<code>values()</code>的静态方法，可以<strong>按照声明顺序返回其值数组</strong> </li><li><code>ordinal()</code>方法，返回<strong>枚举值在枚举类中的顺序</strong>，根据声明时候的顺序决定(从0开始)</li><li>可以用valueOf来得到枚举实例，用toString将枚举转化为可以打印的字符串</li><li>比如<code>Light L =  Light.valueOf(&quot;RED&quot;);</code> </li><li>枚举类型也支持switch语句直接对实例进行选择</li><li>enum类型可以可以关联不同的数据，也可以<strong>添加任意的方法和域来增强枚举类型</strong>,比如添加构造函数来丰富枚举类的结构</li><li><strong>特定于常量</strong>的方法实例<ul><li>缺点是难以共享代码，可以借助策略枚举，将处理委托给另一个枚举类型</li></ul></li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public enum Operation&#123;    PLUS&#123;        double apply(double x, double y)&#123;            return x+y;        &#125;    &#125;,    MINUS&#123;        double apply(double x, double y)&#123;            return x-y;        &#125;    &#125;;    abstract double apply(double x, double y);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这一部分听说期末考会考编程题，需要练练</li></ul><p>🐀🐂🐅🐇🐉🐍🐎🐏🐒🐓🐕🐖</p><h3 id="3-6-继承和多态"><a href="#3-6-继承和多态" class="headerlink" title="3.6 继承和多态"></a>3.6 继承和多态</h3><h4 id="3-6-1-继承"><a href="#3-6-1-继承" class="headerlink" title="3.6.1 继承"></a>3.6.1 继承</h4><ul><li>Java中继承的关键词是<code>extends </code> </li><li>super方法：<ul><li>子类没有继承基类的构造函数，但是子类中可以用关键字<code>super</code>去调用基类的构造函数</li><li>如果不显式地声明super，则会<strong>自动调用基类的无参数的构造函数</strong></li><li>super关键字可以调用基类的构造方法</li></ul></li><li>override：覆写父类的方法<ul><li>子类会继承父类所有的方法，但是可以在子类中对父类的方法进行重载，此时调用子类的该方法就会调用新定义的，覆写了原本的方法</li><li><strong>private类型的方法不能被覆写</strong> </li><li>static类型的方法也不能被覆写，如果在子类中被重定义了，那么父类的该静态方法就会被hidden</li><li>JDK1.5开始增加了<code>@override</code>注解来声明一个覆写——不要忘了写override<ul><li>每个类都会有一个equals的方法，要注意区分重载和覆写  </li></ul></li><li>方法的覆写发生在继承的子类中，而<strong>重载在继承的子类和基类中都会发生</strong> </li></ul></li><li>Object类是java.lang.Object中定义的基本类型，如果一个类没有声明继承自何处，那么就是继承自Object类<ul><li>Object中有toString方法，默认情况下会显示一个实例的类名和@符号后面跟一个代表这个实例的数字</li><li><del>万物起源Object</del> </li></ul></li></ul><h4 id="3-6-2-多态-Polymorphism"><a href="#3-6-2-多态-Polymorphism" class="headerlink" title="3.6.2 多态 Polymorphism"></a>3.6.2 多态 Polymorphism</h4><ul><li><p>多态意味着基类可以被引用作为一个子类来使用</p></li><li><p>Java的动态绑定(dynamic binding)特性</p><ul><li>假如一系列类的继承关系如下(其中Cn在Java中式Object类)</li></ul><p><img src="/static/image-20200714164229166.png" alt="image-20200714164229166"></p><ul><li>JVM会从C1开始寻找某个方法P直到找到一个具体的实现为止，然后搜索停止，调用第一个找到的方法</li><li>method match方法匹配，在<strong>编译期</strong>按照参数类型和个数来进行匹配，而动态绑定是在运行时寻找对应的方法</li></ul></li><li><p>Generic Programming 元编程</p><ul><li>当一个方法的参数是superclass的时候，可以用他的任意一个子类作为参数，但是具体的调用会动态地决定</li></ul></li><li><p>Casting objects</p><ul><li>可以在有继承结构中的类型之间互相切换，比如对一个参数要求为Object的方法，可以用new Student()作为其参数，此时会发生从Student到Object的隐式转换</li><li>当从基类转换到子类的时候必须有显示的声明，但不一定总是能成功<ul><li><code>instanceof</code>操作符可以测试一个对象是不是某个类的实例</li></ul></li><li>Java和C++的区别<ul><li>Java转换失败的时候会抛出异常，而C++转换失败会产生一个nullptr，这样就会在一个操作中完成测试和类型转换</li><li>Java中的类型转换需要和instanceof结合使用，先用instanceof判断，然后来进行转换</li></ul></li></ul></li><li><p>equals方法</p><ul><li>默认的equals方法在Object中是这样定义的</li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public boolean equals(Object obj) &#123;    return this &#x3D;&#x3D; obj;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>可以在自定义类中override这个equals方法</li><li>== 比 equals的要求更高，会检测两个引用变量是不是引用的同一个对象，而equals只要求内容相同</li></ul><h3 id="3-7-Java的内置模板类"><a href="#3-7-Java的内置模板类" class="headerlink" title="3.7 Java的内置模板类"></a>3.7 Java的内置模板类</h3><ul><li>ArrayList 任意长度的任意类型数组<ul><li>可以用<code>ArrayList&lt;typename&gt;</code> 来定义一个typename类型的任意长数组</li><li>相比于普通数组，拥有更多功能比如add，remove和clear，和普通数组之间可以互相转换</li><li>ArrayList可以用<code>java.util.Collections.max</code>和<code>min</code>方法来获取其中的最大值</li><li>此外java.util.Collections中还有sort和shuffle等方法</li></ul></li><li>MyStack类<ul><li>一个内置的Stack结构，支持栈的pop，push，peek等多种操作</li></ul></li></ul><h3 id="3-8-关键词protected和final"><a href="#3-8-关键词protected和final" class="headerlink" title="3.8 关键词protected和final"></a>3.8 关键词protected和final</h3><h4 id="3-8-1-protected"><a href="#3-8-1-protected" class="headerlink" title="3.8.1 protected"></a>3.8.1 protected</h4><ul><li>protected关键词表示一个类或者数据或者方法可以<strong>被同一个包或者子类任意访问</strong> </li><li>Java中状态和方法可访问的范围从小到大是private，default，protected，public<ul><li>private只能在同个类中访问</li><li>default可以在private的基础上同个包中访问</li><li>protected在此基础上可以被子类访问</li><li>public可以被随便访问</li></ul></li><li>继承的时候子类在覆写方法的时候不能把Accessibility弱化，只能往上调</li></ul><h4 id="3-8-2-final"><a href="#3-8-2-final" class="headerlink" title="3.8.2 final"></a>3.8.2 final</h4><ul><li>含有final关键字的类不能被继承</li><li>含有final关键字的变量是常量</li><li>含有final关键字的方法不能被覆写</li></ul><h3 id="3-9-嵌套类"><a href="#3-9-嵌套类" class="headerlink" title="3.9 嵌套类"></a>3.9 嵌套类</h3><h4 id="3-9-1-复合优先于继承"><a href="#3-9-1-复合优先于继承" class="headerlink" title="3.9.1 复合优先于继承"></a>3.9.1 复合优先于继承</h4><ul><li>继承打破了代码的封装性，子类依赖于基类中特定功能的实现，如果基类随着版本变化会破坏子类</li><li>复合composition就是不继承而是在新的类中增加一个private state并引用现有类的一个实例</li></ul><h4 id="3-9-2-嵌套类-nested-class"><a href="#3-9-2-嵌套类-nested-class" class="headerlink" title="3.9.2 嵌套类 nested class"></a>3.9.2 嵌套类 nested class</h4><ul><li>可以在<strong>类的内部再定义一个类</strong>，分为<strong>静态嵌套类</strong>和<strong>非静态嵌套类</strong><ul><li>其中非静态嵌套类最重要，也被称为内部类inner，分为<ul><li>在一个类中直接定义的内部类</li><li>在方法中定义的局部类 <code>local class</code> </li><li>匿名内部类 <code>anonymous class</code> </li></ul></li><li>内部类的作用：内部类之间的<strong>private方法可以共享</strong>因此经常被作为辅助类</li><li>public内部类可以在外部类之外调用，但是对于非静态类，必须要使用一个外部类的对象来创建</li><li>内部类如果在外部类可以直接new，但是在外部类的外面使用需要<strong>先new出一个外部类，在用外部类new出一个内部类</strong></li><li>静态内部类不需要通过外部类的对象来创建，外部类的变量和非静态方法都不能调用</li><li>有内部类的时候在编译成class文件的时候会产生多个class文件，<strong>每有一个类定义就会产生一个class文件</strong> </li></ul></li><li>Local class局部类<ul><li>定义在一个方法内部，只能在方法的内部实例化</li><li>方法内部类的对象不能使用该内部类所在方法的非final局部变量</li><li>方法的局部变量位于栈上，只存在于该方法的生命期内<ul><li>但是该方法结束之后，在方法你创建的内部类对象可能仍然存在于堆中</li></ul></li><li>只有final和abstract可以用来修饰方法内部类</li><li>静态方法内的方法内部类只能放为外部类的静态成员</li></ul></li></ul><h3 id="3-10-抽象类和接口-Abstract-class-and-Interfaces"><a href="#3-10-抽象类和接口-Abstract-class-and-Interfaces" class="headerlink" title="3.10 抽象类和接口 Abstract class and Interfaces"></a>3.10 抽象类和接口 Abstract class and Interfaces</h3><ul><li>Interface 接口：用来定义各种类的表现</li></ul><h4 id="3-10-1-Abstract-class-抽象类"><a href="#3-10-1-Abstract-class-抽象类" class="headerlink" title="3.10.1 Abstract class 抽象类"></a>3.10.1 Abstract class 抽象类</h4><ul><li>抽象类的语法特性<ul><li>抽象类<strong>不能实例化出对象</strong>，抽象方法<strong>不能在非抽象类中使用</strong> </li><li>抽象类不能使用new操作符，但是依然可以定义构造方法并在子类中调用<ul><li>抽象类的非抽象子类可以创建对象</li><li>可以作为一种数据类型</li></ul></li><li>Java中的抽象类表示一种继承关系，一个类<strong>只能继承一个抽象类</strong> </li><li>抽象方法一定属于抽象类，抽象类不一定需要有抽象方法</li><li>子类也可以是抽象类，不管是继承了一个抽象类还是一个具体的类</li></ul></li><li>抽象方法<ul><li>只有方法体，没有方法名</li><li>继承了抽象方法的子类必须override这个方法，否则这个子类也必须声明为抽象类，最终必须有子类override这个方法，否则这些类定义都不能实例化出对象</li></ul></li></ul><h4 id="3-10-2-Interface-接口"><a href="#3-10-2-Interface-接口" class="headerlink" title="3.10.2 Interface 接口"></a>3.10.2 Interface 接口</h4><ul><li>接口只包含常数和抽象方法，用于指定对象的通用行为，定义的方法如下<ul><li>接口是抽象方法的集合</li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface InterfaceName &#123;constant declarations;abstract method signatures;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>接口也不能实例化出一个对象，但是接口名<strong>可以作为变量类型</strong>来使用</p><ul><li>抽象类中所有的数据都是<code>public final static</code>类型，所有的方法都是<code>public abstract</code>类型</li><li>接口中的方法不是在接口中实现的，只能由实现接口的类来具体实现接口中的方法</li><li>JDK1.8以后接口里可以写静态方法和方法体</li><li>接口可以继承其他的接口</li></ul></li><li><p>实现接口的关键字：用<code>implements</code>关键字来<strong>让一个类实现接口中的方法</strong></p><ul><li>如果实现接口的类是抽象类，就可以先不用实现</li><li>一个类可以有多个接口，但是只能继承自一个类</li></ul></li><li><p>marker interface 标记接口</p><ul><li><strong>没有任何方法和属性</strong>的接口，仅仅表明它的类属于某个特定的类型，这个接口只起到了标记作为</li><li>主要用于<ul><li>建立一个公共的父接口</li><li>向一个类添加数据类型</li></ul></li></ul></li><li><p>接口和抽象类的区别</p><ul><li>抽象类的方法可以有方法体</li><li>抽象类中的成员变量可以实各种类型的，接口中只能是<code>public static final</code>类型</li><li>接口中不能含有静态代码块和静态方法</li><li>一个类只能继承一个抽象类，但是可以实现多个接口</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java应用技术1:基础语法</title>
      <link href="2021/05/04/java1/"/>
      <url>2021/05/04/java1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java应用技术1：基础语法"><a href="#Java应用技术1：基础语法" class="headerlink" title="Java应用技术1：基础语法"></a>Java应用技术1：基础语法</h1><h4 id="RandomStar"><a href="#RandomStar" class="headerlink" title="RandomStar"></a>RandomStar</h4><h3 id="成绩组成"><a href="#成绩组成" class="headerlink" title="成绩组成"></a>成绩组成</h3><ul><li>平时分70%+期末考试30%<ul><li>包含出勤，PTA作业，编程小作业，大作业，期中考试</li></ul></li></ul><h2 id="Chapter-1：Introduction"><a href="#Chapter-1：Introduction" class="headerlink" title="Chapter 1：Introduction"></a>Chapter 1：Introduction</h2><h3 id="1-1-Java语言的特性"><a href="#1-1-Java语言的特性" class="headerlink" title="1.1 Java语言的特性"></a>1.1 Java语言的特性</h3><ul><li>简洁<ul><li>没有C/C++中的指针，没有多重继承和运算符重载的语法特性</li></ul></li><li>面向对象<ul><li>Java设计的核心是如何复用代码，并且支持继承封装多态</li></ul></li><li>Interpreted<ul><li>代码会编译成字节码(bytecode)在Java虚拟机上运行</li><li>Java是跨平台的，可以在所有有JVM的计算机上运行，JMV可以设置不同的安全等级</li></ul></li><li>鲁棒性<ul><li>强类型机制，异常处理，垃圾内存自动搜集等机制</li></ul></li></ul><h3 id="1-2-JDK的版本"><a href="#1-2-JDK的版本" class="headerlink" title="1.2 JDK的版本"></a>1.2 JDK的版本</h3><ul><li>Java Standard Edition (J2SE)<ul><li>可以用于开发客户端应用和app</li></ul></li><li>Java Enterprise Edition (J2EE)<ul><li>可以用于开发服务端应用，比如Java Servlets</li></ul></li><li>Java Micro Edition (J2ME)<ul><li>开发手机应用</li></ul></li><li>本课程中的内容主要是<strong>J2SE</strong> </li></ul><h3 id="1-3-Java程序的组成"><a href="#1-3-Java程序的组成" class="headerlink" title="1.3 Java程序的组成"></a>1.3 Java程序的组成</h3><ul><li>一个简单的Java程序</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Java代码编译的过程<ul><li>Java代码文件的后缀名是<code>.java</code>，被Java编译器编译之后编译成<code>.class</code>文件，之后在JVM中运行</li></ul></li><li>每个Java程序至少需要一个class，每个class都有唯一的class name<ul><li>block是java程序的组件，比如一个类就是一个class block</li></ul></li><li>Java程序中的错误<ul><li>语法错误Syntax Error：会在编译期间被检查出来，因此有语法错误的时候无法通过编译</li><li>运行时错误 Run time Error：</li><li>程序逻辑上本身的错误</li></ul></li></ul><h3 id="⭐作业里一道莫名其妙的题目"><a href="#⭐作业里一道莫名其妙的题目" class="headerlink" title="⭐作业里一道莫名其妙的题目"></a>⭐作业里一道莫名其妙的题目</h3><ul><li>对于下面的这样一个Java程序，它<strong>可以通过编译</strong>但是运行的时候会因为<strong>没有入口main函数</strong>而出现错误<ul><li>这是因为Java的编译器会把类编译成class文件，下面这个类是一个合法的类，没有语法错误，因此可以通过编译</li><li>但是在JVM中执行的时候会因为没有入口main函数而出现错误</li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class main &#123;    public void main() &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-Java的基本语法"><a href="#2-Java的基本语法" class="headerlink" title="2. Java的基本语法"></a>2. Java的基本语法</h2><h3 id="2-1-Java的变量命名"><a href="#2-1-Java的变量命名" class="headerlink" title="2.1 Java的变量命名"></a>2.1 Java的变量命名</h3><ul><li><p>变量：包含大小写字母，数字，下划线和$符号</p><ul><li>Java中的变量不能用数字开头，也不能是保留字</li></ul></li><li><p>变量的定义和声明</p><ul><li>Java中<strong>不区分变量的声明和定义</strong>，这是和C/C++的最大不同<ul><li>C/C++中的编译器<strong>不会为基本类型赋予初始默认值</strong></li></ul></li><li>Java对于方法的局部变量，Java以<strong>编译时错误</strong>来保证**变量在使用前都能得到恰当的初始化 ** <ul><li>但是Java对于方法内的单个变量不会赋予初始值，对于数组会赋予默认的值</li></ul></li></ul></li><li><p>对于下面这样一段代码</p><ul><li>输出的结果是0，因为<strong>变量进行了初始化但是没有赋予具体值</strong></li><li>Java中int类型的默认值就是0</li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class JavaPractice &#123;    static int array[] &#x3D; new int[5];    public static void main(String a[]) &#123;        System.out.println(array[0]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>常量</strong>定义<code>final datatype CONSTANTNAME = VALUE;</code></p><ul><li>final的主要用法有如下三种<ul><li>修饰变量，表示变量的值<strong>不能改变</strong>，但是可以进行任何合法形式的初始化，相当于C/C++中的const类型<ul><li>修饰类对象，表示这个变量不能再赋值成其他的对象，比如一个对象被new了之后，就不能再把它new成一个新的对象</li></ul></li><li>修饰方法method，表示一个Java函数不可更改，<strong>不能被重载</strong> </li><li>修饰类，表示这个类<strong>不能被继承</strong>，类中的所有方法也就变成了final类型的</li></ul></li></ul></li><li><p>Java中的变量类型</p><ul><li>数值型变量：Java中整数类型的范围和<strong>运行的机器无关</strong>，这一点和C/C++不同<ul><li>byte 8bit 有符号类型</li><li>short 16bit 有符号类型</li><li>int 32bit有符号类型</li><li>long 64bit有符号类型</li><li>float和double分别是32bit和64bit的IEEE754标准</li></ul></li><li><strong>字符类型char</strong> <ul><li>编码方式是Unicode</li><li>Java中的一个char类型变量占16bits，也就是2个字节</li></ul></li></ul></li><li><p>数值类型的读入</p><ul><li>首先需要定义Scanner读入器<code>Scanner input = new Scanner(System.in)</code></li><li>之后可以用input的<code>nextInt</code>方法读取下一个整数，其他数据类型同理</li></ul></li><li><p>Java中的数值运算：支持加减乘除取余等各种操作</p><ul><li><p>除法中如整数除法的结果是整数，浮点数除法的结果浮点数</p></li><li><p>浮点数中double比float更加精确，double精确到16位，float精确到8位小数</p></li><li><p>几个特殊的浮点数值</p><ul><li><code>Double.POSITIVE_INFINITY</code> 正无穷大</li><li><code>Double.NEGATIVE_INFINITY</code> 负无穷大</li><li><code>Double.NaN</code> 不是数字</li><li>可以用Double.isNaN来判断是否为数字</li></ul></li></ul></li><li><p>类型转换：byte，short，int，float，double，long，char之间可以进行类型转换</p><ul><li>其中整形向浮点型的转换可能会造成精度的损失</li><li>浮点数向整形转换的时候会丢弃小数部分</li><li>Java不支持C++中的自动强制类型转换，有需要的类型转换必须显式地声明</li></ul></li></ul><h3 id="2-2-选择语句"><a href="#2-2-选择语句" class="headerlink" title="2.2 选择语句"></a>2.2 选择语句</h3><ul><li>布尔类型变量(boolean) 值只有true和false，Java中的大小关系符和C/C++一致</li></ul><h4 id="2-2-1-if语句和switch语句"><a href="#2-2-1-if语句和switch语句" class="headerlink" title="2.2.1 if语句和switch语句"></a>2.2.1 if语句和switch语句</h4><ul><li><p>和C/C++基本一致，没啥好学的</p></li><li><p>if语句有单个if，if-else，多层嵌套if等写法，<strong>else和最近的if匹配</strong> </p></li><li><p>switch语句也跟C/C++基本一致，有break有default</p><ul><li>布尔类型不能用在switch的选择里，下面的代码是错误的</li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">boolean x;switch(x) &#123;  &#x2F;&#x2F; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-逻辑运算符"><a href="#2-2-2-逻辑运算符" class="headerlink" title="2.2.2 逻辑运算符"></a>2.2.2 逻辑运算符</h4><ul><li><p>Java中有如下逻辑运算符</p><ul><li>！逻辑否，&amp;&amp;逻辑且，|| 逻辑或，<strong>^逻辑异或</strong> </li><li>&amp;&amp;和||的运算按照短路的方式来求值，如果第一个操作数已经可以确定表达式的值，后面的就不需要进行运算了</li><li>&amp;和|也可以进行逻辑运算，区别是这两个不用短路的方式来求值</li></ul><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200708231822126.png" alt="image-20200708231822126" style="zoom:67%;" /></li></ul><h3 id="2-3-数学函数"><a href="#2-3-数学函数" class="headerlink" title="2.3 数学函数"></a>2.3 数学函数</h3><ul><li>常见的两个常数：PI和E表示圆周率和自然对数的底数</li><li>常见的数学类方法<ul><li>三角函数</li><li>幂</li><li>高斯函数和舍入方法</li><li>最大，最小，绝对值和随机</li></ul></li></ul><h3 id="2-4-字符和字符串类型"><a href="#2-4-字符和字符串类型" class="headerlink" title="2.4 字符和字符串类型"></a>2.4 字符和字符串类型</h3><ul><li>Java中的字符类型有两种表示方式，ASCII编码和Unicode编码模式<ul><li>Unicode编码模式的形式是前缀<code>\u</code>+四位十六进制数，可以表示从0000到FFFF一共65536个字符</li><li>常见的ASCII码<ul><li>‘0’ - ‘9’在ASCII码中式48到57</li><li>‘A’ - ‘Z’ 式65-90， ‘a’-‘z’是97-122</li></ul></li></ul></li><li>字符串内置方法</li></ul><p><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200709172718342.png" alt="image-20200709172718342"></p><ul><li><p>字符串类型 String</p><ul><li>一些简单的内置方法</li></ul><p><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200709174536954.png" alt="image-20200709174536954"></p><p><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200709175413874.png" alt="image-20200709175413874"></p><ul><li>读取字符串的方式：<ul><li>使用next() 从有效字符开始扫描，遇到第一个分隔符或者结束符的时候结束，将结果作为字符串返回</li><li>nextLine扫描当前行所有的字符串作为结果返回</li></ul></li><li>获取字串，使用<code>substring</code>方法，必须要有的参数是起始位置beginIndex，结束位置endIndex可以缺省，默认值是字符串末尾</li><li>访问单个字符和子串的位置</li></ul><p><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200709175604703.png" alt="image-20200709175604703"></p><ul><li>字符串类型是不可变的，不能对String中的内容做出改变，同时如果在函数中对String进行赋值操作也不能改变主函数里的String，比如下面这样一段代码，最后的输出还是A,B</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">String</span> x<span class="token punctuation">,</span> <span class="token class-name">String</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        y <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>String的concat和substring等方法都不是在原来的字符串上操作的，而是生成了一个新的字符串</p></li><li><p>格式化输出</p><ul><li><p><code>System.out.printf(format, items);</code> 具体的用法和C语言的printf类似</p></li><li><p>占位符的具体格式包括</p><ul><li><p><code>%[index$][标识]*[最小宽度][.精度]转换符</code> </p></li><li><p>index表示从第几个位置开始计算来进行格式化，起始为1</p></li><li><p>最小宽度是格式化之后最小的长度，当输出结果小于最小宽度的时候用标识符填补空格，没有标识符的时候用空格填充</p><ul><li>字符串可用标识：- 表示左对齐，默认的是右对齐</li><li>整数和浮点数可用标识：</li></ul><p><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200709192611084.png" alt="image-20200709192611084"></p><ul><li>对日期进行格式化</li></ul></li><li><p>精度用于设置浮点数保留几位小数</p></li><li><p>转换符用于指定转化的格式，有f，d等等</p></li></ul></li></ul></li></ul><h3 id="2-5-循环"><a href="#2-5-循环" class="headerlink" title="2.5 循环"></a>2.5 循环</h3><ul><li>和C/C++基本一致，有for循环，while循环和do-while循环<ul><li>要注意区别while循环和do-while循环</li><li><code>for(;;)&#123;&#125;</code>和<code>while(true)&#123;&#125;</code>等价</li><li>Java中也有<code>break</code>和<code>continue</code>来结束或者跳出循环</li></ul></li></ul><h3 id="2-6-方法"><a href="#2-6-方法" class="headerlink" title="2.6 方法"></a>2.6 方法</h3><ul><li>将程序中的一部分过程抽象成一个方法，起到代码复用的作用，一个方法的定义包含如下如内容<ul><li>modifier 修饰符，包括方法的public/private/protected和是否是static，final等属性</li><li>return value type 返回值类型</li><li>method name 方法名</li><li>formal parameters 形式参数<ul><li>方法名+形式参数称为方法的签名</li><li>与之相对应的是actual parameter or argument实际参数，也就是调用方法的时候使用的参数</li><li>实参的内容不会因为方法中的操作被改变</li></ul></li><li>body 方法的具体内容</li></ul></li><li>方法的重载：相同的方法名，不同的参数表构成重载关系<ul><li>只有返回值类型不相同的时候不构成重载，这种写法会引起编译错误，不能使用</li><li>重载可以有返回值类型的区别，但是一定会有<strong>参数表的区别</strong> </li></ul></li><li>局部变量：定义在方法内部的变量叫做局部变量<ul><li>局部变量的可调用范围是从定义开始到不再包含这个变量的方法内部区域为止(比如for循环中定义的变量只能在for循环中调用) </li></ul></li></ul><h3 id="2-7-数组"><a href="#2-7-数组" class="headerlink" title="2.7 数组"></a>2.7 数组</h3><h4 id="2-7-1-一维数组"><a href="#2-7-1-一维数组" class="headerlink" title="2.7.1 一维数组"></a>2.7.1 一维数组</h4><ul><li><p>Java中数组的定义方式<code>datatype[ ] array</code>，中括号也可以放在后面，然后需要用<code>new datatype[size]</code>来声明数组的大小</p><ul><li>可以用length来获得数组的长度，但要注意这个和String类型的<code>length()</code> <strong>方法</strong>不一样，数组里的length是state</li><li>数组的长度定义之后就<strong>不能改变</strong> </li><li>数组的长度确定之后，里面所有元素的值会被设定为默认值<ul><li>对于数值类型的数组，默认值是0</li><li>对于char类型，默认值是<code>\u0000</code></li><li>对于boolean类型，默认值是false</li></ul></li><li>数组可以在定义的时候直接赋予若干值，此时数组的长度会被自动设定为值的个数，但是下面这种方式是错误的</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> list<span class="token punctuation">;</span>list <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>Java数组和C++数组的<strong>区别</strong> <ul><li>Java的数组定义在<strong>堆</strong>上，C++中直接声明大小的数组分配在栈上，动态分配的数组在堆上</li><li>Java的[ ]运算符被会检查数组边界，防止下标溢出，并且没有指针运算</li><li>Java中命令行参数是<code>String[] args</code>，其中<code>args[0]</code>是第一个参数，<strong>程序名没有存储</strong>在args中需要在启动Java程序的时候就输入</li></ul></li><li>数组的遍历<ul><li>用下标i去遍历一个数组</li><li>用<code>elementType value: arrayRefVar</code> 的形式来遍历</li></ul></li><li>数组的拷贝：<code>arraycopy(sourceArray, src_pos, targetArray, tar_pos, length);</code> 自带的处理方法<ul><li>在拷贝的过程中，如果被拷贝的数组存在多余的元素，则赋以默认值，如果小于原始数组长度，则只拷贝前面的元素</li></ul></li><li>数组作为方法的参数<ul><li>Anonymous Array 匿名数组：在方法调用中的参数里直接写一个数组，没有用变量去引用，如<code>new int[]&#123;1,2,3&#125;</code>直接作为参数</li><li>将数组作为参数的时候，数组作为一个引用传入，方法中改变数组的值将会影响到原来的数组，但是匿名数组没有变量名</li></ul></li></ul><h4 id="2-7-2-多维数组"><a href="#2-7-2-多维数组" class="headerlink" title="2.7.2 多维数组"></a>2.7.2 多维数组</h4><ul><li>二维数组的定义：<code>dataType[][] refVar;</code> <ul><li>如何new：<code>new dataType[rowSize][columnSize]</code> </li><li>Java的二维数组每一列大小可以不同，并不需要完全相同！<ul><li>比如<code>int[][] a = &#123;&#123;1, 2&#125;, &#123;3, 4, 5&#125;&#125;;</code> </li></ul></li></ul></li><li>如何创建一个二维数组？以下四种写法中，只有第2行的是对的<ul><li>总结起来就是中括号可以放在前面也可以放在后面，但是<strong>声明的时候不能直接指定数组的大小</strong></li><li>数组的大小需要在new的时候指定，并且二维数组<strong>一定要有行的数目</strong> </li></ul></li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int a[3][2] &#x3D; &#123;&#123;1, 2&#125;, &#123;2, 3&#125;, &#123;3, 4&#125;&#125;;int a[][] &#x3D; new int[3][];int[][] a &#x3D; new int[][3];int[][] a &#x3D; new int[][];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络4:应用层与网络安全</title>
      <link href="2021/05/04/cn4/"/>
      <url>2021/05/04/cn4/</url>
      
        <content type="html"><![CDATA[<h4 id="Chapter6：Application-Layer"><a href="#Chapter6：Application-Layer" class="headerlink" title="Chapter6：Application Layer"></a>Chapter6：Application Layer</h4><h3 id="6-1-域名系统DNS"><a href="#6-1-域名系统DNS" class="headerlink" title="6.1 域名系统DNS"></a>6.1 域名系统DNS</h3><ul><li>域名系统(Domain Name System)用于将主机名字转换成IP地址<ul><li>DNS是一个分布式的域名系统，是一个联机的分布式数据库系统，并采用C/S模式，大多数域名在本地解析而少量解析需要互联网上的通信</li><li>域名到IP地址的解析是由分布在互联网上的许多域名服务程序共同完成的，域名服务器在专门设置的节点上运行</li><li>解析的时候需要把需要解析的域名放在DNS请求报文中，以UDP用户数据报的方式发送给本地域名服务器，本地域名服务器把对应的IP地址放在回答报文中返回，如果没找到就需要向别的域名服务器发出请求</li></ul></li><li>域名：层次树状结构<ul><li>从左到右域名级别逐渐提高，并且用小数点隔开，域名都由英文字母和数字组成，除了-以外不能使用其他标点符号</li><li>顶级域名：国家顶级域名如cn，通用顶级域名如com，基础结构域名，只有一个arpa</li></ul></li><li>域名服务器<ul><li>采用分区的方法解决这个问题，一个服务器所管辖的范围叫做区，一个区中的所有节点都是可以联通的，每一个区设置相应的权限域名服务器，用来保存该区中所有主机的域名，区是域的子集</li><li>根域名服务器：最高层次、最重要的域名服务器，本地域名服务器无法解析的时候会首先请求根域名服务器，采用了任播技术</li><li>顶级域名服务器：负责管理所有该顶级域名下的二级域名</li><li>权限域名服务器：负责管理一个区的域名服务器</li><li>本地域名服务器，也叫默认域名服务器和</li><li>为了提高安全性，可以设置一个主域名服务器和若干个辅助域名服务器</li></ul></li><li>域名解析的查询<ul><li>主机向本地域名服务器的查询一般都是递归查询，即如果查不到，就由本地域名服务器向根域名服务器发送查询请求而不是让主机自己进行下一步的查询</li><li>本地域名服务器向根域名服务器的查询是迭代查询，即由本地域名服务器一个个查过去，当然也可以是递归查询</li><li>为了提高查询效率，域名服务器中广泛使用了高速缓存</li></ul></li></ul><h3 id="6-2-电子邮件相关协议"><a href="#6-2-电子邮件相关协议" class="headerlink" title="6.2 电子邮件相关协议"></a>6.2 电子邮件相关协议</h3><ul><li><p>两个最重要的标准：简单邮件传送协议SMTP和互联网文本报文格式</p></li><li><p>一个电子邮件系统最重要的三个组成构件</p><ul><li>用户代理：一般就是一个电子邮件客户端软件，至少需要有撰写、显示、处理、通信等功能</li><li>邮件服务器：必须要同时可以充当客户机和服务器</li><li>邮件发送协议SMTP和邮件读取协议POP3，都是使用TCP连接来传送邮件</li></ul></li><li><p>邮件发送的过程：</p><ul><li>用户代理用SMTP向发送方邮件服务器的SMTP服务器建立TCP连接发送</li><li>发送方邮件服务器的SMTP客户向接受方的邮件服务器建立TCP连接，并发送给SMTP服务器</li><li>接收方的POP3服务器读取邮件向收件人的用户代理POP3客户发送邮件的内容</li></ul></li><li><p>邮局协议POP3</p><ul><li>非常简单但是功能有限的邮件读取协议，使用客户服务器的工作方式</li><li>需要用户输入鉴别信息之后才允许对邮箱进行读取</li><li>只要用户从POP3服务器中读取了邮件，POP3服务器就把该邮件删除</li></ul></li><li><p>网际报文存取协议IMAP</p><ul><li>比POP3复杂的多，也使用客户服务器的方式工作</li><li>是一个联机协议，用户计算机上运行IMAP的客户程序，然后和接收方的邮件服务器上的IMAP服务器程序建立TCP连接，因此就可以在自己的电脑本地操纵邮件服务器的邮件</li><li>最大的好处是用户可以在不同的地方使用不同的计算机随时读取邮件</li></ul></li><li><p>通用互联网邮件扩充MIME</p><ul><li>SMTP只能传输ASCII编码的文本文件，而不能传送可执行文件或者二进制对象，限于传送7位的ASCII码和并且会拒绝超过一定长度的邮件</li><li>MIME没有取代或者改动SMTP，而是继续使用原来的邮件格式，但是增加了邮件主体的结构</li><li>这个应该了解一下就好，不然太离谱了</li></ul></li></ul><h3 id="6-3-万维网-World-Wide-Web"><a href="#6-3-万维网-World-Wide-Web" class="headerlink" title="6.3 万维网 World Wide Web"></a>6.3 万维网 World Wide Web</h3><ul><li><p>万维网</p><ul><li>是一个大规模的、联机式的信息储藏所，使用链接的方法能非常方便访问互联网上的站点</li><li>万维网是一个分布式的超媒体系统，是<strong>超文本系统</strong>的扩充</li><li>万维网以客户服务器的方式进行工作，客户程序向服务器程序发出请求，服务器程序发送回所要的万维网文档</li><li>运用统一资源定位符URL和超文本传输协议HTTP来标志、发送各类文档</li></ul></li><li><p>统一资源定位符URL</p><ul><li>表示从互联网中得到的资源位置和访问这些资源的方法</li><li>基本的格式是：<code>协议://主机:端口/路径</code> 不区分大小写</li><li>使用HTTP协议的URL就是<code>http://主机:端口/路径</code></li></ul></li><li><p>HTTP协议</p><ul><li>HTTP协议定义了浏览器怎么想万维网服务器请求万维网文档，以及服务器如何把文档传送给服务器</li><li>HTTP是面向事务的，可以传输文本、超文本、声音、图像等格式的信息</li><li>使用TCP作为运输层的协议，需要在建立TCP连接之后再进行发送，保证了传输的可靠</li><li>每次交互有一个ASCII编码的串进行交互，即类MIME格式</li><li>HTTP协议是无状态的，即多次访问同一个服务器上的同一个页面，服务器的响应是相同的</li><li>持续连接特性<ul><li>HTTP/1.1的持续连接有两种工作方式，即流水线式的和非流水线式的</li><li>流水线式的，客户收到HTTP响应报文之前就能接着发送新的请求，可以连续发送HTTP响应，客户访问所有的对象只需花一个RTT时间，流水线的工作方式使得TCP连接中的空闲时间减少</li></ul></li><li>HTTP的状态码</li></ul><img src="image-20201215110240401.png" alt="image-20201215110240401" style="zoom:50%;" /><ul><li>HTTP的cache，也叫代理服务器，是一种网络实体，将最近的一些请求和响应放在本地磁盘中，如果发现这个请求和暂时存放的请求相同，就返回已经存储的响应而不需要按照URL再次访问该资源</li></ul><img src="image-20201215110402922.png" alt="image-20201215110402922" style="zoom:50%;" /></li><li><p>HTTP报文请求</p><ul><li>HTTP的报文分为两类，请求报文和响应报文</li><li>HTTP是面向文本的，因此在报文中的每个字段都是ASCII码串，因此各个字段的长度是不确定的，每个报文有三个部分组成：<ul><li>开始行：用于区分是请求报文还是响应报文，请求报文中叫做请求行，响应报文中叫做状态行，以回车换行结尾<ul><li>请求行有方法、URL和HTTP协议的版本，方法就是GET、POST等等</li><li>响应报文中的状态行有版本、状态码和短语</li></ul></li><li>首部行：可以有若干行，传输一些信息，用<strong>字段名+空格+value+回车换行</strong>的形式存储</li><li>实体主体：请求一般没有，响应中可能会有</li></ul></li></ul></li></ul><h4 id="Chapter-7-Network-Security"><a href="#Chapter-7-Network-Security" class="headerlink" title="Chapter 7: Network Security"></a>Chapter 7: Network Security</h4><h3 id="7-1-密码学和散列函数"><a href="#7-1-密码学和散列函数" class="headerlink" title="7.1 密码学和散列函数"></a>7.1 密码学和散列函数</h3><ul><li>加密模型：任何加密模型的安全性取决于密钥的长度，以及攻破所需的计算量</li></ul><img src="image-20201229102205472.png" alt="image-20201229102205472" style="zoom:33%;" /><ul><li><p>两类密码体制</p><ul><li>对称密钥体制：加密密钥和解密密钥使用相同的密码体制<ul><li>DES是一种分组密码，由IBM公司研制，安全性更强的有三重DES</li><li>AES（高级加密标准）由Joan Daemen和Vincent Rijmen研制出，原名叫做Rijndael算法</li></ul></li><li>公钥密码体制：使用不同的加密密钥和解密密钥<ul><li>RSA是Rivest、Shamir和Adleman提出的</li></ul></li></ul></li><li><p>密码散列函数：</p><ul><li>单向加密，输入长度不固定但是输出的长度固定</li><li>要找到两个报文使得其具有相同的输出，在计算上是不可行的</li><li>MD5:报文摘要算法，算法需要将报文按规则填充成512的倍数，然后每个512位的块分成128位，128位再分成32位的小块</li><li>SHA是美国NIST系统的散列算法，但是码长是160位，比MD5更安全</li></ul></li><li><p>密码攻击</p><ul><li>重放攻击replay attact：直接截获密码报文，不需要破译，而是伪装成发送方发给接收方，可以使用不重数nonce</li><li>中间人攻击man-in-the-middle：我也没看懂，大概就是中间人把不重数用自己的私钥加密之后发送，然后分别向发送方和接收方发送获取公钥的请求</li></ul></li><li><p>密钥分配</p><ul><li>由于密码算法是公开的，网络的安全性就完全基于密钥的保护</li><li>对称密钥的分配<ul><li>设立密钥分配中心KDC，常用的密钥分配协议是Kerberos V5，使用鉴别服务器AS和票据授予服务器TGS</li><li>票据有一定的有效期，过期了密钥就失效了，不能被用于长久的重放攻击</li></ul></li><li>公钥的分配<ul><li>使用认证中心把公钥和对应的实体进行绑定</li><li>ITU-T制定了X.509协议标准，并在RFC5280中给出了互联网公钥基础结构PKI</li></ul></li></ul></li></ul><h3 id="7-2-互联网安全协议"><a href="#7-2-互联网安全协议" class="headerlink" title="7.2 互联网安全协议"></a>7.2 互联网安全协议</h3><ul><li>IPsec协议族<ul><li>可以在IP层提供互联网通信安全的协议族，可以分为<ul><li>IP安全数据报格式的两个协议：鉴别首部AH协议和封装安全有效载荷ESP协议</li><li>有关加密算法的三个协议</li><li>互联网密钥交换IKE协议</li></ul></li><li>IP安全数据报有两种不同的方式：<ul><li>运输方式：运输层报文段的前后分别添加若干控制信息再加上IP头部</li><li>隧道方式：在原始的IP数据报前后添加控制信息，再加上心得IP首部构成一个IP安全数据报</li></ul></li><li>安全关联SA是发送IP安全数据报之前在源实体和目的实体之间创建一条网络层的逻辑链接，将无连接的网络层变成了具有逻辑链接的一个层，并且是单向连接</li></ul></li><li>运输层安全协议<ul><li>安全套接字层SSL：是Netscape提出的安全协议，作用在HTTP和运输层之间，在TCP之上建立一个安全通道<ul><li>提供的服务<ul><li>SSL服务器鉴别，允许用户正式服务器的身份</li><li>SSL客户鉴别，允许服务器证实客服身份</li><li>加密SSL绘画，对客户和服务器之间的报文进行加密，并检测报文是否被篡改</li></ul></li><li>工作过程：协商加密算法、服务器鉴别、会话密钥计算、安全数据传输</li><li>HTTPs是提供安全服务的HTTP协议，调用SSL对整个网页进行加密</li></ul></li><li>运输层安全TLS：基于SSL的标准化协议</li><li>原本还有安全电子交易SET协议，但是已经out了</li></ul></li><li>应用层安全协议<ul><li>PGP是Zimmerman于1995年开发的电子邮件的标准</li></ul></li></ul><h3 id="7-3-防火墙和入侵检测"><a href="#7-3-防火墙和入侵检测" class="headerlink" title="7.3 防火墙和入侵检测"></a>7.3 防火墙和入侵检测</h3><ul><li>防火墙是一种访问控制技术，是一种特殊的路由器<ul><li>可以禁止任何不必要的通信，可以实施访问控制策略</li><li>防火墙内的是可信的网络，墙外面是不可信的网络</li><li>防火墙的主要技术分为<ul><li>分组过滤路由器：按照一定的规则进行分组过滤，对进出内部网络的分组执行转发或者丢弃</li><li>代理服务器，在应用层通信中扮演报文中继的角色，一种网络应用需要一个应用网关，所有的进出网络的应用程序都必须通过应用网关</li><li>往往两种技术混合使用</li></ul></li></ul></li><li>入侵检测系统IDS<ul><li>对网络的分组执行深度分组检查，当观察到可疑分组的时候向网络管理员发出警报</li><li>可以检测多种网络攻击：网络映射、端口扫描、DoS攻击（拒绝服务攻击，分布式拒绝服务简称DDoS）、蠕虫和病毒、系统修改漏洞攻击等等</li><li>一般可以分为基于特征的入侵检测和基于异常的入侵检测</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络3:网络层和运输层</title>
      <link href="2021/05/04/cn3/"/>
      <url>2021/05/04/cn3/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5：Network-Layer"><a href="#Chapter-5：Network-Layer" class="headerlink" title="Chapter 5：Network Layer"></a>Chapter 5：Network Layer</h2><h3 id="5-1-网络层的设计"><a href="#5-1-网络层的设计" class="headerlink" title="5.1 网络层的设计"></a>5.1 网络层的设计</h3><ul><li><p>网络层</p><ul><li>关注的是如何将源端的数据包发送到接收方</li><li>可以通过中间路由器进行转发，数据链路层只负责将线路从一边传送到另一边，而网络层是<strong>处理端到端数据传输的最底层</strong> </li><li>因此网络层必须知道网络的拓扑结构，并选择适当的路径进行传输</li></ul><p><img src="/2021/05/04/cn3/image-20201027100044982.png" alt="image-20201027100044982"></p><ul><li>网络层提供给传输层的服务<ul><li>应该独立于路由器技术，向传输层屏蔽网络拓扑结构的具体内容</li><li>传输层可用的网络地址应该有一个统一的编地址方案</li></ul></li></ul></li><li><p>网络层提供的服务</p><ul><li><p>无连接服务：</p><ul><li>每个数据包独立路由，不需要任何预先的设置</li><li>此时的数据包通常也称为数据报datagram，对应的网络称为数据报网络</li><li>每个路由器中都有一个内部表，指明了针对每一个可能的目标地址应该将数据包送到哪里去。<ul><li>表中的每一项由两个部分组成：目标地址和通往目标地址所使用的出境线路</li><li>管理路由表更新的算法称为路由算法</li></ul></li></ul><p><img src="/2021/05/04/cn3/image-20201027102548025.png" alt="image-20201027102548025"></p></li><li><p>面向连接的服务：</p><ul><li>在发送数据包之前需要先建立起一条虚电路，对应的网络称为虚电路网络</li><li>一个例子是多协议标签交换 MPLS</li></ul><p><img src="/2021/05/04/cn3/image-20201027103350204.png" alt="image-20201027103350204"></p></li></ul></li></ul><h3 id="5-2-路由算法"><a href="#5-2-路由算法" class="headerlink" title="5.2 路由算法"></a>5.2 路由算法</h3><ul><li><p>是<strong>网络层软件</strong>的一部分，负责确定一个入境数据包应该被发送到哪条线路上</p><ul><li>路由算法需要有一定的鲁棒性和稳定性，能够处理拓扑结构和流量的各种变化</li><li>功能：路由routing和转发forwarding</li><li>可以分为自适应算法和非自适应算法<ul><li>非自适应算法不会根据流量和拓扑结构来调整路由决策，也叫做<strong>静态路由</strong> </li><li>自适应算法会根据拓扑结构和流量来改变路由策略，也叫做<strong>动态路由</strong> </li></ul></li></ul></li><li><p>最优化原则</p><ul><li>最优化原则的表述：最优路径上的子路径一定是最优路径</li><li>从所有源到制定目标的最优路径构成的集合构成了一棵以目标节点为根的树，称为汇集树<code>sink tree</code> </li></ul></li><li><p>几种常用的算法</p><ul><li><p>最短路径算法：用跳数hop或者网线长度等指标来标识拓扑图中的边长</p><ul><li>可以使用数据结构基础中学过的Dijkstra算法</li></ul></li><li><p>泛洪算法：</p><ul><li>每个路由器必须根据本地的知识而不是网络的全貌做决策，一个简单的技术是泛洪，这种技术将每一个入境的数据包发送到了除了到达线路以外的每条出境线路</li><li>问题使会产生大量的重复数据包，需要用措施来抑制泛洪，一种方法是在数据包里放一个跳计数器，每跳一次减小1，如果计数器为0就丢弃这个数据包</li></ul></li><li><p>动态路由算法：距离矢量路由算法</p><ul><li>每个路由器维护一张表，表钟列出了当前已知的到每个目标的最佳距离和使用的链路，通过邻居之间相互交换信息而不断被更新，最终每个路由器都了解到了到达目标的最佳链路</li><li>每个路由器维护一张路由表，以网络中的每个路由器作为索引，并且每个路由器作为表中的一项，该表包含两个部分——到达目标路由器的<strong>首选线路</strong>和<strong>距离的估计值</strong>  </li><li>每个路由器收到了相邻路由器发来的矢量之后会更新自己的路由表</li></ul><p><img src="/2021/05/04/cn3/image-20201027113853141.png" alt="image-20201027113853141"></p></li><li><p>无穷计算问题：</p><ul><li>整个网络最佳路径的寻找过程称为收敛，距离矢量算法可以收敛到一条最短的路径，但是问题是速度太慢了</li><li>距离矢量算法对好的结果反应特别迅速，对坏消息的反应非常迟钝</li><li>某些情况下可能会让路由表的计算出现无限计算的情况，这就是无穷计数问题</li><li><strong>Poisoned Reverse染毒逆转：</strong>在基于路由信息协议的网络中，当一条路径信息变为无效之后，路由器并不立即将它从路由表中删除，而是用无穷大，即不可达的度量值将它广播出去。但是它不能完全解决无穷计数问题</li></ul></li><li><p>链路状态路由算法：每一个路由器需要完成5个步骤，算法才能正常工作</p><ul><li>发现邻居节点，并了解网络地址</li><li>设置每个邻居节点的距离或者成本度量值</li><li>构造一个包含刚才所得的信息的链路信息包</li></ul><p><img src="/2021/05/04/cn3/image-20201027120128225.png" alt="image-20201027120128225"></p><ul><li>将包发送给所有的路由器，并接受所有来自其他路由器的信息包</li><li>计算出到每个路由器的最短路径</li></ul></li><li><p>层次路由：</p><ul><li>路由器被划分成了不同的区域，每个路由器知道如何将数据包路由到自己所在的区域内的布标地址，但是对于其他区域的内部结构不知情，当不同的网络被相互连接在一起的时候，每个网络就会作为一个独立的区域，一个网络中的路由器不必直到其他网络的拓扑结构</li><li>代价是增加了路径的长度</li></ul></li><li><p>广播路由：</p><ul><li>浪费带宽，并且需要源头拥有所有目标机器的完整地址列表，不够理想但是广泛使用</li><li>多目标路由：每个数据包包含一组目标地址或者位图</li><li>逆向路径转发</li></ul></li></ul></li></ul><h3 id="5-3-IP协议"><a href="#5-3-IP协议" class="headerlink" title="5.3 IP协议"></a>5.3 IP协议</h3><ul><li><p>网际协议IP是TCP/IP体系中最重要的协议之一，用来连接计算机网络进行通信</p><ul><li>互联以后的计算机网络都是由网际协议IP因此可以看成一个虚拟互联网络，因为物理介质之间的异构性是客观存在的</li><li>而IP协议使得性能各异的网络在网络层中看起来就像上一个统一的网络</li></ul></li><li><p>为了连接不同的网络，需要一些中间设备</p><ul><li>物理层的中间设备叫做转发器repeater</li><li>数据链路层的中间设备叫做网桥或者桥接器bridge</li><li>网络层使用的中间设备叫做路由器router</li><li>网络层以上使用的中间设备叫做网关gateway，可以用来连接两个不兼容的系统，需要在高层进行协议的转换</li></ul></li><li><p>Internet的通信过程：</p><ul><li>从传输层获取数据流，并将数据流拆分成段，以便作为IP数据包发送</li><li>每个数据包理论上最大容量是64KB，但一般不超过1500bytes</li><li>IP路由器转发每个数据包穿过Internet，沿着一条路径把数据包从一个路由器转发到下一个路由器，直到数据包到达目的地。</li><li>在接受方，网络层将数据交给传输层，再由传输层交给接收进程</li></ul></li></ul><h4 id="5-3-1-IPv4协议"><a href="#5-3-1-IPv4协议" class="headerlink" title="5.3.1 IPv4协议"></a>5.3.1 IPv4协议</h4><ul><li><p>协议头</p><ul><li>每个IP数据报包含两个部分：头和正文，正文部分也叫做有效净荷</li><li>每个IPv4协议头有20个字节的定长部分和一个可选的变长部分</li></ul><p><img src="/2021/05/04/cn3/image-20201103100249466.png" alt="image-20201103100249466"></p><ul><li>组成部分<ul><li>版本字段记录了协议属于哪个版本，目前用的比较多的依然是IPv4</li><li>IHL指明了头到底有多长(以32位字长度为单位)，最小值是5表明没有可选项，最大值是15，因此可选项最多为40字节</li><li>总长度包含了数据报中所有的内容即头和数据的总长度</li><li>标识用来让目标主机确定一个新到的分段属于哪一个数据报，同一个数据报的所有段包含相同的表示值</li><li>后面还有一个空位</li><li>DF表示不分段，MF表示更多的段，除了最后一段之外所有段都必须设置MF这个位置</li><li>分段偏移量表示当前段在数据报中的位置，该字段有13位，所有段的长度必须是8的倍数，因此<strong>最多可以有8192个段</strong> </li><li>生存期是一个计数器，每一跳后计数器都会减小，减小到0的时候数据包就会被丢弃</li><li>协议表明了数据包需要被交给哪个传输进程，可能是TCP,UDP等等</li><li>头校验和用来校验和保护地址</li><li>源地址和目标地址是源网络接口和目标网络接口的IP地址</li></ul></li></ul></li></ul><h4 id="5-3-2-IP地址"><a href="#5-3-2-IP地址" class="headerlink" title="5.3.2 IP地址"></a>5.3.2 IP地址</h4><ul><li><p>IPv4协议中的IP地址是一个<strong>32位的地址</strong>，网络中的每一台主机和路由器都有一个IP地址</p><ul><li><p>IP地址是一种逻辑地址，因为是软件实现的，而物理层和数据链路层的协议用的是物理地址</p><ul><li>IP数据报一旦交给了数据链路层就被封装成MAC帧，MAC帧传送的时候使用的都是硬件地址</li></ul></li><li><p>IP地址并不真正指向一台主机，而是一个<strong>网络接口</strong>，所以如果一台主机在两个网络上，它就必须有两个IP地址，路由器有多个网络接口，所以一个路由器有多个IP地址</p></li><li><p>IP一般由网络号和主机号构成，分为ABCDE五类(这里的网络号就是下面说的前缀)</p><ul><li>A类的网络号有8位且第一位是0，B类有16位且前两位是10，C类地址的网络号有24位且前两位是110</li><li>D类地址是1110开头的多播地址，E类地址前四位1111有待开发</li></ul></li><li><p>IP地址的<strong>前缀</strong>：IP地址具有层次性，每个32位地址由高位的可变长网络号和低位的主机两部分组成，同一个网络上所有主机其地址的网络值都是相同的，这一段就是前缀</p></li><li><p>子网掩码：也标注了前缀的长度，比如128.208.101.21/24表示32位的IP地址中前缀长度是24位，后面8位是主机地址</p><ul><li>层次化的地址使得路由规模化了，但是也造成了地址的浪费</li></ul></li><li><p>子网：在内部将一个网络块分成几个部分供多个内部网络使用，但是对外部世界仍然像单个网络一样，这样的划分得到的结果就是子网</p><p><img src="/2021/05/04/cn3/image-20201103103620142.png" alt="image-20201103103620142"></p></li></ul></li><li><p>CIDR 无类域间路由(构造超网)</p><ul><li>按块分配依然解决不了路由表爆炸的问题，尤其是位于默认自由区的骨干路由器，其路由表的规模非常大</li><li>路由聚合Route Aggregation：可以运用和子网划分相同的方法，不同地点的路由器可以知道一个给定IP地址的不同大小的前缀，然而不是将一块地址分割成为若干子网，而是将<strong>多个小前缀的地址合并成一个大前缀</strong>，此时产生的大块前缀地址称为超网</li><li>有了地址聚合，IP地址可以包含大小不等的前缀，同一个IP地址，可以作为不同长度的前缀被多个路由器使用，这个设计称为无类域间路由 <code>Classless Inter-Domain Routing</code> </li></ul><p><img src="/2021/05/04/cn3/image-20201103105435313.png" alt="image-20201103105435313"></p></li><li><p>NAT 网络地址转换</p><ul><li>因为IP地址非常有限，因此可以采取动态分配IP的策略，在主机不活跃的时候回收IP地址，然后分配给别人，但是也有局限性</li><li>NAT的基本思想是给每个家庭或者公司分配一个IP地址用来传输流量，但是在客户网络的内部，每台计算机有唯一的IP地址，该地址主要用来路由内部流量，然而当一个数据包离开客户网络发送到其他的地方的时候，必须进行一个地址转换，<strong>把内部IP转换成公共IP地址</strong></li><li> 三个保留的地址范围：已经被私有化，任何网络可以内部随意使用这些地址，不允许包含这些地址的数据包出现在Internet上面</li></ul><p><img src="/2021/05/04/cn3/image-20201103112225810.png" alt="image-20201103112225810"></p><ul><li>NAT带来的问题：<ul><li>违反了IP的结构模型，即一台机器对应一个IP</li><li>NAT打破了端到端的连接模型</li><li>NAT将因特网从无连接网络变成了面向连接的网络</li><li>违反了最基本的协议分层规则</li><li>进程并不一定只有TCP和UDP</li></ul></li></ul></li></ul><h4 id="5-3-3-Internet控制协议"><a href="#5-3-3-Internet控制协议" class="headerlink" title="5.3.3 Internet控制协议"></a>5.3.3 Internet控制协议</h4><ul><li><p>ICMP 控制消息协议</p><ul><li>是路由器监视Internet的协议，当路由器处理数据包的时候发生了意外，就可以用ICMP向数据包的源端报告有关事件，所有的ICMP都被<strong>封装在一个IP数据包中</strong> </li></ul><p><img src="/2021/05/04/cn3/image-20201103114037900.png" alt="image-20201103114037900"></p></li><li><p>ARP 地址解析协议</p><ul><li>以太网网卡并不能理解IP地址，每一块NIC根据48位的以太网地址来发送和接收帧</li><li>ARP协议的作用就是将IP地址映射到以太网的地址(硬件地址)，优点是简单，比配置文件更加简单，属于网络层的协议</li><li>ARP协议解决转换问题的方法是在主机ARPcache中存放一个从IP地址到硬件地址的映射表，并进行动态更新，每一台主机上都设有一个ARP高速缓存，里面有本局域网上的各台主机和路由器的IP到硬件地址映射表</li><li>当一台主机A要向本局域网上的主机B发送IP数据报的时候就先在缓存中查看有无主机B的IP地址，如果有就在ARP高速缓存中查出其对应的硬件地址写入MAC帧然后进行发送，否则就需要再进行一系列的操作</li><li>ARP解决的是同一个局域网上的主机或者路由器IP到硬件地址的映射问题</li></ul></li><li><p>DHCP 动态主机配置协议</p><ul><li>每个网络必须有一个DHCP服务器负责地址的配置，为发送请求的主机分配一个空闲的IP地址，并通过DHCP的OFFER包返回给主机</li><li>动态分配的IP地址只能使用一段固定的时间，到期之前主机必须请求DHCP续订否则IP地址就失效了</li></ul></li><li><p>标签交换和MPLS</p><ul><li>多协议标签交换 MOLS在每个数据包前面增加一个标签，路由器根据数据包标签进行转发，用标签作为内部表的一个索引，快速查找出正确的输出线路</li><li>通用的MPLS有4个字节，并且包含四个字段，标签存放的是索引，QoS表明服务类别，S表示在层次网络中叠加多个标签的做法，TTL字段指出该数据包还可以被转发多少次，美经过一个路由器被减小1，降为0的时候数据包将被丢弃</li></ul><p><img src="/2021/05/04/cn3/image-20201103135011630.png" alt="image-20201103135011630"></p></li></ul><h3 id="5-4-Internet-路由"><a href="#5-4-Internet-路由" class="headerlink" title="5.4 Internet 路由"></a>5.4 Internet 路由</h3><ul><li><p>OSPF：内部网关路由协议</p><ul><li><p>因特网由大量的独立网络或者自治系统(AS)构成，在一个网络的内部，一个组织可以使用自己的内部路由算法，也叫做域内路由算法</p></li><li><p>开放最短路径优先 Open Shortest Path First 协议借鉴了ISIS(中间系统到中间系统)协议，已经成为了ISO的标准</p><ul><li>使用了分布式的链路状态协议(link state protocol)和最短路径算法</li><li>动态算法，支持多种距离度量</li><li>实现<strong>负载均衡</strong>，使用层次化的系统</li><li>同时支持点到点的链路和广播网络</li></ul></li><li><p>OSPF的工作方式本质上是对一张图进行操作，将一组实际网络、路由器和线路抽象到一个有向图中，两个路由器之间的点到点连接可以用两条有向的弧来表示</p><p><img src="/2021/05/04/cn3/image-20201103141528228.png" alt="image-20201103141528228"></p></li><li><p>OSPF协议做了两件事情：</p><ul><li>用一个有向图来表示实际的网络，计算出各条最短的任务</li><li>OSPF记住最短的路径集合，并在报文转发阶段把流量分摊到多条路径上，实现负载均衡，这种方法称为等价成本多路径(ECMP)</li></ul></li><li><p>OSPF可以将AS划分成若干个area，每一个都是一个网络，或者一组互连的网络，区域不能相互重叠，每个AS有一个骨干区域</p><ul><li>路由器也分为区域边界路由器和内部路由器，AS边界路由器，骨干路由器等等</li><li>AS边界路由器把通往其他AS的外部路由注入到本区域</li></ul><p><img src="/2021/05/04/cn3/image-20201103142446582.png" alt="image-20201103142446582"></p></li><li><p>OSPF协议需要在邻接的路由器之间相互交换信息才能工作，OSPF要求每个LAN中选出一台指定路由器，该指定路由器和本LAN上所有的路由器都是邻接的，并且和它们进行信息的交互</p></li><li><p>OSPF有五类消息，在邻接路由器之间进行传递：看xxr的计网教材</p><p><img src="/2021/05/04/cn3/image-20201103143538027.png" alt="image-20201103143538027"></p></li></ul></li><li><p>BGP 外部网关路由协议</p><ul><li>BGP的全称是边界网关协议 Border Gateway Protocol</li><li>在一个AS的内部推荐使用的是OSPF和ISIS协议，而在AS之间用BGP比较好，这是因为域内协议和域间协议的目标不同，域内协议所需要做的只是尽可能有效地将数据包从源端发送到接收方，而域间的路由协议则必须要考虑大量的选择策略</li><li>BGP只能力求寻找一条能够达到目的的网络且比较好的路由，采用了<strong>路径向量路由选择协议</strong> </li></ul></li><li><p>Internet 组播</p><ul><li>普通的IP通信发生在一个发送方和一个接收方之间，而IP用D类IP地址来支持<strong>一对多的通信</strong>或者组播，每个D类地址标识了一组主机  </li><li>Internet 组管理协议 IGMP用来解决广播成员分布在不同网络上的情况</li><li>在AS中主要是使用协议独立组播协议PIM，在系数模式PIM中，使用特定源组播PIM可用来优化只有一个发送方的情况，当成员分布不知一个AS的时候，需要BGP的组播扩展来创建组播路由                        </li></ul></li></ul><h3 id="5-5-拥塞控制"><a href="#5-5-拥塞控制" class="headerlink" title="5.5 拥塞控制"></a>5.5 拥塞控制</h3><ul><li>拥塞：网络中存在太多的数据包导致数据包被延迟传输和丢失，导致网络的性能下降<ul><li>控制拥塞是网络层和传输层共同承担的责任</li><li>因为拥塞是出现在网络中的，但又是由于传输层发送出太多的数据包儿导师网络的过载，因此需要网络层和传输层共同承担责任</li><li>根据拥塞发生的原因，可以将解决方案分为：增加资源或者减少负载</li></ul></li><li>准入控制：在虚电路网络中，如果太拥堵了就拒绝建立新的连接</li><li>流量感知路由：了解到网络流量之后定制路由</li><li>负载脱落：一切努力都失败了，不得不丢弃一些数据包</li></ul><h3 id="5-6-服务质量"><a href="#5-6-服务质量" class="headerlink" title="5.6 服务质量"></a>5.6 服务质量</h3><ul><li>评价标准：可靠性、延迟、抖动(jitter)、带宽。抖动是延迟的方差，也代表了到达时间的变化</li></ul><p>隧道技术</p><h3 id="5-7-IPv6标准"><a href="#5-7-IPv6标准" class="headerlink" title="5.7 IPv6标准"></a>5.7 IPv6标准</h3><ul><li>IPv6依然是无连接的，并且分为头部和有效载荷，IPv6的地址变成了128位，采用冒号十六进制记法，每个16位的值用十六进制来表示，并用冒号来分隔<ul><li>比如FF05:0:0:0:0:0:0:B3是一个冒号十六进制写法的IPv6地址<ul><li>零压缩：连续的一串0可以用两个冒号代替，一个IP地址只能使用一次</li></ul></li></ul></li></ul><h2 id="Chapter-6：Transmission-Layer"><a href="#Chapter-6：Transmission-Layer" class="headerlink" title="Chapter 6：Transmission Layer"></a>Chapter 6：Transmission Layer</h2><h3 id="6-1-运输层的作用"><a href="#6-1-运输层的作用" class="headerlink" title="6.1 运输层的作用"></a>6.1 运输层的作用</h3><ul><li>运输层向上面的应用层提供通信服务，是用户功能中的最底层，也属于面向通信部分的最高层<ul><li>通信的真正端点并不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信</li><li>运输层的重要功能是复用和分用<ul><li>复用是指发送方不同的进程都可以用同一个传输层协议传输数据</li><li>分用是接收方的运输层在处理报文之后可以把数据交付给正确的进程</li><li>也就是说运输层提供了运输层之间的逻辑通信，而网络层是为主机提供了逻辑通信</li></ul></li><li>运输层的两个重要的运输协议是面向连接的TCP和无连接的UDP</li></ul></li></ul><h3 id="6-2-运输层的协议"><a href="#6-2-运输层的协议" class="headerlink" title="6.2 运输层的协议"></a>6.2 运输层的协议</h3><ul><li>TCP和UDP协议<ul><li>UDP的全称是用户数据报协议，TCP的全称是传输控制协议</li><li>两个peer在通信时候传送的数据单位叫做运输协议数据单元 TPDU，但是在TCP/IP体系中，TCP传输的被称为TCP报文段，UDP传输的被称为UDP用户数据报</li><li>TCP提供的是面向连接的服务，在传输之前必须先建立连接，传输结束之后需要释放连接，并且不提供多播和广播的服务，SMTP、HTTP、FTP等应用层协议用的是TCP</li><li>UDP则是无连接的协议，远程的主机的运输层在收到UDP之后，不需要给出任何的确认</li></ul></li><li>端口：<ul><li>传输层的端口指的是软件端口，指的是应用层的各种协议进程和运输实体层之间进行交互的一种地址</li><li>TCP/IP的运输层用16位的端口号，最多支持65535个不同的端口，这里的端口号是一种虚拟端口</li><li>也叫做传输服务访问点TSAP</li><li>已经分配的一些端口号：<ul><li>20/21 FTP</li><li>22 SSH</li><li>25 STMP</li></ul></li></ul></li><li>协议的要素：<ul><li>寻址：建立通信的时候指定连接到哪个应用进程上面，用一个端口映射器的进程来处理端口和服务的映射关系</li><li>连接建立：拥有建立连接的一套算法，最常见的就是<strong>三次握手</strong></li><li>连接的释放：非对称释放和对称释放，非对称释放类似于挂电话，对称释放是两段建立的连接都释放</li><li>差错控制和流量控制：使用动态缓冲区，对于低带宽的突发流量可以不设置缓冲区，对于文件传输和高带宽流量需要使用缓冲区</li><li>多路复用：到达的数据报段必须用某种方式告知把它交给哪个进程处理。“逆向多路复用”</li><li>崩溃恢复：在路由器或者主机崩溃的时候重新发送</li></ul></li></ul><h3 id="6-3-用户数据报协议-UDP"><a href="#6-3-用户数据报协议-UDP" class="headerlink" title="6.3 用户数据报协议 UDP"></a>6.3 用户数据报协议 UDP</h3><ul><li>用户数据报协议UDP只在IP协议上面增加了复用和分用的功能，其主要特点是：<ul><li>无连接，即发送数据不需要建立连接，减小了开销和延迟</li><li>尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态</li><li>面向报文：一次交付一个报文，对应用层的报文既不合并也不拆分，而是保留这些报文的边界</li><li>没有拥塞控制，因此网络中出现的拥塞不会导致主机的发送速率降低，允许拥塞时候丢数据但是不允许数据有太大的延迟<ul><li>可能会引发网络的严重拥堵</li></ul></li><li>支持一对一、一对多、多对多的交互通信</li><li>header开销小，只有8个字节</li></ul></li></ul><h3 id="6-4-应用"><a href="#6-4-应用" class="headerlink" title="6.4 应用"></a>6.4 应用</h3><ul><li>实时传输<ul><li>实时传输协议RTP</li><li>实时传输控制协议RTCP</li><li>防抖动和缓冲的播放</li></ul></li></ul><h3 id="6-4-传输控制协议TCP与socket"><a href="#6-4-传输控制协议TCP与socket" class="headerlink" title="6.4 传输控制协议TCP与socket"></a>6.4 传输控制协议TCP与socket</h3><ul><li><p>TCP是一个非常复杂的传输层协议，其特点是：</p><ul><li>面向连接：使用之前必须建立连接，使用完之后必须释放</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的</li><li>可靠交付，用TCP协议传输的数据无差错、不丢失、不重复并且按顺序到达</li><li>提供全双工通信，用缓存来存放双向通信的数据</li><li>面向字节流：将应用层传下来的数据看成无结构的数据流</li></ul></li><li><p>TCP的连接：</p><ul><li>连接是TCP最基本的抽象，每条TCP的连接都有两个端点，成为socket(套接字)</li><li>IP地址+端口号就可以构成一个socket，每条TCP连接由两个socket来确定，一个IP地址可以有多个套接字</li><li>berkerley socket是在操作系统内核中实现的socket封装库，提供如下操作</li></ul><img src="image-20201112144634224.png" alt="image-20201112144634224" style="zoom: 50%;" /></li><li><p>TCP段的头</p><ul><li>TCP每个段的起始部分是固定格式的20字节的头部，而IP头也有20个字节，因此数据段的最大长度是65535-20-20=65495</li><li>源端口和目标端口字段表示了连接的本地端点，各占2字节，TCP端口+IP头中的IP地址组成了48位的唯一端点</li><li>序号和确认好都是4字节，确认号制定的是下一个期待的字节，而不是已经正确接收到的最后1字节</li><li>TCP的头长度表明了TCP头包含<strong>几个32位的字</strong>，因为后面的选项option是变长的，实际上指明了数据段的起始地址，接着有四位空位</li><li>8个1bit的标志位，有CWR、ECE、URG、ACK、PSH、RST、SYN、FIN</li><li>窗口大小、校验和、紧急指针的长度都是1字节<ul><li>窗口大小指定了滑动窗口的大小，表明从被确认的字节算起可以发送多少个字节，可以是0</li><li>选项字段提供了一种添加额外设施的途径，主要针对常规头覆盖不到的方面，长度必须是32的倍数</li></ul></li></ul></li><li><p>TCP连接的建立：三次握手，即发送请求、收到确认、确认收到确认三个步骤</p></li><li><p>TCP的滑动窗口</p><ul><li>TCP协议的窗口管理方式是将正确接收段和确认和接受段的接受缓冲区分配分开的</li><li>当窗口变成0的时候，发送端不能像往常一样发送数据段了，有两种处理办法：一种是杀死进程来存储紧急的数据，或者发送窗口探测的长度为1字节的段，以便强制接受段重新宣告下一个期望的字节的窗口大小，可以放置窗口更新之后死锁</li></ul></li><li><p>TCP的拥塞控制</p><ul><li>TCP维持了一个拥塞窗口，窗口的大小是任何时候发送端可以往网络中发送的字节数，相应的速率则是窗口大小/连接的往返时间，TCP根据AIMD规则来调整窗口的大小</li><li>东西太多了，讲不完，回去看xxr教材</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层，数据链路层与MAC子层</title>
      <link href="2021/05/04/cn2/"/>
      <url>2021/05/04/cn2/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter2-Physics-Layer"><a href="#Chapter2-Physics-Layer" class="headerlink" title="Chapter2.  Physics Layer"></a>Chapter2.  Physics Layer</h2><h3 id="2-0-物理层的基本概念"><a href="#2-0-物理层的基本概念" class="headerlink" title="2.0 物理层的基本概念"></a>2.0 物理层的基本概念</h3><ul><li>物理层存在的意义正是要尽可能地屏蔽不同的传输媒体和通信手段之间的差异，使得物理层上面的数据链路层感受不到这些差异<ul><li>物理层的协议也常常称为规程 procedure，这个词比协议要出现的早</li></ul></li><li>一个数据通信系统分为如下几个部分<ul><li>源系统，也叫发送端和发送方：包含源点和发送器</li><li>传输系统，也叫传输网络</li><li>目的系统，也叫接收端，包含接收器和重点</li></ul></li></ul><h3 id="2-1-有线通信和无线通信"><a href="#2-1-有线通信和无线通信" class="headerlink" title="2.1 有线通信和无线通信"></a>2.1 有线通信和无线通信</h3><ul><li>物理层用到的几种线<ul><li>双绞线 Twisted Pair</li><li>同轴电缆</li><li>光缆 Fiber Cables<ul><li>利用了光的全反射原理，在特定入射角度下不会发生折射</li></ul></li></ul></li><li>接口线 Interface Line</li><li>无线通信：<ul><li>卫星通信</li><li>微波通信：常见于移动通讯，微波会穿过遮挡物继续传播，但可能会被吸收</li></ul></li><li>物理层要做的就是把计算机中的电信号转化成上面这些可以传播的信号<ul><li>信号 signal是数据的电气或者电磁表现，分为模拟信号和数字信号<ul><li>模拟信号也叫连续信号，代表消息的参数的取值是连续的</li><li>数字信号也叫离散信号，代表消息的参数取值是离散的，比如计算机和解调器的通信就是数字信号</li></ul></li><li>信号分为数字信号和模拟信号，比如：<ul><li>电话是将模拟信号转换成模拟信号</li><li>Modem是模拟信号转换成数字信号</li><li>Codec是把数字信号转换成模拟信号</li></ul></li></ul></li></ul><h3 id="2-2-信道channel和传输-Transmission"><a href="#2-2-信道channel和传输-Transmission" class="headerlink" title="2.2 信道channel和传输 Transmission"></a>2.2 信道channel和传输 Transmission</h3><ul><li><p>信道：表示向某一方向传送信息的媒体</p><ul><li>信道和电路的概念不相同，电路往往包含了发送信道和接受信道各一条</li><li>信道的通信方式也分为单向通信、双向交替通信和双向同时通信</li></ul></li><li><p>基带传输 Baseband Transmission 信号分为0和1，分为若干种传输方式：</p><ul><li>Non-return to zero 用高频代表1，低频信号代表0<ul><li>存在时钟恢复问题，应该从中间处采样</li></ul></li><li>NRZ Invert 在发生10切换的时候信号突变，高低电平进行切换<ul><li>被USB使用</li></ul></li><li>Manchester 曼切斯特编码：传输1是半个高信号+半个低信号，传输0是半个低信号+半个高信号<ul><li>被Ethernet 以太网使用</li></ul></li></ul><img src="image-20200929115121369.png" alt="image-20200929115121369" style="zoom:50%;" /><ul><li><p>二级编码：AMI</p></li><li><p>4B/5B编码：每四位一组，按照规则扩展成32位，共有32种组合，其余的16种作为控制码</p></li><li><p>宽带传输和基带传输的<strong>区别</strong>：</p><ul><li>宽带传输是把基带信号调制之后形成频分复用模拟信号，在模拟信道上传输</li><li>调制是将数字01转换为信号的过程</li></ul></li></ul></li><li><p>通带传输 Passband Transmission</p><ul><li>调制的三种方法：调幅Amplitude shift keying，调频 Frequency shift keying，调相 Phase shift keying</li><li>调幅是用多个振幅来表示一个信号——调节振幅</li><li>调频是用多个频率来表示信号——调节频率</li><li>调相是用多个相位来表示信号——调节相位</li><li>QPSK 正交<strong>相移键控</strong>(调相的全名) 用45°，135°，225°和315°的四个偏移</li></ul></li><li><p>信道的<strong>最大数据传输速率</strong>：</p><ul><li>Nyquist定理：带宽为W，则<strong>信号传输速率</strong>不超过2W<ul><li>对于一个信道，并且没有噪声的情况下才适用</li><li>W的单位是赫兹，表示每秒信号变化次数</li></ul></li><li>Bilevel 编码：数据传输速率 = 2倍的带宽，单位是bps</li><li>多进制编码：数据传输速度 =  $2W\log_2M$ 其中M是进制，结果的单位是bps<ul><li>没有理论值的上限，但是会产生损失</li></ul></li></ul></li><li><p>香农定理 Shannon’s Theorem</p><ul><li>带宽是H(HZ)，信噪比是S/N，信噪比的计量单位是dB</li><li>最大的数据传输速率是：$H\log _2(1+\frac SN)$ <ul><li>也就是说信噪比越大，最大的可能传输速率就越高</li></ul></li><li>信噪比的计算公式：$信噪比=10\log_{10}(\frac SN)$  </li></ul></li></ul><h3 id="2-3-公共电话系统-PSTN"><a href="#2-3-公共电话系统-PSTN" class="headerlink" title="2.3 公共电话系统 PSTN"></a>2.3 公共电话系统 PSTN</h3><ul><li><p>PSTN用于传输人声，但是更加难以辨别，结构如下图所示：</p><img src="image-20200929115442909.png" alt="image-20200929115442909" style="zoom: 67%;" /><ul><li>主要组成部分：<ul><li>本地回路：传输模拟信号的双绞线</li><li>干线 Trunk：数字光缆，连接了各个交换局</li><li>交换局 Switching office：进行通话的交换，从手动切换变成了计算机切换</li></ul></li><li>模拟信号在end office通过设备使用codec进行数字化<ul><li>每秒采样8000次，每次采样量化成8bit的二进制数，这项技术叫做PCM脉冲编码调制</li><li>T1信道有24个PCM信号，数据传输速率是<strong>1.544Mbps</strong> </li><li>E1信道有32个PCM信号，数据传输速率是<strong>2.048Mbps</strong> </li></ul></li></ul><img src="image-20200929200113363.png" alt="image-20200929200113363" style="zoom:50%;" /><ul><li>信道的<strong>开销cost</strong>：<ul><li>T1信道每一帧传输的193bit中，有7*24=168bit是有效信息，有25bit是开销，因此开销率是25/193=13%</li><li>E1信道的32个信道中30个传输数据，2个传输信号，因此开销是2/32=6.25%</li></ul></li></ul></li></ul><h3 id="2-4-信道复用"><a href="#2-4-信道复用" class="headerlink" title="2.4 信道复用"></a>2.4 信道复用</h3><h4 id="2-4-1-频分复用-FDM-Frequency-Division-Multiplexing"><a href="#2-4-1-频分复用-FDM-Frequency-Division-Multiplexing" class="headerlink" title="2.4.1 频分复用(FDM, Frequency Division Multiplexing)"></a>2.4.1 频分复用(FDM, Frequency Division Multiplexing)</h4><ul><li><p>利用通带传输的优势使得多个用户共享信道，每个用户拥有一个自己的频段来发射自己的信号</p><img src="image-20200929193200257.png" alt="image-20200929193200257" style="zoom:50%;" /><ul><li>OFDM 正交分频复用</li></ul></li></ul><h4 id="2-5-2-时分复用-TDM"><a href="#2-5-2-时分复用-TDM" class="headerlink" title="2.5.2 时分复用 TDM"></a>2.5.2 时分复用 TDM</h4><ul><li><p>每个用户周期性地获取整个带宽非常短的一个时间段，每个输入流中的bit从一个固定的时间槽中取出，并输出到混合流中</p><ul><li>TDM被广泛应用在电话网络和蜂窝网络中</li></ul><img src="image-20200929194404181.png" alt="image-20200929194404181" style="zoom:50%;" /></li></ul><h4 id="2-5-3-码分复用-CDM"><a href="#2-5-3-码分复用-CDM" class="headerlink" title="2.5.3 码分复用 CDM"></a>2.5.3 码分复用 CDM</h4><ul><li>码分多址 CDMA：在CDMA中，每个bit时间被分为m个更短的时间间隔，称为码片chip<ul><li>如果要传输一个1就发送分配的码片序列，如果要传输0就发送码片序列的反码</li><li>发送站的任意两个chip都正交，也就是归一化的内积为0</li></ul></li></ul><img src="image-20200929195813292.png" alt="image-20200929195813292" style="zoom:50%;" /><h3 id="2-6-习题"><a href="#2-6-习题" class="headerlink" title="2.6 习题"></a>2.6 习题</h3><ul><li><p> If a binary signal is sent over a 15-kHz channel whose signal-to-noise ratio is 15 dB, what is the maximum achievable data rate?</p></li><li><p>首先需要根据信噪比的分贝数算出S/N，再算出香农定理下的最大传输速率，但是要注意另一种算法下的最大传输速率是30，因此取比较小的应该是30</p></li><li><p>14 signals, each requiring 5000 Hz, are multiplexed on to a single channel using FDM. How much minimum bandwidth is required for the multiplexed channel? Assume that the guard bands are 200 Hz wide.</p><ul><li>n个信号，每个所需要的宽度是x，guard band是y，则一共需要的带宽是nx+(n-1)y HZ</li></ul></li><li><p>A simple telephone system consists of two end offices and a single toll office to which each end office is connected by a 1-MHz full-duplex trunk. The average telephone is used to make four calls per 8-hour workday. The mean call duration is 6 min. Ten percent of the calls are long-distance (i.e., pass through the toll office). What is the maximum number of telephones an end office can support? (Assume 4 kHz per circuit.)</p><ul><li>每天工作8小时，平均一台电话机要打4个电话，每个电话6min，一共是24min所以每小时只需要3min，因此可以一次支持20台远程通话，又因为只有10%是远程通话，所以一个信道可以支持200台</li><li>1MHZ的干线，每个信道的带宽是4KHZ，一共有250个，因此答案是50000个</li></ul><h2 id="Chapter3-Data-link-layer"><a href="#Chapter3-Data-link-layer" class="headerlink" title="Chapter3. Data link layer"></a>Chapter3. Data link layer</h2></li></ul><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><ul><li><p>数据链路层：构建数据链路和逻辑链路，区别于物理层，物理层构建的是物理链路</p><ul><li><strong>物理层和数据链路层</strong>的本质作用都是用来构建网络通信、访问通道</li><li>物理链路是真实存在的物理线路和设备，数据链路层是一些必要的硬件(比如网络适配器)和软件(传输协议)组成的</li><li>数据链路层向上提供网络层的服务，处理传输的错误(因为物理层不能发现传输错误)，调节数据流，确保接收方不会被淹没</li><li>提供的一些服务：<ul><li>无确认，无连接的服务：对丢失的帧不负责重发而是交给上一层处理，适用于实时通信或者误码率低的信道，比如以太网</li><li>有确认的，无连接的服务，比如无线通信</li><li>有确认的，面向连接的服务：帧的传输需要建立数据链路、传输帧、释放数据链路，适用于长距离的不可靠链路</li><li>提供“虚拟的交流”：实际上就是通过协议和查错，避免需要通过物理层的通信产生的差错，就好像绕过了物理层一样</li></ul><img src="image-20201014114245291.png" alt="image-20201014114245291" style="zoom:67%;" /> </li></ul></li><li><p>Frame和Framing 帧：是数据链路层<strong>发送数据的单位</strong> </p><ul><li><p>Packet和Frame的关系</p><img src="image-20201014113939446.png" alt="image-20201014113939446" style="zoom:67%; " align="center"/></li><li><p>具有一定的特殊格式：</p><ul><li><p>character count 不常用的方法，很容易出错，一个错了后面的就都错了</p></li><li><p>字节填充法：开始和结束使用特定的字符，用STX和ETX分别表示帧的开始和结束，DLE可以用来表示转义字符</p><ul><li>DLE+STX表示需要把STX进行转义，不代表帧开始的符号，DLE+DLE表示把第二个DLE进行转义</li></ul></li><li><p>比特填充法：通过在帧头和帧尾各插入一个特定的比特串（如 01111110) 来标识-一个数据帧的起始与结束</p><ul><li>为了保证传输的内容不被错误解析，可以在传输的数据中每出现连续的5个1就在后面添加一个0，这样就不会出现连续的6个1，就算后面有0也要加一个0</li></ul><img src="image-20201013102809850.png" alt="image-20201013102809850" style="zoom:67%;" /></li></ul></li></ul></li></ul><h3 id="3-2-数据链路层的错误检测"><a href="#3-2-数据链路层的错误检测" class="headerlink" title="3.2 数据链路层的错误检测"></a>3.2 数据链路层的错误检测</h3><ul><li><p>错误控制的方式</p><ul><li><code>error correcting</code> 纠错功能</li><li><code>error detecting with retransmission</code> 错误检测和重发</li></ul></li><li><h3 id="纠错码-Error-correcting-code"><a href="#纠错码-Error-correcting-code" class="headerlink" title="纠错码 Error correcting code"></a>纠错码 Error correcting code</h3><ul><li><p>假设一帧由 $m$ 个数据位和 $r$ 个冗余位组成，记 $n=m+r$， 并将该编码描述成$(m,n)$码</p></li><li><p>海明码：设置一系列校验码和校验位</p><ul><li>海明距离：两个码字(codeword)中不同的位的个数，如果两个码字的海明距离为 $d$ ，则需要 $d$ 个1位错误才能把一个码字转换成另一个码字<ul><li>也就是一个码字中最多可能错误的位数</li></ul></li><li>纠错能力：<ul><li>为了检测d个错误，就需要d+1的海明距离的编码方案，其实也就是说海明距离为n的编码方案只能检测出n-1个错误</li><li>为了纠正d个错误，需要2d+1的海明编码方案</li></ul></li></ul></li><li><p>对于每$2^m$个合法消息，任何一个消息都有n个非法码字，即海明距离为1的非法码字有n个，因此每个合法消息都需要用n+1位来标识，由于总共有$2^n$种位模式，也就是$(n+1)\le 2^r$ </p><ul><li>用2的幂次的位置作为校验码，其他位置依次放数据</li></ul></li><li><p>海明码的海明距离为3，可以发现2bit的错误，可以纠正1bit的错误，将码字内的位编号为1到n，其中是2的幂次的位就是校验码，其余的都是数据码</p></li></ul></li><li><p><strong>循环冗余校验 Cyclic Redundancy Check</strong>  </p><ul><li>基本思路：并在数据帧的末尾添加若干位作为校验码，<strong>要使所生成的新帧能与</strong>发送端和接收端<strong>共同选定的某个特定数整除</strong> <ul><li><p>约定一个生成多项式$G(x)$ 需要首位和末尾的系数都是1</p><ul><li>所选定的除数二进制位数（假设为 k 位），然后在要发送的数据帧（假设为 m 位）后面加上 k- 1 位0，接着以这个加了 k-1 个0的新帧（一共是 m+k-1 位）<strong>除</strong>以上面这个除数</li></ul></li><li><p>所得到的余数（也是二进制的比特串）就是该帧的 CRC 校验码，又称 FCS（帧校验序列）</p><ul><li>但要注意的是，余数的位数比除数位数只能少一位，不能省略0</li></ul></li><li><p>还要注意这里的除法是特殊的计算方式，除法中用到的减法是异或XOR，也就是不会借位</p></li></ul><img src="image-20201013111047773.png" alt="image-20201013111047773" style="zoom: 50%;" /><ul><li>再把这个余数附加在原数据帧的末尾(覆盖之前的0)，构建一个新的帧发送到接收端</li><li>在接收端除以第二步中的除数，如果没有余数就说明没有差错</li></ul></li></ul></li></ul><h3 id="3-3-数据链路层的协议"><a href="#3-3-数据链路层的协议" class="headerlink" title="3.3 数据链路层的协议"></a>3.3 数据链路层的协议</h3><ul><li><p>停止-等待协议 <code>Stop-and-Wait Protocol</code></p><ul><li>最简单的通信协议</li></ul><img src="image-20201013112052219.png" alt="image-20201013112052219" style="zoom: 67%;" /><ul><li>基本思路：每次发送完毕，停止，等到接收方收到**表示发送成功的数据包(ACK)**之后再进行下一次的发送<ul><li>如果收到了NAK包，表示不确认，此时需要发送方重新发送一次数据包</li><li>如果产生了数据丢失，就会Time Out，即发送方迟迟等不到接收方的回复，就会尝试<strong>主动重发</strong> </li><li>如果产生了ACK丢失，也会导致发送方重发，这时就会丢弃收到的数据，并再发送一个ACK提醒发送方已经收到</li></ul></li><li>对发送的数据包的标记方式可以只用1个bit来标记，01交替表示换了个新的数据包</li><li>效率的衡量<ul><li>$T_{frame}$ 表示发送方<strong>发出去完整的一个帧</strong>需要的时间，$T_{prop}$ 表示传输到接收方需要的时间<ul><li>$T_{prop}=\frac{distance}{\mathcal {speed}}$ 而且 $T_{frame}=\frac{frame_size}{bit_rate}$ </li><li>令$\alpha = \frac{T_{prop}}{T_{frame}}$ 则链路利用率 $U=\frac 1 {2\alpha +1}$ </li></ul></li></ul></li><li>停止等待协议的编程实现——重要的数据结构</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAX_PKT 1024typedef unsigned int seq_nr;typedef struct packet &#123;    unsigned char data[MAX_PKT];&#125;;typedef enum &#123;data, ack, nak&#125; frame_kind;typedef struct &#123;    frame_kind kind;    seq_nr seq, ack;    packet info;&#125; frame;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>滑动窗口协议 <code>Sliding Window Protocols</code></p><ul><li><p>窗口就是一系列用于收发数据的<strong>序列号的集合</strong> </p><ul><li><p>发送方维持一组连续的允许发送帧的窗口，称为发送窗口</p><ul><li>发送方每次收到一个ACK就把窗口移动一个位置</li></ul></li><li><p>某些协议中的发送窗口</p></li></ul></li><li><p>接收方维持一组连续的允许接收帧的窗口，称为接收窗口</p><ul><li>接收端收到一个数据帧之后就把接收窗口移动一格，并发回确认帧ACK，落在接收窗口之外的数据帧一律丢弃</li><li>当发生错误时，丢弃错误帧后所有的帧，不发回确认，要求发送方重传开始错误之后的帧</li></ul></li><li><p>滑动窗口协议的利用率$U=\min (\frac{N}{2\alpha +1}, 1)$ 但是仅存理论可能</p></li><li><p>几种不同的<strong>重新发送</strong>的协议</p><ul><li><p>Go-Back-N </p><ul><li>回退到第一个出问题的窗口，对后面的所有内容都进行重新发送，因此接收端也必须丢弃所有相应的数据包</li></ul></li><li><p>发送方窗口大小不超过 <code>MAX_SEQ</code>，即<strong>最大的序列号</strong> </p><ul><li><p>接收方的窗口大小为1</p></li><li><p>问题在于网络情况不好的时候会进一步恶化网络状况</p></li></ul></li><li><p>Selective Repeat Protocol 选择重复协议</p><img src="image-20201013114512808.png" alt="image-20201013114512808" style="zoom: 50%;" /><ul><li>在滑动窗口的基础上，不需要发送丢失之后的所有数据帧，只需要发送缺少的数据帧就可以</li><li>为了保证没有序号重叠，窗口的最大尺寸不应该超过序号空间的一半，即(MAX_SEQ+1)/2<ul><li>接收方和发送方的窗口size一样，接收方的缓冲区=窗口的size</li></ul></li><li>相比于GO-Back-N需要更大的缓冲区</li></ul></li></ul></li></ul></li><li><p>PPP协议(Point to Point Protocol) </p><ul><li><p>用于在链路中发送数据包的协议，包含光纤链路和ADSL</p></li><li><p>是一个点对点的协议，需要提供身份验证，会动态分配IP地址，具有简单的差错功能，包含了链路控制协议LCP和网络控制协议NCP</p><ul><li>链路控制协议会激活数据链路，并进行测试，当不需要的时候再关闭</li></ul></li><li><p>有若干种状态</p><p>​    <img src="image-20201019123822959.png" alt="image-20201019123822959" style="zoom: 80%;" /></p></li></ul></li></ul><h3 id="3-4-HDLC帧格式"><a href="#3-4-HDLC帧格式" class="headerlink" title="3.4 HDLC帧格式"></a>3.4 HDLC帧格式</h3><ul><li>起始和结束都是8bit的01111110+8bit address + 8bit control + 若干位data + 16位checksum <ul><li>不同类型的帧的控制位数不一样</li><li>对于信息帧而言，8bit = 1bit 0 + 3bit seq序号 + 1bit P/F + 3bit next序号</li><li>监督帧：10+2bit type + P/F + 3bit next</li><li>无符号帧： 11+2bit type + P/F + 3bit modifier</li></ul></li></ul><img src="image-20201019123740549.png" alt="image-20201019123740549" style="zoom:67%;" /><h2 id="Chapter4：Medium-Access-Sublayer"><a href="#Chapter4：Medium-Access-Sublayer" class="headerlink" title="Chapter4：Medium Access Sublayer"></a>Chapter4：Medium Access Sublayer</h2><ul><li>中译名：介质<strong>访问控制</strong>子层</li></ul><h3 id="4-1-回忆"><a href="#4-1-回忆" class="headerlink" title="4.1 回忆"></a>4.1 回忆</h3><ul><li>数据链路的两种类型：<ul><li>P2P的连接</li><li>使用广播信道进行连接<ul><li>多路访问信道 Multiaccess Channel</li><li>随机访问信道 Random Access Channel</li></ul></li></ul></li><li>介质访问控制子层 Medium Access Control(MAC)<ul><li>用于确定多路访问信道中下一个使用者的协议</li></ul></li></ul><h3 id="4-2-信道分配协议"><a href="#4-2-信道分配协议" class="headerlink" title="4.2 信道分配协议"></a>4.2 信道分配协议</h3><ul><li>信道分配的方式：<ul><li>静态分配：比如物理层中介绍的频分复用，波分复用，码分复用等等<ul><li>在用户少，信道充足的情况下简单高效</li><li>单个信道的帧平均延迟时间：K是帧的到达速率，$\frac{1}{\lambda}$是帧的长度，C表示信道的总数，则$T=\frac{1}{\lambda C-K}$，在频分复用的时候时间延迟变成NT，其中N是子信道的个数</li></ul></li><li>动态信道分配：又叫多点接入，特点是信道并非在用户通信的时候固定分配给用户<ul><li>5个基本的假设：<ul><li>流量独立：帧的传输是独立的，一旦生成了一帧，这个站就会被阻塞，直到帧被成功发送出去</li><li>单信道假设：所有站点使用一个信道</li><li>帧的发送冲突可以被观察到</li><li>发送的时间是连续的或者有间隔的发送</li><li>载体感知或者无载体感知：站点在发送之前可以知道信道是否在使用</li></ul></li><li>多路传输协议：ALOHA，CSMA等等</li></ul></li></ul></li></ul><h4 id="4-2-1-竞争性的协议"><a href="#4-2-1-竞争性的协议" class="headerlink" title="4.2.1 竞争性的协议"></a>4.2.1 竞争性的协议</h4><ul><li>ALOHA协议<ul><li>Pure ALOHA：有需要的时候就可以发送帧，不需要全局时间的同步<ul><li>协议的效率 $S=Ge^{-2G}$ 其中G表示每个帧发送所需的时间内new和resend的帧的数量，一个帧时间内希望有G帧，但是生成K帧的概率服从泊松分布</li><li>协议最高的效率大约是：18.4%——因为所有的站点都可以随机发送，因此冲突非常多</li></ul></li><li>Slotted分槽ALOHA：将时间分成离散的间隔，用户遵守统一的时间槽边界，效率是$S=Ge^{-G}$ </li></ul></li><li>CSMA协议(Carrier Sense Multiple Access Protocol)<ul><li>特点：在发送数据之前一直监听信道，如果冲突了就等待一段随机的时间之后再试一次</li><li>分为多种情况：<ul><li>1-persistant CSMA：<ul><li>先监听，一有空闲时间就发送，如果信道繁忙就持续监听</li><li>如果发生冲突就等待一段随机的时间，如果带宽延迟乘积大，协议的性能就差</li></ul></li><li>non-persistant CSMA：<ul><li>如果信道正在使用则不持续监听，改成随即等待，冲突就随即等一段时间</li><li>信道的利用率高但是延迟大</li></ul></li><li>p-persistant CSMA：<ul><li>持续监听信道，如果空闲就以一定的概率p发送数据，否则推迟到下一个时间槽，如果信道繁忙就持续监听</li><li>IEEE 802.11使用优化后的p-CSMA</li></ul></li><li>有冲突检测的CSMA(CSMA/CD)<ul><li>假设两个站点之间传播所需的最长时间是t那么只有一个站的传输时间大于2t才能被检测到冲突</li></ul></li></ul></li></ul></li></ul><h4 id="4-2-2-非竞争和有限竞争"><a href="#4-2-2-非竞争和有限竞争" class="headerlink" title="4.2.2 非竞争和有限竞争"></a>4.2.2 非竞争和有限竞争</h4><ul><li>无冲突协议 CFP<ul><li><strong>基本位图法</strong>：竞争槽中表示哪个station需要传输，假设数据的传输所需的时间长度为d，每个竞争期包含的槽的个数是N<ul><li>在低负载的情况下，低序号的站发送的平均等待时间是1.5N，高序号的站的平均等待时间是0.5N，对所有站而言平均等待时间是N，即每一帧的额外开销是N位，因此低负载的情况下信道的利用率是$\frac{d}{N+d}$ </li><li>在高负载的情况下，N个竞争位被分到了N个帧上面，此时利用率是$\frac{d}{1+d}$ </li></ul></li><li><strong>令牌传递</strong> token passing<ul><li>令牌环：用于向下一个站点发送令牌</li><li>令牌总线：利用总线发送帧</li></ul></li><li><strong>二进制计数</strong> Binary CountDown<ul><li>高序站的优先级比较高，利用率是$\frac d {d+\log_2 N}$ </li></ul></li></ul></li><li>有限竞争协议：<ul><li>低负载的时候使用竞争协议降低延迟，高负载的时候采用无冲突的方法提高信道效率</li><li>自适应树遍历协议：二叉树中的节点表示各个站点，当节点冲突的时候，左子树下面的节点才有竞争权</li></ul></li></ul><h4 id="4-2-3-WLAN协议"><a href="#4-2-3-WLAN协议" class="headerlink" title="4.2.3 WLAN协议"></a>4.2.3 WLAN协议</h4><ul><li><p>WLAN的特点</p><ul><li>无线通信系统通常不能检测出正在发生的冲突，站点接收到的信号可能非常微弱</li><li>WLAN的站点可能无法给所有其他的站发送帧，也可能无法接受来自所有来自其他站的帧</li></ul></li><li><p>一个简单的想法是使用CSMA：每个站点监听是否有其他的站点在传输，并且只有当没有其他站在传送数据的时候才进行传输，问题在于这种方法没有考虑WLAN的特性，如下图所示：</p><p><img src="/2021/05/04/cn2/image-20201020230440351.png" alt="image-20201020230440351"></p><ul><li>当A发送给B的时候，C在监听，但是监听不到A，因为在距离之外，因此错误地认为C可以向B发送数据，因此B处就造成了混乱，扰乱了A发送过来的数据帧</li><li>因此我们需要一个MAC协议防止此类冲突的发生</li><li>冲突将导致宽带的浪费，由于竞争者离得太远而导致站点无法检测到潜在的竞争者，这个问题被称为<strong>隐藏终端问题</strong>(<code>hidden station problem</code>)</li></ul></li><li><p>MACA 冲突避免多路访问协议</p><ul><li>基本思路是发送方刺激接收方输出一个短的数据帧，以便其在附近可以接收到，同时避免接下去进行的数据帧传输也需要发送数据</li><li>RTS(Request to Send)：30字节，包含随后要发送的数据帧长度</li><li>CTS(Clear to Send)：应答帧</li></ul><p><img src="/2021/05/04/cn2/image-20201020112537734.png" alt="image-20201020112537734"></p></li></ul><h3 id="4-3-以太网-IEEE802-3标准"><a href="#4-3-以太网-IEEE802-3标准" class="headerlink" title="4.3 以太网 IEEE802.3标准"></a>4.3 以太网 IEEE802.3标准</h3><ul><li><p>以太网的分类：</p><ul><li>经典以太网 Classsic</li><li>交换式以太网 Switched：用交换机来连接不同的计算机，目前主要使用的以太网类型</li></ul><p><img src="/2021/05/04/cn2/image-20201020114731024.png" alt="image-20201020114731024"></p></li></ul><h4 id="4-3-1-经典以太网的MAC子层协议"><a href="#4-3-1-经典以太网的MAC子层协议" class="headerlink" title="4.3.1 经典以太网的MAC子层协议"></a>4.3.1 经典以太网的MAC子层协议</h4><ul><li><p>802.3的数据帧格式：</p><ul><li>前导码是8个字节，7个字节是10101010，最后一个字节是SOF10101011</li><li>目标地址和源地址都是6字节的长度<ul><li>目标地址的第一位是0/1分别表示普通地址和组播地址</li><li>目标地址全是1则是广播</li></ul></li><li>类型用2个字节来标识，取决于协议的类型</li><li>数据字段最多可以有1500个字节</li><li>以太网要求有效帧的长度至少是64bit，因此需要有0-46字节的填充区<ul><li>这是为了满足2t的传输时间</li></ul></li><li>校验和是4字节，一般十32位的CRC</li></ul><p><img src="/2021/05/04/cn2/image-20201020114421387.png" alt="image-20201020114421387"></p><ul><li>采用曼切斯特编码的方式</li></ul></li><li><p><strong>二进制指数后退算法</strong> <code>Binary Exponential Backoff</code>： </p><ul><li>在第i次的冲突之后，随即等待$0\rightarrow 2^i-1$ 个时间槽，但是最大不超过1023</li><li>如果只有少量的站冲突可以确保比较低的延迟，但是冲突的站点比较多的时候也可以保证一个合理的时间来解决冲突</li></ul></li><li><p>以太网的信道效率：假设每个时间槽的间隔时间是2t，并且传送一帧平均需要P秒，获得某个信道的概率为$A=kp(1-p)^{k-1}$ 则信道效率=$\frac{P}{P+2t/A}$</p></li></ul><h4 id="4-3-2-交换式以太网"><a href="#4-3-2-交换式以太网" class="headerlink" title="4.3.2 交换式以太网"></a>4.3.2 交换式以太网</h4><ul><li><p>以太网的结构</p><ul><li>集线器：在电气上简单地连接所有的连接线，比如用双绞线，但是集线器不能增加容量，逻辑上等于一根电缆组成的经典以太网</li><li>交换机：包含一块连接所有端口的<strong>高速背板</strong>，其他的略</li></ul><p><img src="/2021/05/04/cn2/image-20201020233043714.png" alt="image-20201020233043714"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络1:OSI七层模型</title>
      <link href="2021/05/04/cn1/"/>
      <url>2021/05/04/cn1/</url>
      
        <content type="html"><![CDATA[<h4 id="Randomstar-2020-09-2021-01"><a href="#Randomstar-2020-09-2021-01" class="headerlink" title="Randomstar 2020.09-2021.01"></a>Randomstar 2020.09-2021.01</h4><ul><li>成绩组成<ul><li>平时成绩 50%<ul><li>平时小作业</li><li>8个lab</li><li>课堂表现和quiz</li></ul></li><li>期末考试 50%</li></ul></li></ul><h2 id="Chapter1-Introduction"><a href="#Chapter1-Introduction" class="headerlink" title="Chapter1.  Introduction"></a>Chapter1.  Introduction</h2><h3 id="1-1-网络模型"><a href="#1-1-网络模型" class="headerlink" title="1.1 网络模型"></a>1.1 网络模型</h3><ul><li><p>OSI 七层模型：三个重要概念：服务，接口和协议</p><ul><li>物理层：在一条通信信道上传输比特<ul><li>要确定用什么电子信号表示0和1，一个比特持续多久，传输是否可以双向，连接如何建立等等</li></ul></li><li>数据链路层：发送方将输入数据拆分成若干数据帧(frame)，然后按照一定的顺序来发送这些数据帧<ul><li>接收方必须确认收到的每一帧，保证数据的顺序和完整性，然后发回确认帧</li><li>为了防止发送方淹没慢速的接收方，需要对流量进行调节</li><li><strong>介质访问控制子层</strong>则是控制对共享信道的访问，没有拥塞控制的功能</li></ul></li><li>网络层：控制子网的运行，将数据包从源端发送到接收方，需要处理拥塞<ul><li>允许异构的网络相互连接成互联网络</li></ul></li><li>传输层：接受会话层的数据，将数据分割成小单元，然后传到网络层<ul><li>传输层是真正的端到端的层，始终将源数据从源端带到接收方</li><li>OSI模型中1-3层是链式连接的，而4-7层是端到端的</li></ul></li><li>会话层：负责管理主机间的会话进程，利用传输层提供的端到端的服务，向表示层提供增值服务，主要表现为<strong>表示层实体或者用户进程</strong>建立连接并在连接上传输数据<ul><li>这一过程也称为建立同步</li></ul></li><li>表示层：关注传递信息的语法和语义，主要是实现数据的格式转换和压缩</li><li>应用层：包含了各种各样的协议，提供了用户和网络的接口<ul><li>软件开发基本都是应用层的工作</li></ul></li></ul><p><img src="/2021/05/04/cn1/image-20200922231442750.png" alt="image-20200922231442750"></p><ul><li><strong>几种常见设备所处的OSI七层模型的层级：</strong><ul><li>路由器：网络层</li><li>交换机：数据链路层</li><li>集线器：物理层</li></ul></li></ul></li><li><p>TCP/IP</p><ul><li>原本是Linux/Unix下的一个网络通信栈，比较OSI七层模型简单</li><li><strong>没有表示层和会话层</strong>，物理层和数据链路层Host-to-network</li><li>因为开放，所以用的人多，所以成为了互联网的标准</li><li>混合模型 hybrid model——本课程讨论的模型<ul><li>物理层</li><li>数据链接层</li><li>网络层：可能分为内层和外层</li><li>传输层</li><li>应用层</li></ul></li></ul></li></ul><h3 id="1-2-协议架构"><a href="#1-2-协议架构" class="headerlink" title="1.2 协议架构"></a>1.2 协议架构</h3><ul><li>几个关键词：<ul><li>Protocol 协议</li><li>Layer 层</li><li>Peers 对等——不同的host之间存在对等的协议层</li><li>Interface 接口——传输的过程中上层协议会调用下层协议的接口</li><li>Protocol Stack 协议栈</li></ul></li><li>数据传输的过程：<ul><li>在source machine中，数据自顶向下传输，每一层会给上一层传输的数据包添加一个header，如果传输的数据包过大则会把数据包进行拆分，但是<strong>header不会进行拆分</strong> </li><li>在destination machine中，则一步步去掉底层的header，并将小的数据包合并</li></ul></li></ul><h3 id="1-3-服务-Service"><a href="#1-3-服务-Service" class="headerlink" title="1.3 服务 Service"></a>1.3 服务 Service</h3><ul><li><p>服务类型</p><ul><li>面向连接的服务 connection-oriented<ul><li>Reliable message stream 可信信息流，比如page的序列</li><li>Reliable byte stream 可信字节流，比如远程登录，TCP/IP协议向应用层发送的是字节流</li><li>Unreliable connection 不可信连接，比如数字化语音</li></ul></li><li>不需要连接的服务 connection-less<ul><li>Unreliable datagram 不可信数据报，比如垃圾邮件</li><li>Acknowledged datagram 共识数据包，比如注册邮件</li><li>Request-reply 请求回复，比如数据库查询</li></ul></li><li>QoS 服务的质量</li></ul></li><li><p>服务原语 Service Primitives</p><ul><li>面向连接服务的5个服务原语</li></ul><table><thead><tr><th>Primitive</th><th>Meaning</th></tr></thead><tbody><tr><td>LISTEN</td><td>等待一个还没来的连接</td></tr><tr><td>CONNECT</td><td>和一个等待的对等层进行连接</td></tr><tr><td>RECEIVE</td><td>等待一个还没来的message</td></tr><tr><td>SEND</td><td>向对等层发送一个message</td></tr><tr><td>DISCONNECT</td><td>结束一个连接</td></tr></tbody></table><ul><li>Request–Indication–Response–Confirm</li></ul></li></ul><h3 id="1-4-C-S模式"><a href="#1-4-C-S模式" class="headerlink" title="1.4 C/S模式"></a>1.4 C/S模式</h3><ul><li><p>Client-Server Model 客户端主动连接，服务端被动连接</p><ul><li>客户端之间不能直接通信，客户端的通信也需要经过服务器</li><li>新技术：服务器分配端口，让两个客户端直接通信，不需要所有数据经过服务器</li><li>当客户端升级的时候需要更新整个客户端，手机APP就是C/S模式</li></ul></li><li><p>Browser-Server Model 从C/S体系发展而来</p><ul><li>通过浏览器来实现用户和服务端的交互，只需要升级浏览器</li></ul></li><li><p>Peer-to-peer Model(P2P模式)——对等网络</p><ul><li>每个客户端同时又是服务端，没有固定的客户端和服务端</li></ul></li><li><p>wireless network 无线网络</p><ul><li>注意和移动计算mobile computing的区别，移动计算可以是有线的，可以是无线的</li><li>wifi就是一种无线网络</li></ul></li></ul><h3 id="1-5-网络传输"><a href="#1-5-网络传输" class="headerlink" title="1.5 网络传输"></a>1.5 网络传输</h3><ul><li>三种传输方式：<ul><li>Broadcast links 广播式传输<ul><li>传输模型类似于<strong>总线</strong>，总分式结构</li><li>以太网的原理都是基于广播的</li></ul></li><li>Point-to-point limks 点对点传输<ul><li>传输模型是一张复杂的网——网络拓扑结构</li><li>一次只发给一台计算机</li></ul></li><li>multicasting 多点广播<ul><li>传输模型是一个环，一次发给一组计算机</li><li>不是天然存在的，需要通过软件系统来实现多点广播机制</li></ul></li></ul></li><li>网络的类型：按照规模来划分<ul><li>个人区域网 Personal area network(PAN)</li><li>局域网 Local area network(LAN)</li><li>层域网Metropolitan area network(MAN)<ul><li>技术的可替代性比较强，局域网大一点就可以作为层域网，广域网小一点就可以作为层域网</li></ul></li><li>广域网Wide area network(WAN)<ul><li>特点是会有很多router和subnet</li></ul></li><li>最大的网络就是因特网 The Internet</li></ul></li></ul><h3 id="1-6-性能指标"><a href="#1-6-性能指标" class="headerlink" title="1.6 性能指标"></a>1.6 性能指标</h3><p>这一部分来自XXR版计网，作为基础知识了解一下</p><ul><li>数据率和比特率：表示数据传送的速率，单位是bit/s，也写作bps</li><li>带宽 bandwidth<ul><li>带宽本来是指某个信号具有的频带宽度，也就是某个信号所处频率区间的长度，这种意义上的带宽单位是HZ</li><li>但是在计算机网络中也可以指某个信道的最大传输速率，此时的单位也是bit/s</li><li>事实上两种说法一种是频域称谓，另一种是时域称谓</li></ul></li><li>吞吐量：表示单位时间内某个网络每秒的实际数据量，并不是实际数据总量</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统4：磁盘与I/O</title>
      <link href="2021/05/03/os4/"/>
      <url>2021/05/03/os4/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-File-System-Interface"><a href="#Chapter-10-File-System-Interface" class="headerlink" title="Chapter 10. File-System Interface"></a>Chapter 10. File-System Interface</h2><h3 id="10-1-文件"><a href="#10-1-文件" class="headerlink" title="10.1 文件"></a>10.1 文件</h3><ul><li>文件是存储在某种介质上的并且具有文件名的一组信息的集合，分为数据和程序<ul><li>文件具有很多属性，比如name，type，location，size，protection等等</li><li>文件是一种抽象数据类型，可以进行创建、读写、删除等操作</li><li>打开文件需要：<ul><li>文件指针，指向上次读写位置的指针</li><li>文件打开次数的计数器，记录文件被打开的次数，当最后一个进程关闭文件的时候就从打开文件的记录表中移除这个文件名</li><li>文件的磁盘位置</li><li>访问权限</li></ul></li><li>文件的结构<ul><li>流文件结构：字符流或者字节流</li><li>记录文件结构：按照行或者定长、变长的段来存储</li><li>复杂结构：格式化文档、可重定位加载文件</li></ul></li></ul></li></ul><h3 id="10-2-文件访问的方式"><a href="#10-2-文件访问的方式" class="headerlink" title="10.2 文件访问的方式"></a>10.2 文件访问的方式</h3><ul><li><p>三种存取方式</p><ul><li>顺序存取：按照顺序读取文件中的内容，有一个当前位置的指针，读写一次都前进一格，也可以将指针reset</li></ul><img src="image-20201214143053146.png" alt="image-20201214143053146" style="zoom:33%;" /><ul><li>直接存取：可以直接读写n个字符</li><li>索引顺序</li></ul></li></ul><h3 id="10-3-文件目录"><a href="#10-3-文件目录" class="headerlink" title="10.3 文件目录"></a>10.3 文件目录</h3><ul><li><p>磁盘的结构</p><ul><li>磁盘可以划分成若干个分区，每个分区都有目录和文件</li><li>RAID可以防止磁盘或者分区failure</li></ul></li><li><p>目录</p><ul><li><p>可以搜索、创建、删除、重命名、遍历文件</p></li><li><p>分类：</p><ul><li>单级目录</li></ul><img src="image-20201214144314473.png" alt="image-20201214144314473" style="zoom:33%;" /><ul><li>多级目录</li><li>树形目录：搜索速度快<ul><li>绝对路径和相对路径的区别</li></ul></li><li>无环图目录：允许项目有共享的子目录和文件，同一个文件或者目录可以出现在两个不同的目录中<ul><li>共享文件的实现方式是创建一个链接，链接实际上是指向另一个文件或者目录的指针，但是无环图必须是无环的，</li><li>删除链接并不影响原文件而只是删除链接，当原文件被删除的时候链接也会被删除，也可以暂时不管这些指针，而是等使用的时候再发现原来的文件已经被删除</li><li>也可以使用一个文件引用表，在删除所有链接之前不能删除文件，UNIX系统中采用了硬链接的方式，在inode中记录文件被引用量</li></ul></li></ul><img src="image-20201215131714514.png" alt="image-20201215131714514" style="zoom: 33%;" /><ul><li>通用图目录</li></ul></li></ul></li></ul><h3 id="10-4-文件系统安装"><a href="#10-4-文件系统安装" class="headerlink" title="10.4 文件系统安装"></a>10.4 文件系统安装</h3><ul><li>文件系统在访问之间必须要进行挂载</li></ul><h3 id="10-5-文件共享和保护"><a href="#10-5-文件共享和保护" class="headerlink" title="10.5 文件共享和保护"></a>10.5 文件共享和保护</h3><ul><li>网络文件系统：常见的分布式文件共享方式</li><li>多用户系统中可以使用用户id和组id标识文件和访问权限</li><li>Linux/Unix系统中，文件的权限分为读写执行三种，用RWX分别表示三种权限，用户/小组的权限可以用一个数字来表示，执行用1表示，读是2，写是4，用一个0-7之间的数字来表示用户的权限，比如5=4+1表示可以写和执行，7=4+2+1可以读写执行</li></ul><h2 id="Chapter11：File-System-Implementation"><a href="#Chapter11：File-System-Implementation" class="headerlink" title="Chapter11：File System Implementation"></a>Chapter11：File System Implementation</h2><h3 id="11-1-文件系统的分层"><a href="#11-1-文件系统的分层" class="headerlink" title="11.1 文件系统的分层"></a>11.1 文件系统的分层</h3><ul><li>文件系统<ul><li>位于二级存储中，即被存储在磁盘中</li><li>是操作系统中以文件方式管理计算机软件资源的软件和被管理的文件和数据结构的集合</li><li>文件控制块FCB：存储文件的结构</li><li>设备驱动器控制物理设备</li><li>分层的文件系统设计：<ul><li>逻辑文件系统：管理各类文件的元数据，即文件系统的所有数据结构，而没有实际的数据，或者文件内容，根据给定的符号文件名来管理目录结构，逻辑文件系统通过FCB来维护文件的结构</li><li>文件组织模块：知道文件对应的逻辑块和物理块</li><li>基本文件系统：向合适的设备驱动程序发送一般命令就可以对磁盘上的物理块进行读写</li><li>I/O控制：由设备驱动程序和中断处理程序组成，实现内存和磁盘之间的I/O</li></ul></li><li>常见的文件系统<ul><li>FAT用于MS-DOS中的文件系统，FAT32（VFAT）是Windows98中的文件系统，NTFS是最新的Windows文件系统</li><li>ext系列是Linux操作系统中使用的文件系统，proc是Linux的虚拟文件系统，yaffs是闪存文件系统</li><li>HFS+是macOS和iOS上的文件系统</li><li>NFS网络文件系统</li><li>VFS是Linux使用的一个虚拟文件系统是物理文件系统和服务之间的借口，给用户和程序提供了统一的接口（系统调用）</li></ul></li></ul></li></ul><h3 id="11-2-文件系统的实现"><a href="#11-2-文件系统的实现" class="headerlink" title="11.2 文件系统的实现"></a>11.2 文件系统的实现</h3><ul><li>磁盘上的文件结构<ul><li>在磁盘上，文件系统包括如下信息：<ul><li>如何启动存储的操作系统 boot control block</li><li>总的块数，空闲块的数目和位置</li><li>目录结构和各个具体的FCB</li></ul></li><li>FCB包括文件的权限、时间信息、大小、所有者、数据块或者数据块的指针</li></ul></li><li>内存中的文件结构<ul><li>分区表</li><li>目录结构</li><li>系统打开文件表</li><li>进程打开文件表</li></ul></li></ul><h3 id="11-3-文件目录的实现"><a href="#11-3-文件目录的实现" class="headerlink" title="11.3 文件目录的实现"></a>11.3 文件目录的实现</h3><ul><li>线性检索法：按照线性遍历查找所有的文件<ul><li>程序实现比较简单</li><li>缺点是非常耗时</li></ul></li><li>哈希表：减少了目录搜索的时间，但可能会引发冲突</li><li>索引：用的比较多，如B+树索引</li></ul><h3 id="11-4-文件物理结构"><a href="#11-4-文件物理结构" class="headerlink" title="11.4 文件物理结构"></a>11.4 文件物理结构</h3><ul><li><p>分配方式：磁盘块如何被分配给文件</p><ul><li><p>连续分配：每个文件分配一系列连续的磁盘块，优点是简单但是浪费空间</p><ul><li>允许随机访问</li><li>文件的size不能增长否则就要换块，可以采用defragmentation机制</li><li>存在一个逻辑地址向纹理地址转换的机制，LA/512=Q…R</li><li>基于长度的分配</li></ul></li><li><p>连接分配：每个文件是若干磁盘块组成的链表，一个block包含数据和指针</p><ul><li>不允许随机访问，逻辑地址/块的数据位大小=Q…R</li><li>FAT(File-allocation table)文件系统就是连接分配的，FAT32有一个引导区，而文件分配表维护了一系列文件的链表</li></ul><p><img src="/2021/05/03/os4/image-20201217151227603.png" alt="image-20201217151227603"></p><p><img src="/2021/05/03/os4/image-20201217151245128.png" alt="image-20201217151245128"></p><ul><li>NTFS卷布局：引导系统，主文件表，文件区，MFT前16个元数据文件备份，文件区<ul><li>每个分区有一个主文件表MFT，用数据库形式组织，每条记录长度是1K</li></ul></li></ul></li><li><p>索引分配：</p><ul><li>用索引块专门存放所有的指针，<strong>每个文件使用一个索引块</strong>，包含文件所使用的块的地址</li><li>分为一级索引和二级索引等形式</li><li>链接索引：索引块组成的链表</li></ul></li><li><p>Linux的ext2/ext3以及Unix的UFS采用了混合分配机制<br>##Chapter 12：大容量存储系统</p></li></ul></li><li><p>存储器的体系结构，二三级都是大容量存储器</p></li></ul><img src="image-20210107134704724.png" alt="image-20210107134704724" style="zoom:33%;" /><ul><li>常见的大容量存储器<ul><li>磁盘：可拆卸，通过<strong>总线</strong>连接到计算机<ul><li>总线的种类很多，有EIDE, ATA, SATA, USB, Fibre Channel, SCSI等等</li></ul></li><li>固态驱动器：Solid State Drives，简称SSD，也叫固态硬盘，由控制单元和存储单元（FLASH或者DRAM）组成</li><li>磁带：LTFS(Liner Tape File System)为磁带提供了一种通用、开放的文件系统</li></ul></li></ul><p>###12.1 磁盘结构</p><ul><li>磁盘的地址被分为若干个逻辑块的一位数组，一般逻辑块的大小是512字节<ul><li>逻辑块的数组被映射到扇区中</li><li>扇区0是第一个磁道上的第一个扇区</li><li>映射的顺序是从一个磁道用完之后，使用同一个cylinder中的其他磁道，然后从cylinder从外到内</li></ul></li></ul><img src="image-20210107142040501.png" alt="image-20210107142040501" style="zoom:33%;" /><img src="image-20210107142244486.png" alt="image-20210107142244486" style="zoom:33%;" /><ul><li>Network-attached storage(NAS) 通过网络来存储</li><li>Storage Area Network(SAN)</li></ul><img src="image-20210107142630136.png" alt="image-20210107142630136" style="zoom:33%;" /><ul><li>虚拟化存储技术<ul><li>是将存储（子）系统内部功能与具体应用、主机及通用网络资源分离、隐藏及抽象的行为。以期达到存储或数据管理的网络无关性</li><li>对于存储服务及设备的虚拟化应用，以期达到整合设备功能、隐藏复杂细节以及向已经存在的底层存储资源添加新的应用</li></ul></li></ul><p>###12.2 磁盘的调度</p><ul><li><p>磁盘的<strong>访问时间</strong>有三个主要影响因素</p><ul><li>寻道时间：将读写头移动到对应的扇区中所需要的时间</li><li>Rotational latency旋转延迟：将扇区旋转到读写头对齐所需要的额外的时间<ul><li>可以通过转速来计算，平均需要旋转半圈</li></ul></li><li>Transfer Time传输时间：读写所需要的时间</li></ul></li><li><p>磁盘的调度算法：</p><ul><li>先来先服务(FCFS)：按照需要的顺序来调度磁盘中的内容</li><li>最短寻道时间优先(SSTF)：先选择需要的寻道时间最短的磁盘进行调度</li><li>扫描(SCAN)算法：先往start或者end扫描，然后再反方向扫描，读取需要的扇区，也叫电梯算法</li><li>循环扫描(C-SCAN)算法：到一头之后直接返回另一端，再扫描一次</li></ul><img src="image-20210107145045252.png" alt="image-20210107145045252" style="zoom:33%;" /><ul><li>C-LOOK：SCAN的升级版，往一端去的时候，到了最后一个请求就直接折返，不死磕到底</li><li>总结：<ul><li>扫描类算法在大规模的系统中效果更好，算法的性能取决于磁盘访问请求的数量和类型</li><li>磁盘调度算法应该在操作系统中单独写成一个模块，方便被其他的算法替换。</li></ul></li></ul></li></ul><p>###12.3 磁盘的管理</p><ul><li><p>磁盘管理</p><img src="image-20210107150201893.png" alt="image-20210107150201893" style="zoom:33%;" /></li><li><p>启动块 Boot Block存储在ROM中，启动的时候，先启动ROM中的代码，然后是启动块中的代码，然后是整个OS内核</p></li></ul><p>###12.4 Swap-Space Management 交换空间管理</p><ul><li>交换空间是因为虚拟内存将磁盘空间作为内存的扩展，因此需要大量的交换<ul><li>Windows中用pagefile.sys来存储交换空间的信息</li><li>Linux和Unix系统中划分了专门的磁盘分区</li></ul></li></ul><p>###12.5 RAID结构</p><ul><li><p>RAID的全称是Redundant Arrays of Inexpensive (independent) Disks（冗余廉价磁盘阵列）</p><ul><li>把多块物理硬盘组合成一个逻辑磁盘，提供更好的存储性能和数据备份技术</li><li>提高了fail所需的平均时间</li><li>RAID的分级</li></ul><p><img src="image-20210107152629255.png" alt="image-20210107152629255" style="zoom:33%;" /><img src="/2021/05/03/os4/image-20210107153910004.png" alt="image-20210107153910004"></p><ul><li>RAID依然有可能fail，因此备份是非常必要的</li></ul></li><li><p>通常情况下，会有少量热备盘未被分配，自动替换失效的硬盘并在其上重建数据</p></li></ul><p>##Chapter13：I/O System</p><ul><li><p>I/O设备日益多样化，但是软硬件的接口却越来越标准化，因此操作系统内核设计成使用设备驱动程序模块的结构，为不同的I/O设备提供了统一的接口</p></li><li><p>I/O系统由总线I/O系统和主机I/O系统两种组成</p><ul><li>I/O设备具有一定的寻址方式，被直接I/O指令和内存映射I/O所使用</li></ul><img src="image-20210111140550611.png" alt="image-20210111140550611" style="zoom:33%;" /></li><li><p>不同的I/O方式：</p><ul><li>轮询polling，需要考虑设备的状态（ready、busy、error）</li><li>中断interrupt，CPU有一条中断请求线，由I/O设备触发，设备控制器通过中断请求线发送信号而引起中断，CPU捕获中断并派遣到中断处理程序，中断处理程序通过处理设备来清除中断。<ul><li>中断请求分为非屏蔽和可屏蔽的两类，非屏蔽的中断用于处理如不可恢复内存错误等事件，可屏蔽中断可以由CPU在执行关键的不可中断的指令序列前加以屏蔽</li><li>中断优先级：能够使CPU延迟处理低优先级中断而不屏蔽所有中断，这也可以让高优先级中断抢占低优先级中断处理。</li><li>中断可以用于处理各种异常，系统调用是中断驱动的，中断可以用来管理内核的控制流</li></ul></li><li>DMA：直接内存访问，不需要CPU，需要DMA控制器，数据直接在I/O设备和内存之间传输</li></ul></li><li><p>I/O的系统调用提供了对不同I/O设备的统一接口</p><ul><li>驱动设备对内核隐藏了不同I/O控制器差异</li></ul><img src="image-20210111142650086.png" alt="image-20210111142650086" style="zoom:33%;" /><ul><li>块设备包含了磁盘驱动器，可以进行read, write, seek 等操作，允许Raw I/O or file-system access，或者内存映射文件访问</li><li>字符设备包括鼠标键盘和串口，包含get和put等命令</li></ul></li><li><p>阻塞I/O和非阻塞的I/O</p><ul><li>阻塞：进程挂起直到I/O完成</li><li>非阻塞：I/O调用立刻返回，比如buffered I/O，通过多线程机制来实现</li><li>异步I/O：进程和I/O同时运行</li></ul></li><li><p>内核的I/O子系统</p><img src="image-20210111144051884.png" alt="image-20210111144051884" style="zoom:33%;" /><ul><li>I/O的调度：<ul><li>OS通过为每个设备维护一个请求队列来实现调度，调度方式根据实际需要确定，可以FCFS也可以优先级调度</li><li>其他的实现方法：缓冲、高速缓冲、假脱机</li></ul></li><li>缓冲：<ul><li>解决了CPU和I/O设备的速度失配问题，需要管理缓冲区的创建、分配和释放</li><li>单缓冲、双缓冲、多缓冲、缓冲池</li></ul></li><li>假脱机SPOOLing 用来保存设备输出的缓冲，这些设备如打印机不能接收交叉的数据流</li><li>内核中需要维护一些I/O相关的数据结构，保存留I/O组件使用的状态信息，包括打开文件表，网络连接，字符设备状态等</li></ul></li><li><p>进程从磁盘中读取一个文件的过程</p></li></ul><img src="image-20210111150157848.png" alt="image-20210111150157848" style="zoom:33%;" /><ul><li><p>STREAM</p><ul><li>是一个用户进程和I/O设备之间的全双工通信信道</li></ul><img src="image-20210111150703622.png" alt="image-20210111150703622" style="zoom:33%;" /></li><li><p>提高I/O性能的办法：</p><ul><li>减少上下文切换、数据的copy</li><li>减少中断，使用更大的数据传输和更优秀的控制器，或者使用轮询</li><li>使用DMA</li><li>平衡CPU，内存，I/O设备和总线的吞吐量</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统3：内存管理</title>
      <link href="2021/05/03/os3/"/>
      <url>2021/05/03/os3/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8：主存-Main-Memory"><a href="#Chapter-8：主存-Main-Memory" class="headerlink" title="Chapter 8：主存 Main Memory"></a>Chapter 8：主存 Main Memory</h2><h3 id="8-1-基本知识"><a href="#8-1-基本知识" class="headerlink" title="8.1 基本知识"></a>8.1 基本知识</h3><ul><li><p>程序一定要从磁盘装载进入内存才能运行，内存和寄存器是CPU可以直接访问的存储部分</p><ul><li>cache位于内存和CPU寄存器之间</li></ul><img src="image-20201130140737037.png" alt="image-20201130140737037" style="zoom:50%;" /></li><li><p>逻辑地址和物理地址</p><ul><li>逻辑地址也叫相对地址和虚地址，由CPU生成，用户程序汇编之后生成的目标代码通常采用相对地址的形式<ul><li>首地址作为0，其他指令都用相对于首地址来编址</li><li>不用能逻辑地址在内存中读取信息</li></ul></li><li>物理地址：实地址，绝对地址，可以直接寻址</li></ul></li><li><p>基地址寄存器和限长寄存器</p><ul><li>一对基地址寄存器和限长寄存器定义了逻辑地址空间</li><li>基地址寄存器存放地址的首地址，限长存储长度</li></ul></li><li><p>地址映射</p><ul><li>在编译、装在和执行三个阶段都有发生</li><li>编译阶段，如果预先知道内存的location就可以生成absolute code，一旦起始位置变了就需要重新编译</li><li>装载阶段，如果内存的location未知，必须生成可以重定位的代码</li><li>执行阶段，如果进程可以移动那么绑定会延迟到运行的时候，需要硬件支持地址映射</li></ul></li><li><p>内存管理单元</p></li><li><p>动态装载和动态链接</p></li></ul><h3 id="8-2-交换技术"><a href="#8-2-交换技术" class="headerlink" title="8.2 交换技术"></a>8.2 交换技术</h3><ul><li>交换技术是指一个进程可以暂时被移出内存并保存在backing store中，然后再次装载进入内存执行<ul><li>backing store是后备存储器，是一个可以存储所有内存映像的快速磁盘，可以提供对这些内存映像的直接访问<ul><li>在Linux系统中表现为交换区，Windows中表现为pagefile.sys</li></ul></li><li>调出和调入：优先级低的进程被调出，优先级高的被调入，使用交换变量，交换的主要耗时是transfer time</li><li>系统会维护一个准备队列来存放准备运行的进程，其内存映像都存储在disk上面</li><li>正常情况下是不会交换的，在内存低于一个阈值的时候会启动交换，在内存增加到一定数量的时候停止换出</li><li>移动操作系统不支持交换，因为是基于闪存的，有写的次数限制</li></ul></li></ul><h3 id="8-3-连续分配"><a href="#8-3-连续分配" class="headerlink" title="8.3 连续分配"></a>8.3 连续分配</h3><ul><li><p>主存往往被分为两个单独的分区：</p><ul><li>常驻操作系统：保存在具有中断向量的低内存中</li><li>用户进程被保存在高内存中</li></ul></li><li><p>浮动寄存器relocation register被用来保护用户进程，将进程之间隔离，并防止其改变操作系统的数据和代码</p><ul><li>基寄存器保存最小的物理地址的值</li><li>有限寄存器包含了逻辑地址的区间，每个逻辑地址必须比有限寄存器要小</li><li>MMU动态映射逻辑地址</li></ul><img src="image-20201130143550998.png" alt="image-20201130143550998" style="zoom: 33%;" /></li><li><p>分区式管理的基本思想是将内存划分成若干个连续的区域，称为分区，每个分区只能存放一个进程，分为固定分区和动态分区</p><ul><li>固定分区：分成若干块固定长度的分区，区域和区域之间存在着未使用的内存空间</li><li>动态分区：<ul><li>动态划分内存，在程序装入内存的时候把可以使用的内存划分出一个连续的区域分配给该进程，并且分区的大小正好适合进程的需要</li><li>三种动态的分配算法<ul><li>First-Fit 分配第一个可以用的足够大的内存分区给进程</li><li>Best-Fit 分配最小的足够大的内存分区给进程</li><li>Worst-Fit 分配最大的一个分区给进程，必须搜索整个记录表</li><li>Next-Fit 类似于First-Fit，每次分区的时候总是从上次查找结束的地方开始，找到一个够大的区域就分配</li></ul></li></ul></li></ul></li><li><p>内存碎片 Fragmentation</p><ul><li>内存会浪费，产生很多的fragmentation，内部碎片是进程内存空间内部的fragmentation，外部碎片是进程内存空间之间的碎片，会减少可运行的进程个数</li><li>可以通过拼接和压紧来进行，但是消灭fragmentation需要非常大的cost</li></ul></li></ul><h3 id="8-4-页式存储管理"><a href="#8-4-页式存储管理" class="headerlink" title="8.4 页式存储管理"></a>8.4 页式存储管理</h3><ul><li><p>分页管理使得一个进程内部的逻辑地址所处的物理空间可以是不连续的，进程在有空的地方就被分配物理内存</p><ul><li>物理内存被分成许多固定大小的frame(帧、物理块)，一般大小都是4k</li><li>逻辑地址被分成了若干块相同大小的block，称为页，运行一个n页的程序需要找到n个空闲的帧</li><li>页表用于将逻辑地址转化成物理地址，页表中列出了进程的逻辑页和其在主存中的物理帧之间的对应关系</li></ul></li><li><p>地址的转换：</p><ul><li>由CPU生成的地址被分为页号p和偏移d，页号被作为页表的索引，包含每一页的在物理内存中的基地址，偏移表示在物理地址相对于基地址的偏移量</li><li>对于<strong>逻辑地址空间大小</strong>为$2^m$，页的大小是$2^n$的情况，页号p有m-n位，偏移量有n位</li></ul><img src="image-20201130153619598.png" alt="image-20201130153619598" style="zoom:33%;" /></li><li><p>页表page table</p><ul><li>页表位于内存中，有PTBR和PTLR分别存储页表号和页表的长度</li><li>页表的cache：TLB也叫联想寄存器，快表，工作原理如下图所示</li></ul><img src="image-20201203142041351.png" alt="image-20201203142041351" style="zoom:33%;" /><ul><li><p>有效访问时间</p><img src="image-20201203142252118.png" alt="image-20201203142252118" style="zoom: 25%;" /></li><li><p>内存的保护：用一位来表示数据是否有效</p></li></ul></li><li><p>共享页：没仔细讲</p></li><li><p>页表的类型</p><ul><li>分级页表：x86的逻辑地址32位，页的大小是4kb，则页表项最多有1M个，这就需要每个进程的页表需要连续的4MB，这很明显是不现实的，因此需要分级的页表</li><li>哈希页表：虚拟页号通过一个hash函数在页表中查找</li></ul><img src="image-20201203145152612.png" alt="image-20201203145152612" style="zoom:33%;" /><ul><li>反向页表：逻辑地址由pid+页表号+偏移量组成</li></ul><img src="image-20201203145708082.png" alt="image-20201203145708082" style="zoom:33%;" /></li></ul><h3 id="8-5-分段管理"><a href="#8-5-分段管理" class="headerlink" title="8.5 分段管理"></a>8.5 分段管理</h3><ul><li><p>一个进程有若干个部分组成，包括</p><img src="image-20201203151440744.png" alt="image-20201203151440744" style="zoom:50%;" /><ul><li>将逻辑地址分为段号+段内地址</li></ul></li></ul><h2 id="Chapter-9：虚拟内存Virtual-Memory"><a href="#Chapter-9：虚拟内存Virtual-Memory" class="headerlink" title="Chapter 9：虚拟内存Virtual Memory"></a>Chapter 9：虚拟内存Virtual Memory</h2><h3 id="9-1-基本概念"><a href="#9-1-基本概念" class="headerlink" title="9.1 基本概念"></a>9.1 基本概念</h3><ul><li>虚拟内存的基本思路：只将一部分正在运行的程序放入内存中，将逻辑内存和物理内存分开<ul><li>请求调页Demand Paging 按需要调取页，请求页式管理</li><li>请求段式管理 Demand Segmentation</li><li>局部性原理：空间局部性和时间局部性</li><li>虚拟内存的空间比物理地址的空间要大</li></ul></li><li>一个进程的地址空间中，从高到低依次是栈、堆、数据和代码区，再往外的高地址空间是操作系统的内核和环境变量和参数</li></ul><h3 id="9-2-按需调页"><a href="#9-2-按需调页" class="headerlink" title="9.2 按需调页"></a>9.2 按需调页</h3><ul><li>基本的想法是只在需要的时候将一个页调度内存，可以减少I/O次数和内存使用，相应更快，支持更多用户</li><li>页表的结构<ul><li>有效位：每个页表的项目需要一位来表示该页是否有效，如果页表中显示这个页表项是无效的，就说明存在page fault，说明这一页在内存中不存在</li><li>在请求分页系统中，每个页表项的页号对应有如下内容：<ul><li>物理块号</li><li>状态位P，表示该页是否已经调入内存中，供程序访问的时候参考</li><li>访问字段A，用于记录本页在一段时间内被访问的次数，或者最近已经有多长时间没有被访问</li><li>修改位R/W，表示页在调入内存后是否被修改过</li><li>外存地址：用于指出该页在外存上面的地址</li></ul></li></ul></li><li>缺页Page Fault<ul><li>第一次访问页表中的某一项肯定会导致缺页(因为还没有调入内存，这一页无效)，会使得操作系统进入缺页中断，此时操作系统会把页调入内存中并修改表项，然后重新运行上一条指令(因为没有访问到)</li><li>缺页率p在0-1之间，内存访问有效时间EAT的计算方式是：(1-p)*物理内存访问效率+p*缺页中断服务的时间<ul><li>缺页服务的时间包括发现缺页、换入和换出、重新启动所需要的时间之和</li><li>PPT上有一个比较具体的时间统计过程，但是太细了，记不住</li></ul></li></ul></li></ul><h3 id="9-3-进程创建"><a href="#9-3-进程创建" class="headerlink" title="9.3 进程创建"></a>9.3 进程创建</h3><ul><li>虚拟内存允许进程创建的时候进行写时拷贝(copy-on-write)<ul><li>COW允许父进程和子进程一开始的时候共享一些页，如果有进程需要改变页的内容，才会copy一份该页，这样可以让进程的创建更加有效率</li><li>Windows和Linux都使用该技术</li></ul></li></ul><h3 id="9-4-页面置换"><a href="#9-4-页面置换" class="headerlink" title="9.4 页面置换"></a>9.4 页面置换</h3><ul><li>当内存没有空闲帧的时候，就需要进行页面的置换，即找到一些内存中的页将其换出<ul><li>目标是要尽可能减小page fault的概率</li><li>使用一个修改位来减少过多的页置换，只将修改过的页写入磁盘中</li><li>页面置换算法的过程：<ul><li>找到磁盘上需要换入的页面</li><li>然后去内存中找一个空闲的帧或者选出一个淘汰帧，将这个淘汰帧写入磁盘，然后修改页表</li><li>将需要换入的帧换入内存中并修改页表</li><li>启动进程</li></ul></li><li>我们希望置换之后得到最小的page fault率，因此可以使用引用串来表示一系列对页的访问，引用串由一系列页号组成</li><li>常见的页面置换算法<ul><li>FIFO先进先出算法<ul><li>会引发Belady’s Anomaly 更多的帧导致更多的缺页</li></ul></li><li>OPT最佳页面置换算法：选择未来不再使用的或者在离当前最远位置上出现的页被替换</li><li>LRU最近最久未使用算法：选择最久没有引用的页面来替换，但是要记录页面使用时间，硬件开销太大<ul><li>该算法的关键问题在于怎么计算多长时间没有被引用<ul><li>使用计数器：每个页有一个计数器，每次页被使用就将时钟拷贝到计数器中，当页中的内容需要改变的时候，通过计数器来决定把哪一页换出去</li><li>使用栈：使用一个双向链表来维护一个页号的栈，当页被引用的时候就将对应的页号移动到栈顶，好处是确定替换页面的时候不需要进行搜索</li></ul></li></ul></li><li>近似LRU算法<ul><li>使用引用位，初始化为0，被引用就变成1，优先替换引用位是0的页</li><li>附加引用位算法：每页使用一个8bit的引用位，被访问的时候左边最高位为1，定期右移并且最高位补0，寄存器数值最小的就是最久未使用的页面</li><li>二次机会算法：也叫clock算法，需要引用位，如果被替换的页的引用位是1，那么就设置引用位为0，然后保留这一页，将时钟顺序的下一页作为替换</li><li>增强二次机会算法</li></ul></li><li>LFU最不经常使用算法</li><li>MFU最多引用算法</li><li>Page Buffering页面缓冲算法</li></ul></li></ul></li></ul><h3 id="9-5-帧分配"><a href="#9-5-帧分配" class="headerlink" title="9.5 帧分配"></a>9.5 帧分配</h3><ul><li>固定分配Fixed Allocation<ul><li>平均分配算法：顾名思义，平均分所有的帧</li><li>按比例分配：按照进程的size来分配</li></ul></li><li>优先级分配Priority Allocation<ul><li>如果一个进程发生了缺页，可以置换自己的帧，也可以置换一个更低优先级进程的帧</li><li>置换策略有全局置换和局部置换，全局置换就是可以置换所有的帧，而局部置换只能置换该进程拥有的帧</li><li>分配策略有固定分配和可变分配，和置换策略组合之后产生了三种分配和置换策略<ul><li>固定分配局部置换</li><li>可变分配全局置换</li><li>可变分配局部置换</li></ul></li></ul></li></ul><h3 id="9-6-抖动Thrashing"><a href="#9-6-抖动Thrashing" class="headerlink" title="9.6 抖动Thrashing"></a>9.6 抖动Thrashing</h3><ul><li>如果有一个进程没有足够的页数，会导致缺页率非常高，导致低的CPU使用率，抖动就是一个进程频繁换进换出页的行为<ul><li>按需掉页的基本原理是计算机的两个局部性，当局部性失效的时候就会出现抖动的现象</li></ul></li><li>工作集模型<ul><li>工作集WS是最近被引用的页的集合</li><li>后面慢慢看</li></ul></li></ul><h3 id="9-7-内存映射文件"><a href="#9-7-内存映射文件" class="headerlink" title="9.7 内存映射文件"></a>9.7 内存映射文件</h3><ul><li>内存映射文件的读写允许文件读写被作为一个routine memory access来进行，将一个磁盘块映射到内存中的一页<ul><li>一个文件一开始用按需调页的方法读入</li><li>文件子序列的读写被作为内存访问来进行</li><li>允许多个进程将同一个文件映射到内存中</li></ul></li></ul><h3 id="9-8-内核内存分配"><a href="#9-8-内核内存分配" class="headerlink" title="9.8 内核内存分配"></a>9.8 内核内存分配</h3><ul><li>和用户内存不同，通常使用一个空闲内存池<ul><li>内核需要多种不同size的内存大小</li><li>一些内核内存需要是连续的</li></ul></li><li>Buddy-System<ul><li>用一些物理地址连续的定长段分配内存</li><li>内存的分配以2的幂为单位</li></ul></li><li>Slab Allocator</li></ul><h3 id="9-9-其他"><a href="#9-9-其他" class="headerlink" title="9.9 其他"></a>9.9 其他</h3><ul><li>预调页：<ul><li>可以减少一开始会产生的大量缺页</li><li>预先将一些页调入内存中，但是如果没有被引用，就会导致内存和I/O的浪费</li></ul></li><li>页的大小：需要综合考虑帧的大小、页表的大小、I/O设备的性能</li><li>TLB的范围</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统2：CPU调度，同步和死锁</title>
      <link href="2021/05/03/os2/"/>
      <url>2021/05/03/os2/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter5：CPU-Schedule"><a href="#Chapter5：CPU-Schedule" class="headerlink" title="Chapter5：CPU Schedule"></a>Chapter5：CPU Schedule</h2><h3 id="5-1-基本概念-标准"><a href="#5-1-基本概念-标准" class="headerlink" title="5.1 基本概念/标准"></a>5.1 基本概念/标准</h3><ul><li><p>调度的基本概念</p><ul><li><p>CPU调度=处理机调度=进程调度</p></li><li><p>进程运行消耗的时间主要分为CPU时间和I/O时间，根据程序运行主要消耗的时间，可以分为CPU型的程序和I/O型的程序</p></li><li><p>三种层级的调度</p><ul><li>短程调度、中程调度和长程调度，其中CPU主要是短程调度</li></ul><img src="image-20201015141557996.png" alt="image-20201015141557996" style="zoom:67%;" /></li><li><p>调度发生的时间点：</p><ul><li>从运行切换到暂停的时候</li><li>从运行到就绪状态的时候</li><li>从等待到就绪状态的时候</li><li>进程终止的时候</li></ul></li><li><p>调度的方式：</p><ul><li>抢占式：进程一旦被调度了就一直运行，直到完成或者阻塞的时候才让处理机分配给另一个进程</li><li>非抢占式：程序运行的时候可以基于某种原则，<strong>剥夺进程的CPU使用权，分配给别的进程</strong> </li></ul></li><li><p>调度程序 Dispatcher</p><ul><li>需要进行上下文切换，并切换到用户态</li></ul></li></ul></li><li><p>调度的一系列标准：</p><ul><li>面向用户的准则和评价方式<ul><li>周转时间：进程从<strong>提交到完成所经历的时间</strong>，包含平均周转时间，加权周转时间，平均加权周转时间</li><li>响应时间：从进程提出到首次被响应所需要的时间</li><li>等待时间：进程在就绪队列中等待的时间总和</li><li>进程的调度需要满足公平性和一定的优先级</li></ul></li><li>面向系统的调度性能准则<ul><li>吞吐量 Throughput：单位时间内完成的进程数，跟进程本身的性质和调度算法都有一定的关系<ul><li><strong>批处理系统</strong>：用户交给操作系统一批任务之后就<strong>不再和操作系统交互</strong>，直到任务全部结束</li></ul></li><li>CPU利用率：要使得CPU尽可能忙碌</li><li>各种系统的均衡利用：比如CPU型程序和I/O型程序进行合理搭配，使整个系统的利用率比较高</li></ul></li></ul><blockquote><p>要做软件开发的人多学一些怎么提高用户体验的内容，虽然这些我们学校都不教。</p><p>​                                                        ———— 季江民</p></blockquote><ul><li>我们希望的目标：最大的CPU利用率、最大的吞吐量，最短的周转时间、等待时间、响应时间</li></ul></li></ul><h3 id="5-2-调度算法"><a href="#5-2-调度算法" class="headerlink" title="5.2 调度算法"></a>5.2 调度算法</h3><ul><li>FCFS算法：First-Come First-Serve先来先服务<ul><li>按照进程的提交顺序来安排CPU的调度，先来的直到结束或者阻塞，才让出CPU(非抢占式的)</li><li>在进程或者作业完成的时候，并不立即恢复执行，通常等到当前进程让出CPU才进行</li><li>是最简单的算法</li><li>优点是：有利于长进程，而不利于短进程，对CPU型进程友好</li></ul></li><li>SJF算法：Shortest-Job-First Scheduling<ul><li>对<strong>预计执行时间</strong>最短的作业优先分配CPU使用权</li><li>事实上是很难实现的，因为难以估计进程运行需要的时间，所以真的操作系统中一般不用这些东西</li><li>两种变形的形式：<ul><li>最短剩余时间优先 SRT</li><li>最高相应比优先 HRRN<ul><li>相应比R=(等待时间+要求执行的时间)/要求执行的时间</li></ul></li></ul></li><li>这里JJM上课讲了好几道PPT里面的例题</li></ul></li><li>优先级调度：Priority Scheduling<ul><li>小的数字代表高的优先级，该算法就是把CPU分配给了就绪队列中优先级最高的进程</li><li>静态优先级和动态优先级，静态是一开始就确定优先级，动态优先级是基于某种原则，使得进程的优先级随情况而变</li><li>一般使用抢占式的调度，优先级高的进程来了直接将CPU使用权从当前进程中剥夺</li><li><strong>饥饿 Starvation</strong> 在使用静态优先级的调度策略时，优先级低的进程可能永远得不到CPU的使用权<ul><li>进程卷起来的后果</li><li>解决的方法：老化 Aging，随着时间的增加提高进程的优先级——动态优先级的策略</li></ul></li></ul></li><li>时间片轮转调度：<code>Round Robin(RR)</code><ul><li>算法描述<ul><li>将系统中所有的进程按照FCFS原则排成队列，每次调度将CPU分配给队列顶端的进程，执行一个时间片slice</li><li>时间片结束的时候，发生时钟中断，然后将该进程移动到队列末尾</li><li>通过上下文切换，执行当前的队列顶端的进程</li><li>进程可以不运行完就出让CPU的使用权</li></ul></li><li>slice的确定：和进程数量有关，数目越多，时间片越短<ul><li>n个进程，<code>time quantum</code>是q，响应时间就是nq</li></ul></li></ul></li><li>多级队列调度<ul><li>将就绪队列分为若干个子队列，每个进程按照一定方式归入一个队伍，不同的队伍可能有不同的优先级、时间片长度和调度策略：<ul><li>固定优先级调度</li><li>给定时间片调度</li></ul></li><li>多级反馈队列：时间片轮转算法和优先级算法的综合和发展，有点有<ul><li>为提高系统吞吐量和缩短平均周转时间而照顾短进程</li><li>为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程</li><li>不必估计进程的执行时间，动态调节</li></ul></li></ul></li></ul><blockquote><p>5.3这一部分不会考试，上课也就随便讲讲</p></blockquote><h3 id="5-3-Windows中的调度"><a href="#5-3-Windows中的调度" class="headerlink" title="5.3 Windows中的调度"></a>5.3 Windows中的调度</h3><ul><li><p>Windows2000/XP的处理机调度的调度对象是<strong>线程</strong>，调度算法是多种调度算法的综合体，针对实际系统的需要进行针对性的优化和改进</p><ul><li>线程都是内核线程，没有用户线程</li><li>线程有七种状态：初始化、就绪、备用、运行、等待、转换、中止</li><li>采用动态优先级和抢占式的调度，总是运行优先级最高的线程，同一优先级的按照RR算法进行调度</li><li>32个用户优先级：其中一半是实时的优先级</li></ul></li><li><p>哪些情况下会提高线程的当前优先级：</p><ul><li>I/O操作完成了</li><li>信号量或者时间等待结束</li><li>前台进程中的线程完成了一个等待的操作</li><li>由于窗口活动而唤醒图形用户接口线程</li><li>线程处于就绪状态超过一定的时间</li></ul></li></ul><h2 id="Chapter-6：Process-Synchronization"><a href="#Chapter-6：Process-Synchronization" class="headerlink" title="Chapter 6：Process Synchronization"></a>Chapter 6：Process Synchronization</h2><h3 id="6-1-Background"><a href="#6-1-Background" class="headerlink" title="6.1 Background"></a>6.1 Background</h3><ul><li><p>并发的线程访问共享数据的时候可能会出现数据的不一致性</p><ul><li><p>需要有一定的机制去维持一致性</p></li><li><p>比如上一节提到的有限缓冲区问题中，我们维护一个counter来记录缓冲区中item的个数，其中两个进程producer和customer分别需要执行<code>counter++</code>和<code>counter--</code>，但是这两种操作需要满足<strong>原子性</strong>(运行的时候不允许被中断)，如果两个进程producer和customer都想要改变counter，就可能导致数据的不一致性</p><ul><li>一个<code>counter++</code>的操作编译成汇编语言可能就是,<code>counter</code>–同理，区别是<strong>寄存器不同</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">regiter1 &#x3D; counter;register1 &#x3D; register1 + 1;counter &#x3D; register1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>一个神奇的题目：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">有两个进程P1、P2，它们分别执行下面的程序体，其中total是两个进程都能访问的共享变量，初值为0（可理解为共享存储段中的存储单元），count是每个进程的私有变量。假设这两个进程并发执行，并可自由交叉（interleave），则这两个进程都执行完后，变量total可能得到的最小取值是A. 50 B. 1 C. 2 D. 3;P1: &#123;int count;for ( count &#x3D;1; count &lt;&#x3D; 50; count++ )total &#x3D; total + 1; &#125;P2: &#123;intcount;for ( count &#x3D;1; count &lt;&#x3D; 50; count++ )total &#x3D; total + 2; &#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这道题的答案是3，因为每一次都会有<code>total=registerX</code> 这样一个步骤，只需要合理地控制这一步就可以使得最后total是3，题目中讲的方法就是在写入total之前执行另一个进程剩下的49次，这样就使得total不会被这49次影响，因此<strong>能影响到total结果的只有一次+1，一次+2</strong>，最后的结果就是3</li></ul></li></ul></li><li><p>竞争条件 Race Condition</p><ul><li>多个进程都需要访问和修改一块共享数据区，此时数据的状态取决于最后访问这一区域的进程</li><li>为了防止竞争条件的出现，并发的进程必须<strong>同步</strong><code>Sychronized</code></li><li>三个控制问题：<ul><li>互斥mutual exclusion 多个进程不能同时得到一个资源</li><li>死锁dead lock 进程互不相让，导致永远得不到资源</li><li>饥饿starvation 资源分配不公平，一个进程长时间得不到资源</li></ul></li></ul></li></ul><h3 id="6-2-主要问题"><a href="#6-2-主要问题" class="headerlink" title="6.2 主要问题"></a>6.2 主要问题</h3><ul><li><p>基本概念</p><ul><li>假设有n个进程在竞争一些共享的数据区</li><li><strong>临界资源</strong>：一次只允许一个进程访问的资源，比如消息缓冲队列等等</li><li><strong>临界区critical section</strong>：访问临界资源的代码段</li><li>Solution必须满足以下条件：<ul><li><code>mutual exclusion</code> 互斥，一个进程在访问临界资源的时候其他的进程不能访问</li><li><code>Progress</code> 空间让进：如果临界资源没有进程在访问，并且有进程想要进入临界区，那么应该允许其进行</li><li>有限等待：进程需要在等待有限时间之后可以访问资源</li></ul></li></ul></li><li><p>Peterson’s Solution</p><ul><li><p>以两个进程为例，指令的装载是原子的，即不能被中断</p></li><li><p>算法1：</p><img src="image-20201022142113936.png" alt="image-20201022142113936" style="zoom:67%;" /><ul><li>这个算法是强制轮流的，没有考虑进程的实际需要，造成资源利用不充分，没有实现空闲让进</li></ul></li><li><p>算法2：</p><img src="image-20201022142441975.png" alt="image-20201022142441975" style="zoom:67%;" /><ul><li>依然不满足空闲让进，两个进程可能都进不了临界区，如果两个进程同时执行了第一行，就会两个都进不了临界资源，这里就造成了死锁，看起来比前面一个算法更加糟糕，开倒车🚗    </li><li>如果改成下面这样，可能会导致两个进程同时进入临界区，不满足互斥条件</li></ul><img src="image-20201022143100553.png" alt="image-20201022143100553" style="zoom:67%;" /></li><li><p>算法3：Peterson’s Algorithm——缝合怪，是上面两个算法的结合</p><img src="image-20201022143334493.png" alt="image-20201022143334493" style="zoom:67%;" /><ul><li>变量turn表示谁可以进入临界区，flag数组表示进程是否准备好了</li><li>满足了三个条件：互斥，空闲让进，有限等待</li></ul></li><li><p>面包房算法<code>Bakery Algorithm</code>：处理n个进程时候的情况</p><ul><li>进入临界区之前，进程收到一个标号number，标号最小的进程可以进入临界区</li><li>如果两个进程有相同的标号，则按进程本身的下标决定谁先来</li><li>共享的数据区<code>bool choosing[n]; int number[n];</code> 若choose为真则表示进程i正在获取编号，number表示进程的编号</li></ul></li></ul></li></ul><h3 id="6-3-硬件的同步"><a href="#6-3-硬件的同步" class="headerlink" title="6.3 硬件的同步"></a>6.3 硬件的同步</h3><ul><li>计算机提供的硬件支持和硬件指令<ul><li>Test-And-Set 测试与设置的指令，调度的选择是随机的</li><li>swap 交换指令</li><li>优缺点：<ul><li>优点：<ul><li>适用于任意数目的进程，单处理机/多处理机系统都适用</li><li>简单容易验证，可以支持进程内存存在多个临界区，只需为每个临界区设置一个布尔变量</li></ul></li><li>缺点：<ul><li>消耗CPU时间，不能实现让权等待</li><li>可能产生饥饿，从等待的进程中随机选一个，可能永远选不上</li><li>可能死锁</li></ul></li></ul></li></ul></li><li>自旋锁 Spinlock<ul><li>处理多处理机的互斥机制的自旋锁，类同于TS指令机制，是一个和公用数据结构有关的锁定机制</li><li>自旋锁像所保护的数据结构一样，存储在共用的内存中，是用汇编语言写的</li><li>当线程试图获得自旋锁的时候，在处理器上所有其他的工作都要终止，因此拥有自旋锁的线程永远不会被抢占</li></ul></li></ul><h3 id="6-4-semaphores-信号量"><a href="#6-4-semaphores-信号量" class="headerlink" title="6.4 semaphores 信号量"></a>6.4 semaphores 信号量</h3><ul><li><p>信号量：一种数据类型，只有初始化，wait和signal三种操作</p><ul><li>整型信号量</li><li>记录型信号量：可以取任意的正整数，表示资源的个数</li><li>AND型信号量</li><li>二值信号量：只能是0或者1，也叫做同步互斥锁</li></ul></li><li><p>记录型信号量S</p><ul><li>数据结构表示</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">process</span> <span class="token operator">*</span>list<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> semaphore<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>S.value&gt;0表示有这么多资源可以用，等于0表示无资源可用或者不能进入临界区，负数表示在等待队列中进程的个数或者表示等待进入临界区的进程</li><li>两种原子操作：block()将running转换成waiting，wakeup()将waiting转换成ready</li><li>wait操作和signal操作的实现方式</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">wait</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>S<span class="token operator">-></span>value<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-></span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>add this process to S<span class="token operator">-></span>list<span class="token punctuation">;</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">signal</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>S<span class="token operator">-></span>value<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-></span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>remove a process P from S<span class="token operator">-></span>list<span class="token punctuation">;</span><span class="token function">wakeup</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>wait表示申请一个资源，signal表示释放一个资源，一般都需要成对出现</li></ul></li><li><p>死锁和饥饿</p><ul><li>死锁：两个进程互相等待导致执行不了，陷入无限的等待中</li></ul><p><img src="/2021/05/03/os2/image-20201026144519948.png" alt="image-20201026144519948"></p><ul><li>饥饿：资源没有释放导致进程一直在等待队列中</li></ul></li></ul><h3 id="6-5-经典的同步问题"><a href="#6-5-经典的同步问题" class="headerlink" title="6.5 经典的同步问题"></a>6.5 经典的同步问题</h3><h4 id="6-5-1-生产-消费者问题"><a href="#6-5-1-生产-消费者问题" class="headerlink" title="6.5.1 生产-消费者问题"></a>6.5.1 生产-消费者问题</h4><ul><li>也叫做有限缓冲区问题，描述了一组生产者向一群消费者提供消息，他们共享了一个优先缓冲池(bounded buffer pool)，生产者向其中写入消息，而消费者从中取得消息<ul><li>这是很多协作进程通信过程的抽象</li><li>假设可以写的缓冲区有N个，设置三个初始的信号量：<code>mutex=1，full=0，empty=N</code></li></ul></li></ul><h4 id="6-5-2-读者-写者问题"><a href="#6-5-2-读者-写者问题" class="headerlink" title="6.5.2 读者-写者问题"></a>6.5.2 读者-写者问题</h4><ul><li>问题描述：<ul><li>只要读数据的称为读者，一些进程要求修改数据内容的称为写者</li><li>读者可以同时读，但是写者不能和其他进程同时访问，必须互斥</li><li><strong>第一</strong>读者写者问题：允许多个读者一起读，只有一个写者可以进入数据区，会导致写者饥饿<ul><li>信号量的设置：<code>mutex=1，wrt=1</code> 用一个readcount记录读者的数量</li></ul></li><li><strong>第二</strong>读者写者问题：当有写者就绪的时候就尽可能满足写者的要求</li></ul></li></ul><h4 id="6-5-3-哲学家吃饭问题"><a href="#6-5-3-哲学家吃饭问题" class="headerlink" title="6.5.3 哲学家吃饭问题"></a>6.5.3 哲学家吃饭问题</h4><ul><li>问题描述：<ul><li>一群哲学家围成一圈吃饭，每个哲学家和邻座共有一根筷子，一个哲学家吃饭需要拿起两边的筷子，哲学家的行为在吃饭和思考之间转换</li></ul></li></ul><h2 id="Chapter-7：死锁-DeadLock"><a href="#Chapter-7：死锁-DeadLock" class="headerlink" title="Chapter 7：死锁 DeadLock"></a>Chapter 7：死锁 DeadLock</h2><h3 id="7-1-死锁的基本概念"><a href="#7-1-死锁的基本概念" class="headerlink" title="7.1 死锁的基本概念"></a>7.1 死锁的基本概念</h3><ul><li>死锁的定义：指多个进程因竞争共享资源而造成相互等待的一种僵局，若无外力作用，这些进程都将永远不能再向前推进<ul><li>死锁发生的前提是我们写的程序不能自己倒过来运行</li></ul></li><li>产生死锁的四个必要条件：<ul><li>互斥：一个资源在一个时间里只能被一个进程使用</li><li>占有并等待：进程已经占有了一个资源又提出新的要求，而该资源又被其他进程占有</li><li>资源不可抢占/剥夺：资源只能等占有它的进程使用完之后释放，不能被抢占</li><li>循环等待：一系列进程Pi，等待后一个进程占有的资源，占有了前一个进程需要的资源</li></ul></li></ul><h3 id="7-2-资源分配图Resource-Allocation-Graph"><a href="#7-2-资源分配图Resource-Allocation-Graph" class="headerlink" title="7.2 资源分配图Resource Allocation Graph"></a>7.2 资源分配图Resource Allocation Graph</h3><ul><li><p>由一系列的节点V和边E组成：</p><ul><li>是有向图，边是有方向的</li><li>节点V分成两类，P表示进程节点的集合，R表示资源节点的集合</li><li>边分成请求边和分配边两种，请求边从P指向R，表示进程请求这个资源，分配边从R指向P，表示资源被分配给进程</li></ul></li><li><p>资源分配图中有环就表明<strong>可能存在</strong>死锁，当一个资源有多个实例的时候也可能不死锁，也就是说判断是否死锁需要考虑资源的实例个数和分配情况</p><ul><li>没有环的肯定没有死锁</li><li>有环并且可用的只有一个实例，就产生死锁</li><li>有环但是还有多个可以分配的实例，不死锁</li></ul></li></ul><h3 id="7-3-死锁的处理"><a href="#7-3-死锁的处理" class="headerlink" title="7.3 死锁的处理"></a>7.3 死锁的处理</h3><ul><li><p>三种方法：</p><ul><li>程序的开发阶段预防和避免死锁</li><li>程序运行时进行死锁的检测和解除</li><li>鸵鸟方法：假装死锁没有发生过，这一方法被大多数操作系统使用，如UNIX，Linux，Windows</li></ul></li><li><p>预防死锁：</p><ul><li>对于不能共享的资源使用同步互斥</li><li>当一个进程请求一个资源时，不能占有其他任何资源——静态预分配</li><li>不能抢占</li><li>资源有序申请，破坏循环等待</li></ul></li><li><p>避免死锁</p><ul><li><p>分配资源之前判断是否可能产生死锁，如果会死锁就先不分配</p></li><li><p><strong>安全状态</strong>：系统存在一种调度的方式使得进程按这个顺序可以申请到所需资源并完成运行，这个进程序列叫做安全序列，否则就叫不安全状态</p></li><li><p>如果系统处于安全状态就不可能会产生死锁，否则就有可能，而<strong>避免死锁就要让系统永远处于安全状态</strong></p><ul><li>每类资源只有一个实例，使用资源分配图算法</li><li>每类资源有多个实例，使用银行家算法</li></ul></li><li><p>资源分配图算法：</p><ul><li>用虚线表示需求边，一定条件下可以转换成请求边</li><li>假设P需要R，只有在需求边P-R变成分配边R-P而不会形成环的时候才允许这次申请</li></ul></li><li><p>银行家算法：</p><ul><li>假设有n个进程和m种资源<ul><li>available[m]=k表示第m种资源有k个实例</li></ul></li><li>max[i,j]=k表示第i个进程需要资源j 的k个实例<ul><li>allocation[i,j]=k表示第i个进程分配了资源j的k个实例</li></ul></li><li>Need[i,j] =k表示还需要k个</li><li>安全算法：</li></ul><img src="image-20201126141545663.png" alt="image-20201126141545663" style="zoom: 33%;" /><ul><li>资源分配算法</li></ul><img src="image-20201126144018477.png" alt="image-20201126144018477" style="zoom: 33%;" /></li></ul></li><li><p>死锁的检测：</p><ul><li>单个实例：使用等待图，如果<strong>有环就是死锁</strong> </li><li>多个实例：有一套死锁检测算法</li></ul><img src="image-20201129152437083.png" alt="image-20201129152437083" style="zoom: 33%;" /><img src="image-20201129152508228.png" alt="image-20201129152508228" style="zoom:33%;" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统1：导论，进程和线程</title>
      <link href="2021/05/03/os1/"/>
      <url>2021/05/03/os1/</url>
      
        <content type="html"><![CDATA[<h3 id="RandomStar-in-2020-09"><a href="#RandomStar-in-2020-09" class="headerlink" title="RandomStar in 2020.09"></a>RandomStar in 2020.09</h3><h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1. Introduction"></a>Chapter 1. Introduction</h2><h3 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h3><ul><li>用户和计算机硬件之间的中间程序<ul><li>执行用户程序</li><li>使计算机易于使用</li><li>充分调用计算机资源</li></ul></li><li>计算机系统可以分为四个部分<ul><li>硬件：CPU，内存和I/O设备</li><li>操作系统<ul><li>用户视角：操作系统是用户和计算机硬件之间的接口<ul><li>计算机硬件</li><li>操作系统提供了命令级接口(鼠标和键盘)和程序级接口(system calls)</li></ul></li><li>系统视角：操作系统是计算机系统资源的管理者<ul><li>控制程序，分配资源</li></ul></li><li>软件分层的观点：是扩充裸机的第一层系统软件</li><li>一直在运行的程序就是kernel(内核) </li></ul></li><li>应用程序</li><li>用户 user，包含人、机器和其他计算机，不单指人</li></ul></li><li>中文书上对操作系统的定义：<ul><li>操作系统是一组有效控制和管理计算机各种硬件和软件资源，合理组织计算机的工作流程，方便用户的程序的集合</li><li>有效：系统效率高，资源的利用率高</li><li>合理：公平，不公平的时候会产生死锁和饥荒</li><li>方便：用户接口，图形界面</li></ul></li></ul><h3 id="1-2-计算机组成"><a href="#1-2-计算机组成" class="headerlink" title="1.2 计算机组成"></a>1.2 计算机组成</h3><ul><li>主机型计算机系统：以存储器为中心，CPU和数据通道都和存储器相连</li><li>中断：指系统发生某个异步/同步事件后，处理机暂停正在执行的程序，转去执行处理该事件程序的过程<ul><li>通过中断向量来实现，中断向量记录了所有服务例程的地址</li><li>中断的分类<ul><li>中断(外中断)：I/O中断，时钟中断<ul><li>外部设备发出的I/O请求，分为可屏蔽和不可屏蔽两类</li><li>可以在指令执行的任意时期产生</li></ul></li><li>异常(内中断)：系统调用，缺页异常，断点指令，其他异常<ul><li>由CPU产生，一条指令中止之后才会发出中断</li></ul></li></ul></li><li>操作系统是<strong>中断驱动</strong>的</li></ul></li></ul><h3 id="1-3-计算机系统结构"><a href="#1-3-计算机系统结构" class="headerlink" title="1.3 计算机系统结构"></a>1.3 计算机系统结构</h3><ul><li><p>单处理器系统：core是执行指令和存储本地数据的组件</p></li><li><p>多处理器系统</p><ul><li>也被称为并行系统，分为同步和异步两种</li><li>优点包括：规模经济的，吞吐量增加</li><li>NUMA——非同一内存访问</li></ul></li><li><p>集群系统cluster</p><ul><li>是由一组互联的主机（节点）构成统一的计算机资源，通过相应软件协调工作的计算机机群</li><li>分为对称集群和非对称集群</li><li>HPC(high-performance computing) 高性能计算</li><li>DLM(distributed lock manager) 分布式锁管理器，用于避免集群中的冲突操作</li></ul></li></ul><h3 id="1-4-操作系统的运行"><a href="#1-4-操作系统的运行" class="headerlink" title="1.4 操作系统的运行"></a>1.4 操作系统的运行</h3><ul><li><p>何时运行操作系统？</p><ul><li>操作系统是硬件中断驱动的，此时先启动中断处理程序</li><li>软件出错，或者产生异常exception和陷入trap</li><li>其他的进程问题，比如死循环</li></ul></li><li><p>Dual-mode operation 双模式操作</p><ul><li><p>user mode 用户态</p></li><li><p>执行用户程序的时候的模式</p><ul><li>只能访问属于它的存储空间和普通寄存器，只能执行普通指令</li><li>用户程序和操作系统以外的服务程序运行在用户态中，使用用户栈</li></ul></li><li><p>kernel mode 内核态</p><ul><li>执行操作系统程序的时候的模式</li><li>可以访问所有系统资源，执行<strong>特权指令</strong>(I/O指令、设置时钟、置控制寄存器等)，可以直接操作和管理硬件设备</li><li>操作系统内核的程序运行处于内核态，使用内核栈</li></ul></li><li><p>上课讲过的几个习题</p><ul><li><p>三种从用户态<strong>切换到内核态</strong>的方式：</p><ul><li><h1 id="系统调用、异常、外围设备的中断"><a href="#系统调用、异常、外围设备的中断" class="headerlink" title="系统调用、异常、外围设备的中断"></a>系统调用、异常、外围设备的中断</h1></li></ul></li><li><h1 id="中断处理一定会保存而子程序调用不需要保存的内容是：程序状态字寄存器"><a href="#中断处理一定会保存而子程序调用不需要保存的内容是：程序状态字寄存器" class="headerlink" title="中断处理一定会保存而子程序调用不需要保存的内容是：程序状态字寄存器"></a>中断处理一定会保存而子程序调用不需要保存的内容是：程序状态字寄存器</h1></li><li><p>不可能发生在用户态的事件是：进程切换，需要调度处理器和系统资源，为保证系统安全</p><ul><li>缺页是用户态到内核态</li><li>系统调用和中断既可以发生在用户态，也可以发生在内核态</li></ul></li></ul></li></ul></li></ul><h3 id="1-5-资源管理，虚拟化"><a href="#1-5-资源管理，虚拟化" class="headerlink" title="1.5 资源管理，虚拟化"></a>1.5 资源管理，虚拟化</h3><p>后面会细讲，这里就看了几个标题</p><h3 id="1-6-计算环境"><a href="#1-6-计算环境" class="headerlink" title="1.6 计算环境"></a>1.6 计算环境</h3><ul><li>几种不同的计算环境<ul><li>传统计算：<ul><li>大型机系统：批处理系统和分时系统<ul><li>批处理系统：分为单道批处理系统/多道批处理系统，多道批处理系统中，内存同时进行若干工作，CPU被多路复用</li><li>分时系统：多个用户<strong>分时间共享</strong>同一台计算机<ul><li>响应时间：分时系统的重要指标，假设分时系统中进程数为n，每个进程的运行时间片为q，则S=nq</li></ul></li></ul></li><li>桌面系统——PC个人电脑</li></ul></li><li>移动计算：“再过几年可能是鸿蒙”</li><li>C/S结构计算，P2P计算——区块链技术，虚拟化计算，云计算(SaaS, PaaS, IaaS)</li></ul></li></ul><h2 id="Chapter-2-操作系统结构"><a href="#Chapter-2-操作系统结构" class="headerlink" title="Chapter 2. 操作系统结构"></a>Chapter 2. 操作系统结构</h2><h3 id="2-1-操作系统服务"><a href="#2-1-操作系统服务" class="headerlink" title="2.1 操作系统服务"></a>2.1 操作系统服务</h3><ul><li>操作系统提供如下服务<ul><li>用户接口：包括命令行CLI和图形用户界面GUI</li><li>程序执行：把程序载入内存中执行，</li><li>I/O操作：操作文件和IO设备</li><li>文件系统的操作</li><li>交流：不同的进程之间交流信息</li><li>错误检测：检测CPU，内存，IO设备出现的错误</li><li>资源的分配，用户操作的记录</li><li>安全性保护</li></ul></li></ul><h2 id="2-2-用户操作系统接口-UOSI"><a href="#2-2-用户操作系统接口-UOSI" class="headerlink" title="2.2 用户操作系统接口 UOSI"></a>2.2 用户操作系统接口 UOSI</h2><ul><li>操作系统的接口<ul><li>命令接口<ul><li>命令行用户接口，文本界面</li><li>图形用户接口</li><li>触摸屏接口、语音接口……</li></ul></li><li>程序接口：比如system call</li></ul></li></ul><h2 id="2-3-系统调用system-call"><a href="#2-3-系统调用system-call" class="headerlink" title="2.3 系统调用system call"></a>2.3 系统调用system call</h2><ul><li><p>系统调用：提供操作系统服务的程序接口</p><ul><li>是进程和OS内核的程序接口，使用高级语言来编写</li><li>API封装了一系列的系统调用，比如win32 API， POSIX API和Java API(JVM)</li><li>每个系统调用对应了一个封装例程(wrapper routine)，一些API应用了封装例程，API还包括各类编程接口，比如C语言库函数</li><li>系统调用是在<strong>内核</strong>完成的，<strong>用户态的函数</strong>是在函数库中实现的</li></ul><p><img src="/2021/05/03/os1/image-20200921143335057.png" alt="image-20200921143335057"></p><ul><li>注意区别系统调用和库函数的调用<ul><li>像printf，fopen，malloc这些都是C语言的库函数，而不是系统调用</li></ul></li><li>执行系统调用的几个过程：<ul><li>执行trap指令</li><li>传递系统调用操作</li><li>执行相关操作</li><li>返回用户态</li></ul></li><li>系统调用的种类：进程控制，文件/设备的管理，信息的维护，通信，保护</li></ul></li><li><p>系统调用的参数传递</p><ul><li>最简单的方法：通过寄存器传递参数</li><li>用内存中的block和table存储参数，并在系统调用中把块地址放在寄存器中传递<ul><li>Linux系统使用这种方法实现的</li></ul></li><li>通过栈来传递参数</li></ul></li></ul><h2 id="2-4-系统服务"><a href="#2-4-系统服务" class="headerlink" title="2.4 系统服务"></a>2.4 系统服务</h2><ul><li>操作系统提供的服务，比如shell中的各种命令</li><li>操作系统中运行程序的步骤：<ul><li>将程序装入内存中</li><li>确定起始地址，并从这个地址开始执行</li><li>用控制台监控程序执行的过程</li><li>不需要向操作系统预约运行时间<ul><li>只有实时的操作系统才需要预定CPU时间</li></ul></li></ul></li><li>操作系统提供的功能中，需要特定硬件支持的有：<ul><li>时钟管理</li><li>地址映射</li><li>中断</li><li>进程调度不需要特定的硬件支持</li></ul></li></ul><h2 id="2-5-Linker和Loader"><a href="#2-5-Linker和Loader" class="headerlink" title="2.5 Linker和Loader"></a>2.5 Linker和Loader</h2><ul><li>程序编译之后变成了relocatable object file浮动对象文件<ul><li>链接器会将这些文件变成可执行的二进制文件</li><li>Loader将程序装载入内存执行，将最终地址分配给程序部件，并调整程序中的代码和数据以匹配这些地址</li><li>动态链接库 (Windows系统中的后缀是dll) 通过接口的形式实现链接，而不是直接和库文件进行链接</li></ul></li></ul><h2 id="2-6-操作系统结构"><a href="#2-6-操作系统结构" class="headerlink" title="2.6 操作系统结构"></a>2.6 操作系统结构</h2><ul><li><p>常见的结构</p><ul><li><p>简单结构：比如MS-DOS系统，不划分模块</p><img src="image-20200921152621676.png" alt="image-20200921152621676" style="zoom:67%;" /></li><li><p>层次结构：操作系统分成了若干层次，最外层是用户接口，最内层是硬件</p></li><li><p>单/宏内核结构(Monolithic Kernels)：内核的全部代码打包在一个文件中</p><ul><li>优点是效率很高，缺点是维护和修改非常困难，容易出bug，随着OS变复杂内核的规模会爆炸</li></ul></li><li><p>微内核结构(Microkernel  System Structure)</p><ul><li>最基本的功能直接由中央内核实现，其他的功能都委托给独立的进程，这些进程和内核通过通信接口进行通信</li></ul><img src="image-20200921153641789.png" alt="image-20200921153641789" style="zoom:80%;" /></li><li><p>内核的模块：在需要的时候才进行调用，模块之间互相独立，通过接口互相通信</p></li></ul></li></ul><h2 id="2-7-虚拟机VM"><a href="#2-7-虚拟机VM" class="headerlink" title="2.7 虚拟机VM"></a>2.7 虚拟机VM</h2><ul><li>虚拟机技术：<ul><li>硬件和操作系统内核都看成硬件来使用，和宿主机共享操作系统资源</li><li>提供了一个独立于底层硬件的接口</li></ul></li></ul><h1 id="Chapter3：Linux系统概述和Linux内核"><a href="#Chapter3：Linux系统概述和Linux内核" class="headerlink" title="Chapter3：Linux系统概述和Linux内核"></a>Chapter3：Linux系统概述和Linux内核</h1><h2 id="3-1-Linux操作系统"><a href="#3-1-Linux操作系统" class="headerlink" title="3.1 Linux操作系统"></a>3.1 Linux操作系统</h2><ul><li>Linux操作系统指的是GNU/Linux系统<ul><li>Linux系统的组成：内核，C语言库，编译器，工具集和系统的基本工具，Shell，各种应用软件包等等</li><li>Linux是一种类Unix的操作系统，遵守GNU的GPL/LGPL/AGPL</li><li>Linux 是一个可供<strong>多人使用</strong>的<strong>抢占式多任务操作系统</strong> </li></ul></li><li>GPL: <strong>公用版权协议</strong>General  Public Lisence<ul><li>Linux采用该条款发行</li></ul></li><li>开放源代码：Open Source=代码+许可证+管理机制<ul><li>基于社区开发的、非私有的代码，可令成本更低、开发效率更高、商业应用更加灵活</li></ul></li><li>Linux版本有两种表现形式<ul><li>内核版：Kernel</li><li>发行版：Distribution</li></ul></li><li>Linux成长的五个重要支柱<ul><li>UNIX操作系统</li><li>MINIX操作系统</li><li>GNU</li><li>POSIX</li><li>INTERNET</li></ul></li></ul><h2 id="3-2-Linux内核"><a href="#3-2-Linux内核" class="headerlink" title="3.2 Linux内核"></a>3.2 Linux内核</h2><ul><li><p>Linux内核是<strong>单一体系结构</strong>的</p><ul><li>使用了一种全新的内核模块机制，用户可以根据需要，在不需要对内核重新编译的情况下，动态地装入/移除内核的模块</li><li>模块在内核态运行，实际上是一种<strong>目标对象文件</strong>，没有链接，不能独立运行，但是内核的代码可以在运行的时候链接到系统中作为内核的一部分运行或者取出，从而实现了动态扩充内核的功能</li><li>这种目标代码通常由一系列函数和数据结构组成<ul><li>编译相应的模块，用<code>insmod</code> 指令插入就可以<ul><li>insmod 内核加载模块</li><li>lsmod 查看内核模块</li><li>rmmod 卸载内核模块</li><li>ksyms 显示内核符号和模块符号表的信息，可以读取<code>/proc/kallsyms</code> 中的文件</li><li>modprobe 是自动根据模块之间的依赖性插入模块的程序，比如A依赖于B，那么插入A的时候modprobe命令就会把B也加载进入内核之中</li></ul></li><li>模块不依赖某个固定的硬件平台</li><li>被链接到内核之后，模块的作用域和静态链接的内核目标代码完全等价</li></ul></li><li>模块的全称是动态可加载内核模块 Loadable Kernel Module</li></ul></li><li><p>引入内核会<strong>带来的问题</strong> </p><ul><li>内核所占用的内存是不会被换出来的，所以把新的模块链接进去会给整个系统带来一定的性能和内存利用方面的损失</li><li>装入内核的模块会成为内核的一部分，模块使用不当会导致系统崩溃</li><li>为了让内核的模块能够访问所有的内核资源，必须维护一个符号表，并且在装入和卸载模块的时候修改这个符号表<ul><li>模块之间可能会相互依赖，因此内核需要维护模块之间的依赖性    </li></ul></li></ul></li></ul><h1 id="操作系统2：进程-线程"><a href="#操作系统2：进程-线程" class="headerlink" title="操作系统2：进程/线程"></a>操作系统2：进程/线程</h1><h2 id="Chapter-3-Process-进程"><a href="#Chapter-3-Process-进程" class="headerlink" title="Chapter 3. Process 进程"></a>Chapter 3. Process 进程</h2><h3 id="3-1-进程的定义"><a href="#3-1-进程的定义" class="headerlink" title="3.1 进程的定义"></a>3.1 进程的定义</h3><ul><li><p>进程是一个在执行中的程序</p><ul><li>放在外存的程序就不是进程，进程可以理解为进行中的程序</li><li>是计算机工作的基本单位，和job，task，user program等概念相同</li><li>是一个包含了<strong>一系列指令和一些资源</strong>的容器<ul><li>是一个抽象实体，执行任务的时候，将要分配和释放各类资源</li></ul></li></ul></li><li><p>进程包括以下内容：</p><ul><li><p>程序代码(text section)</p></li><li><p>程序计数器 PC</p></li><li><p>寄存器</p></li><li><p>数据区，存储全局变量</p></li><li><p>栈区，存储临时变量</p></li><li><p>堆，<strong>动态分配</strong>的内存(C语言中的malloc)</p></li><li><p>在内存中的示例图</p><img src="image-20200928145028753.png" alt="image-20200928145028753" style="zoom:67%;" /></li></ul></li><li><p>进程的状态：</p><ul><li>几种状态<ul><li>new 新建，创建一个新进程</li><li>running 运行、执行：执行指令的状态</li><li>ready 就绪，准备好被分配给一个CPU执行</li><li>waiting 等待，等待一些事件结束后再执行</li><li>terminated 中止，执行结束</li></ul></li><li>会引起状态变化的操作：<ul><li>程序中的操作，比如系统调用</li><li>OS操作，比如调度的决策</li><li>外部操作，比如中断</li></ul></li><li>状态迁移的图解：</li></ul><img src="image-20200928150034677.png" alt="image-20200928150034677" style="zoom:67%;" /><ul><li>假设一个单CPU的计算机，OS进程有运行就绪等待三个状态，假设某个时刻该系统有10个进程并发执行：<ul><li>处于执行状态的最多有1个，处于就绪/等待状态的最多有9个</li></ul></li></ul></li></ul><h4 id="3-1-1-进程控制块-PCB"><a href="#3-1-1-进程控制块-PCB" class="headerlink" title="3.1.1 进程控制块 PCB"></a>3.1.1 进程控制块 PCB</h4><ul><li>每个进程在操作系统内用进程控制块来表示<ul><li>进程控制块PCB包含如下信息：进程状态，PC，CPU寄存器，调度信息，内存管理信息，accounting信息，文件管理，I/O统计信息</li><li>在Linux内核中，进程的信息用一个C语言中的结构<code>task_struct</code> 来表示，定义在头文件<code>&lt;linux/sched.h&gt;</code> 中，各个进程之间构成一个<strong>双向链表</strong> </li></ul></li></ul><h3 id="3-2-进程调度-Scheduling"><a href="#3-2-进程调度-Scheduling" class="headerlink" title="3.2 进程调度 Scheduling"></a>3.2 进程调度 Scheduling</h3><ul><li><p>调度队列：</p><ul><li>作业队列：系统中所有进程的队列</li><li>就绪队列：在内存中处于就绪状态得进程的队列</li><li>设备队列：等待I/O设备的进程的队列</li></ul></li><li><p>三种scheduler</p><ul><li><h2 id="作业题-进程调度需要将进程在ready、running、blocked三种状态之间切换"><a href="#作业题-进程调度需要将进程在ready、running、blocked三种状态之间切换" class="headerlink" title="(作业题)进程调度需要将进程在ready、running、blocked三种状态之间切换"></a>(作业题)进程调度需要将进程在ready、running、blocked三种状态之间切换</h2></li><li>长程调用/作业调度：现代操作系统已经没有使用长程调度了</li><li>短程调度：又叫CPU调度，选择下一个将要被CPU执行的进程</li><li>中程调度</li></ul></li><li><p>另一种分类方式：</p><ul><li>I/O型进程：主要事件花在IO上</li><li>CPU型进程：主要时间花在CPU处理上</li></ul></li><li><p>上下文切换：</p><ul><li><p>当<strong>切换到另一个进程的时候，系统必须要保留上一个进程的状态，同时又载入新进程的状态</strong></p></li><li><p>在PCB中表示</p></li><li><p>耗时取决于硬件的支持</p><img src="image-20200928153614151.png" alt="image-20200928153614151" style="zoom:67%;" /></li><li><p>A context switch occurs when the CPU switches from one process to another.</p></li></ul></li></ul><h3 id="3-3-进程操作-Process-Operation"><a href="#3-3-进程操作-Process-Operation" class="headerlink" title="3.3 进程操作 Process Operation"></a>3.3 进程操作 Process Operation</h3><h4 id="3-3-1-进程的创建"><a href="#3-3-1-进程的创建" class="headerlink" title="3.3.1 进程的创建"></a>3.3.1 进程的创建</h4><ul><li><p>父进程可以创建子进程，并可以形成一棵进程树，每个进程有唯一标识号pid</p><ul><li>pstree命令可以查看进程树</li></ul></li><li><p>fork：创建进程的系统调用</p><ul><li><code>int pid1 = fork();</code> <ul><li>事实上就是把当前进程分出了一个新的子进程，一个程序变成了两个进程，其中一个是父进程一个是子进程</li><li> 一个进程调用<code>fork()</code>函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己</li></ul></li><li>返回值是一个pid1，从系统调用fork中返回的时候，两个进程除了返回值pid1不同以外具有完全相同的用户级上下文，子进程中pid1为0，父进程中pid1的值就是子进程的pid</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pid1 <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid1 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Failed!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// chidren proccess</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// parant process</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="3-3-2-进程的终止"><a href="#3-3-2-进程的终止" class="headerlink" title="3.3.2 进程的终止"></a>3.3.2 进程的终止</h4><ul><li>引起进程终止的事件：<ul><li>正常结束、异常结束、外界干预</li><li><code>exit(0)</code> 退出进程</li></ul></li><li>系统调用wait()<ul><li>通过wait<strong>父进程可以等待子进程结束</strong>，wait调用会返回进程的状态信息和结束进程的pid<ul><li>这使得父进程可以等待并回收子进程的资源</li><li>父进程一旦调用了<code>wait()</code>就立即<strong>阻塞自己</strong>，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个子进程出现并结束为止</li></ul></li><li><strong>子进程中止而父进程尚未调用wait</strong>就会使得子进程变成一个僵尸进程(zombie process)</li><li>父进程中止而没有调用wait就会产生一个孤立进程(orphan process)</li></ul></li></ul><blockquote><p>安卓操作系统的进程重要度分级架构——优先中止最不重要的进程</p><ul><li>Foreground process 正在运行的进程</li><li>Visible process 可视化的UI组件等等</li><li>Service process 后台提供服务的进程</li><li>Background process </li><li>Empty process 空进程</li></ul></blockquote><h3 id="3-4-进程间通信-Interprocess-Communication"><a href="#3-4-进程间通信-Interprocess-Communication" class="headerlink" title="3.4 进程间通信 Interprocess Communication"></a>3.4 进程间通信 Interprocess Communication</h3><ul><li><p>进程的分类</p><ul><li>独立进程：不能被其他进程影响，也不能跟其他进程交互</li><li>合作进程：进程之间可以进行通信<ul><li>信息共享、方便性</li><li>计算加速</li></ul></li></ul></li><li><p>进程间通信 IPC</p><ul><li>通信分为直接通信和间接通信<ul><li>直接通信就是进程之间直接发送信息，间接就是还有中介，比如内存、邮箱共享等</li></ul></li><li>两种通信的模型：共享内存模型和消息模型</li></ul><img src="image-20201010150210783.png" alt="image-20201010150210783" style="zoom:50%;" /><ul><li>常用的通信机制：    <ul><li>信号 signal</li><li>共享存储区 shared memory</li><li>管道 pipe</li><li>消息 message</li><li>套接字 socket</li><li>是个操作系统都有的通信机制：信号量、消息队列、共享内存</li><li>在Linux操作系统中，还有：<ul><li>文件锁 file lock 问题是速度很慢，因为文件是磁盘I/O</li><li>POSIX线程：互斥锁(mutex)，条件变量 </li></ul></li></ul></li></ul></li><li><p>Windows 的进程间通信</p><ul><li>信号：一系列Windows API</li><li>文件映射机制：可以将整个文件映射为进程虚拟地址空间的一部分来加以访问</li><li>无名管道：类似于UNIX的管道，与此相对的Windows还有命名管道</li><li>邮件槽 mailslot</li><li>剪贴板 Clipboard：暂时保存了一些文本</li></ul></li></ul><h3 id="具体的栗子"><a href="#具体的栗子" class="headerlink" title="具体的栗子"></a>具体的栗子</h3><ul><li><p>有限缓冲区Bounded-Buffer，缓冲区的大小有上限</p><ul><li>生产者-消费者问题：生产者进程制造出新信息，消费者使用新的信息</li><li>用类似于<strong>循环队列</strong>的数据结构控制内存的访问</li></ul></li><li><p>消息传送：分为阻塞的和非阻塞的(block &amp; unblock)</p><ul><li>阻塞的消息传递：同步的<ul><li>send需要发送方阻塞直到消息被接收</li><li>receive需要接收方阻塞直到有消息送到</li></ul></li><li>非阻塞的消息传递：异步的<ul><li>发送方发送之后直接继续，接收方不断接受到有效/无效的消息</li></ul></li></ul></li><li><p>Socket 作为交流的endpoint</p><ul><li>Socket中包含了IP地址和端口，端口是一个包含了数据包起点的数字<ul><li>标号为1024以下的端口是常用端口，用来提供标准服务</li><li>特殊的IP地址127.0.0.1表示正在运行进程的系统</li></ul></li><li>交流需要通过一系列的Socket来实现</li></ul></li></ul><h2 id="Chapter-4：Thread-amp-Concurrency-线程和并发"><a href="#Chapter-4：Thread-amp-Concurrency-线程和并发" class="headerlink" title="Chapter 4：Thread &amp; Concurrency 线程和并发"></a>Chapter 4：Thread &amp; Concurrency 线程和并发</h2><h3 id="4-1-Overview"><a href="#4-1-Overview" class="headerlink" title="4.1 Overview"></a>4.1 Overview</h3><ul><li><p>进程是资源的拥有单位和调度(Dispatching)单位</p><ul><li>进程由虚拟地址空间，控制一些资源，有状态、优先级和调度</li><li>进程是由一个或者多个程序的一次支持，可以和其他进程交替执行</li></ul></li><li><p>线程thread</p><ul><li><p>资源拥有单元称为进程，<strong>调度的单位称为线程</strong>，也叫做轻型进程LWP</p><ul><li>一个传统进程，或者叫重型进程HWP和线程中的一个任务等价</li><li>线城市进程内的一个执行单元或者一个可调度的实体</li></ul></li><li><p>线程只拥有必要的资源，但是可以和同一个进程下的其他线程共享进程拥有的全部资源</p></li><li><h2 id="线程的特点："><a href="#线程的特点：" class="headerlink" title="线程的特点："></a><strong>线程的特点：</strong></h2><ul><li>有执行状态</li><li>不运行时，保存上下文</li><li>有一个执行栈</li><li>有局部变量的静态存储</li><li>可以取所在进程的资源，但是<strong>不拥有系统资源</strong> <ul><li>同一个进程下面的进程还共享代码段和数据段</li></ul></li><li>可以创建、撤销另一个进程</li><li>一个进程中的多个线程可以并发执行，系统开销小，切换快</li></ul></li></ul><img src="image-20201012141925355.png" alt="image-20201012141925355" style="zoom:50%;" /><ul><li>线程带来的benifits    <ul><li>创建线程、线程之间切换的时间比较少</li><li>共享了内存和文件，线程之间的通信不需要经过内核</li></ul></li><li>多核情况下的线程并行</li></ul><img src="image-20201012144357261.png" alt="image-20201012144357261" style="zoom:50%;" /></li></ul><h3 id="4-2-多线程模型"><a href="#4-2-多线程模型" class="headerlink" title="4.2 多线程模型"></a>4.2 多线程模型</h3><ul><li><p>用户级线程和内核级线程</p><ul><li>用户级线程<ul><li>不依赖于OS内核，应用进程利用线程库提供创建、同步、调度和管理的函数来控制用户线程<ul><li>即用户线程的维护由应用进程来完成</li><li>内核<strong>不了解用户线程的存在</strong> </li><li>用户线程切换不需要内核特权</li><li>一个线程发起系统调用而阻塞，则整个进程在等待</li></ul></li><li>常见的线程库：POSIX pthreads库， win32 threads， Java threads</li></ul></li><li>内核级线程<ul><li>依赖于OS内核，由内核的内部需求进行创建和撤销，用来执行一个指定的函数。一个线程发起系统调用而阻塞，不会影响其他线程。时间片分配给线程，所以多线程的进程获得更多CPU时间<ul><li>内核维护进程和线程的上下文信息</li><li>线程的切换由内核完成</li><li>时间片分配给线程，所以多线程的进程获得更过CPU时间</li><li>一个线程发起系统调用而阻塞，不会影响其他线程</li></ul></li></ul></li></ul></li><li><p>线程模型</p><ul><li><p>多对一模型：内核一个线程，用户多个线程，好处是不需要OS的支持    </p><ul><li>可以使用调度策略来优化，但是在多处理器中不适用</li></ul><img src="image-20201012145445814.png" alt="image-20201012145445814" style="zoom:50%;" /></li><li><p>一对一模型：每个用户线程对应一个内核线程</p><ul><li>每个内核线程独自调度，由OS进行一系列线程操作</li></ul><img src="image-20201012145427840.png" alt="image-20201012145427840" style="zoom:50%;" /></li><li><p>多对多模型：每个用户线程对应多个内核线程</p></li></ul></li></ul><h3 id="4-3-Implicit-Threading（隐私多线程）"><a href="#4-3-Implicit-Threading（隐私多线程）" class="headerlink" title="4.3 Implicit Threading（隐私多线程）"></a>4.3 Implicit Threading（隐私多线程）</h3><ul><li>隐私线程：将线程的创建和管理交给编译器和运行时库来完成<ul><li>常见的方法有：Thread Pools 线程池<ul><li>创建一系列线程等待工作</li></ul></li><li>这里好像讲的比较随意，估计是不太重要</li></ul></li></ul><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ul><li>process scheduler可以切换ready running和blocked三种状态</li><li><strong>线程控制块 TCB</strong> 存储的内容包括machine states，包括寄存器和程序计数器，实际上就是存储了线程拥有的资源</li><li>抢占式多任务系统 preemptive multitasking system<ul><li>一个进程在运行随时可能被另一个进程抢占</li><li>running到ready是有效的切换</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构基础</title>
      <link href="2021/05/03/ds/"/>
      <url>2021/05/03/ds/</url>
      
        <content type="html"><![CDATA[<h1 id="Data-Structure-Final-Review"><a href="#Data-Structure-Final-Review" class="headerlink" title="Data Structure Final Review"></a>Data Structure Final Review</h1><h4 id="RandomStar-in-2020-01"><a href="#RandomStar-in-2020-01" class="headerlink" title="RandomStar in 2020.01"></a>RandomStar in 2020.01</h4><h2 id="Chapter-1-Introduction-and-Algorithm-Analysis"><a href="#Chapter-1-Introduction-and-Algorithm-Analysis" class="headerlink" title="Chapter 1 Introduction and Algorithm Analysis"></a>Chapter 1 Introduction and Algorithm Analysis</h2><ul><li>算法的几个要素：输入，输出，明确性(Definiteness)，有穷性(Finiteness)，高效性(Effectiveness)</li></ul><h3 id="1-1-时间复杂度和空间复杂度"><a href="#1-1-时间复杂度和空间复杂度" class="headerlink" title="1.1 时间复杂度和空间复杂度"></a>1.1 时间复杂度和空间复杂度</h3><ul><li>几个基本的运算规则<ul><li>顺序结构：直接相加</li><li>循环中：复杂度=一次循环的复杂度x循环次数</li><li>嵌套循环中：循环规模的乘积x一次循环的复杂度</li><li>if/else语句：选其中复杂度最高的</li></ul></li></ul><h3 id="1-2-最大子列和问题的分析"><a href="#1-2-最大子列和问题的分析" class="headerlink" title="1.2 最大子列和问题的分析"></a>1.2 最大子列和问题的分析</h3><ul><li><p>算法1：使用3层嵌套循环直接计算，复杂度为$O(N^3)$ </p></li><li><p>算法2：使用两层循环并设置标记位，复杂度为$O(N^2)$ </p></li><li><p>算法3：使用归并的方法(这一部分PPT上的代码比较复杂，可以好好看看)，复杂度为$O(N\lg N)$ </p></li><li><p>算法4：一种在线算法，复杂度时线性的，代码如下</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int MaxSubsequenceSum(int A[],int N) &#123;    int ThisSum &#x3D; 0,MaxSum &#x3D; 0,j;    for(j &#x3D; 0; j &lt; N; j++) &#123;        ThisSum +&#x3D; A[j];        if(ThisSum &gt; MaxSum)            MaxSum &#x3D; ThisSum;       else if(ThisSum &lt; 0)            ThisSum &#x3D; 0;    &#125;    return MaxSum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Chapter-2-Linked-List-Stacks-and-Queues"><a href="#Chapter-2-Linked-List-Stacks-and-Queues" class="headerlink" title="Chapter 2 Linked List, Stacks and Queues"></a>Chapter 2 Linked List, Stacks and Queues</h2><h3 id="2-1-List的抽象数据结构-ADT"><a href="#2-1-List的抽象数据结构-ADT" class="headerlink" title="2.1 List的抽象数据结构(ADT)"></a>2.1 List的抽象数据结构(ADT)</h3><ul><li>包含如下操作：<ul><li>获得长度</li><li>打印列表</li><li>清空</li><li>查询一个元素</li><li>插入删除</li><li>找到下一个</li><li>找最值</li></ul></li></ul><h4 id="2-1-1-Array-List"><a href="#2-1-1-Array-List" class="headerlink" title="2.1.1 Array List"></a>2.1.1 Array List</h4><ul><li>需要估计好数组的最大长度，找第K个元素的时间复杂度是<strong>常数级别</strong>的，而插入和删除的时间复杂度是$O(N)$ </li></ul><h4 id="2-1-2-Linked-List"><a href="#2-1-2-Linked-List" class="headerlink" title="2.1.2 Linked List"></a>2.1.2 Linked List</h4><ul><li><p>插入和删除消耗<strong>常数时间</strong>，而查询第K个的时间复杂度是$O(N)$ </p></li><li><p>⭐链表的冒泡排序</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">List BubbleSort(List L)&#123;    if(L-&gt;Next &#x3D;&#x3D; NULL || L-&gt;Next-&gt;Next &#x3D;&#x3D; NULL)        return L;    List p &#x3D; L;    while(p-&gt;Next-&gt;Next !&#x3D; NULL) &#123;        if(p-&gt;Next-&gt;key &gt; p-&gt;Next-&gt;Next-&gt;Key) &#123;            List q &#x3D; p-&gt;Next;            p-&gt;Next &#x3D; q-&gt;Next;            q-&gt;Next &#x3D; p-&gt;Next-&gt;Next;            p-&gt;Next-&gt;Next &#x3D; q;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2-2-栈Stack"><a href="#2-2-栈Stack" class="headerlink" title="2.2 栈Stack"></a>2.2 栈Stack</h3><ul><li>是一个LIFO的列表(Last-in-First-out)</li><li>支持这样一些操作<ul><li>Push 将一个元素添加到栈的末尾</li><li>Pop 弹出栈的末尾元素</li></ul></li></ul><h3 id="2-3-队列-Queue"><a href="#2-3-队列-Queue" class="headerlink" title="2.3 队列 Queue"></a>2.3 队列 Queue</h3><ul><li>是一种FIFO的列表(First-in-First-out)</li><li>支持如下操作<ul><li>Enqueue 将元素添加到队列的末尾</li><li>Dequeue 将位于队列最前面的元素弹出</li></ul></li></ul><h2 id="chapter-3-Trees"><a href="#chapter-3-Trees" class="headerlink" title="chapter 3 Trees"></a>chapter 3 Trees</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><ul><li>树是一系列结点构成的(也可以为空) 并且包含<ul><li>一个根节点r</li><li>若干和r相连的子树(subtree)</li><li>一个N个节点的树一定有N-1条边</li></ul></li><li>几个树中的基本概念<ul><li>父节点，子节点，同辈节点，叶节点</li><li>节点的度数：节点子树的个数，空节点的度数为0</li><li>树的度数：节点度数的最大值</li><li>祖先ancestors ：所有拥有通往这个节点路径的节点</li><li>后代decendants：这个节点子树中的所有节点，不包含自己</li><li>深度depth 从根节点到当前节点的路径长度，根节点的深度为0</li><li>高度height 从叶节点到当前节点路径的最大长度，叶节点的高度为0，空节点的高度为-1</li></ul></li></ul><h3 id="3-2-二叉树-Binary-Tree"><a href="#3-2-二叉树-Binary-Tree" class="headerlink" title="3.2 二叉树 Binary Tree"></a>3.2 二叉树 Binary Tree</h3><ul><li><p>每一个节点最多有2个子节点的树叫做二叉树</p></li><li><p>二叉树的遍历：</p><ul><li>前序遍历：按照上左右的顺序递归地遍历</li><li>中序遍历：按照左上右的顺序递归地遍历</li><li>后序遍历：按照左右上的顺序递归地遍历</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">void PreOrder(Tree T)&#123;if(T &#x3D;&#x3D; NULL) return;printf(&quot;%d &quot;,T-&gt;Value);    PreOrder(T-&gt;Left);    PreOrder(T-&gt;Right);&#125;void InOrder(Tree T)&#123;    if(T &#x3D;&#x3D; NULL) return;    InOrder(T-&gt;Left);    printf(&quot;%d &quot;,T-&gt;Value);    InOrder(T-&gt;Right);&#125;void PostOrder(Tree T)&#123;    if(T &#x3D;&#x3D; NULL) return;    PostOrder(T-&gt;Left);    PostOrder(T-&gt;Right);    printf(&quot;%d &quot;,T-&gt;Value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>二叉树的性质：</p><ul><li>第i层上最多可以用$2^{i-1}$个节点</li><li>深度为K的二叉树最多拥有$2^k-1$个节点 </li></ul></li></ul><h3 id="3-3-二叉搜索树BST"><a href="#3-3-二叉搜索树BST" class="headerlink" title="3.3 二叉搜索树BST"></a>3.3 二叉搜索树BST</h3><ul><li><p>定义：</p><ul><li>左子树的键值都不超过根节点</li><li>右子树的键值都大于根节点</li><li>左右子树都是二叉搜索树</li><li>只有一个节点的树和空树是二叉搜索树</li></ul></li><li><p>二叉搜索树的几个基本操作</p><ul><li>查找一个键值：递归地进行查询，比要查的小查右边，比要查的大查左边</li><li>找到最小/最大的键值：直接找最左边的或者最右边的节点</li><li>插入：先查找键值，找到合适的位置在进行插入</li><li>以上三个操作的时间复杂度都是$O(h)$ 而h是树的高度，最好情况下$h=O(\log N)$</li></ul></li></ul><h2 id="Chapter-4-Heaps-Priority-Queues"><a href="#Chapter-4-Heaps-Priority-Queues" class="headerlink" title="Chapter 4: Heaps(Priority Queues)"></a>Chapter 4: Heaps(Priority Queues)</h2><ul><li><p>二叉堆</p><ul><li><p>实现方式：一棵用数组表示的完全二叉树</p><ul><li>完全二叉树的特点：1-H-1层的节点是满的，第H层的节点从左边开始依次放置没有空的，其中H是整棵树的高度</li><li>高度为H的完全二叉树有$[2^H,2^{H+1}-1]$ 个节点</li></ul></li><li><p>二叉堆的性质：</p><ul><li>对于下标为K的节点，其父节点的下标是K/2，其子节点的下标是2K和2K+1</li><li>分为最小堆和最大堆两种<ul><li>最小堆，所有的父节点中的值都要小于子节点</li><li>最大堆，所有的父节点中的值要大于子节点</li></ul></li></ul></li><li><p>堆的几种操作：</p><ul><li>插入：向下调整到合适的位置</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">void Insert(PriorityHeap H, int X) &#123;    int i;    if(IsFull(H) &#x3D;&#x3D; 1) return;    else &#123;        H-&gt;size++;        for(i &#x3D; H-&gt;size; H-&gt;Elements[i&#x2F;2] &gt; X; i&#x3D;i&#x2F;2)            H-&gt;Elements[i] &#x3D; H-&gt;Elements[i&#x2F;2];       H-&gt;Element[i]&#x3D;X;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除最小值(最小堆)：直接删除根节点，向上调整</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">DeleteMin</span><span class="token punctuation">(</span>PriorityHeap H<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> child<span class="token punctuation">,</span> Min<span class="token punctuation">,</span> Last<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> H<span class="token operator">-></span>Element<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        Min <span class="token operator">=</span> H<span class="token operator">-></span>Element<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Last <span class="token operator">=</span> H<span class="token operator">-></span>Element<span class="token punctuation">[</span>H<span class="token operator">-></span>size<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">&lt;=</span> H<span class="token operator">-></span>size<span class="token punctuation">;</span> i <span class="token operator">=</span> child<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            child <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">!=</span> H<span class="token operator">-></span>size <span class="token operator">&amp;&amp;</span> H<span class="token operator">-></span>Element<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> H<span class="token operator">-></span>Element<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>                child<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Last <span class="token operator">></span> H<span class="token operator">-></span>Element<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>                H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Last<span class="token punctuation">;</span>        <span class="token keyword">return</span> Min<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>一个常见的应用：找数组中第K小的元素</p><ul><li>将数组插入一个最小堆中，不断deletemin，K次之后的删除的值就是数组中第K小的元素</li></ul></li></ul><h2 id="Chapter-5-Disjoint-Set"><a href="#Chapter-5-Disjoint-Set" class="headerlink" title="Chapter 5: Disjoint Set"></a>Chapter 5: Disjoint Set</h2><ul><li><p>等价类的定义：一个定义在集合S上的关系是一个等价关系当且仅当它具有兑成性，自反性和传递性</p></li><li><p>并查集的操作</p><ul><li>Union 操作：普通的union，根据size/height进行union<ul><li>负数表示这个节点是根节点，并且负数的绝对值表示其元素个数</li><li>正数表示当前下标的数据的根节点的编号</li></ul></li><li>Find 操作</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span>DisjSet S<span class="token punctuation">,</span><span class="token keyword">int</span> root1<span class="token punctuation">,</span><span class="token keyword">int</span> root <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    S<span class="token punctuation">[</span>root1<span class="token punctuation">]</span><span class="token operator">=</span>root2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span>DisjSet S<span class="token punctuation">,</span><span class="token keyword">int</span> X<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>X<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        X <span class="token operator">=</span> S<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> X<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>路径压缩：每次合并直接连接到根上面，避免路径过长</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int Find(DisjSet S, int X)&#123;    if(S[X] &lt;&#x3D; 0) return X;    else return S[X] &#x3D; Find(S,S[X]);&#125;&#x2F;&#x2F;Another Methodint Find(DisjSet S, int  X)&#123;    int root,train,lead;    for(root &#x3D; X, S[root] &gt; 0;X &#x3D; S[root]);    for(trail &#x3D; X; trail !&#x3D; root;trail &#x3D; lead)    &#123;        lead &#x3D; S[trail];        S[trail] &#x3D; root;    &#125;    return root;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>根据大小来合并：将小的合并到大的上面去</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">void Union(DisjSet S,int root1,int root 2)&#123;    if(S[root1] &lt;&#x3D; S[root2]) &#x2F;&#x2F;root1 is larger    &#123;        S[root1] +&#x3D; S[root2];        S[root2] &#x3D; root1; &#x2F;&#x2F;insert root2 to root 1    &#125; else &#123;        S[root2] +&#x3D; S[root1];        S[root1] &#x3D; root2;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Chpater-6-Graph"><a href="#Chpater-6-Graph" class="headerlink" title="Chpater 6: Graph"></a>Chpater 6: Graph</h2><h3 id="6-1-图的基本概念"><a href="#6-1-图的基本概念" class="headerlink" title="6.1 图的基本概念"></a>6.1 图的基本概念</h3><ul><li>有向图/无向图：区别在于边是否有方向</li><li>完全图：图中的所有节点两两相连，对于N个点有N(N+1)/2条边</li><li>子图G‘：顶点和边都是图G的子集</li><li>路径、路径的长度<ul><li>路径分为简单路径和环两种</li></ul></li><li>连通分量：图G的一个最大连通子图</li><li>强连通有向图：任意两个顶点之间存在有向的路径可以到达</li><li>顶点V的度数<ul><li>有向图中分为出度和入度</li><li>总而言之表示这个顶点所在的边的数量，其中有向图还区分出去的边和进入的边</li></ul></li></ul><h3 id="6-2-拓扑排序"><a href="#6-2-拓扑排序" class="headerlink" title="6.2 拓扑排序"></a>6.2 拓扑排序</h3><ul><li>定义：<ul><li>拓扑逻辑顺序是顶点的一种线性排列，如果存在顶点i指向顶点j的边，那么拓扑排序中i一定出现在j的前面</li><li>只有有向无环图才有拓扑排序，并且可能不唯一</li></ul></li><li>实现拓扑排序的算法</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define INF 123456789int TopNum[Max];void TopSort(Graph G)&#123;    int Q[Max], rear, front, counter;    rear &#x3D; 0;    front &#x3D; 0;    counter &#x3D; 0;    int v, w, i, j;    &#x2F;&#x2F;Find the head vertices    for (v &#x3D; 0; v &lt; G-&gt;Nv; v++)    &#123;        if (Indegree[v] &#x3D;&#x3D; 0)            Q[rear++] &#x3D; v;    &#125;    while (rear - front !&#x3D; 0)    &#123;        v &#x3D; Q[front++];        TopNum[v] &#x3D; ++counter;        for (w &#x3D; 0; w &lt; G-&gt;nv; w++)        &#123;            if (G[v][w] !&#x3D; INF)            &#123;                Indegree[w]--;                if (Indegree[w] &#x3D;&#x3D; 0)                    Q[rear++] &#x3D; w;            &#125;        &#125;    &#125;    if (counter !&#x3D; G-&gt;Nv)        return; &#x2F;&#x2F; The graph has a circle&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-最短路径算法-Dijkstra-Algorithm"><a href="#6-3-最短路径算法-Dijkstra-Algorithm" class="headerlink" title="6.3 最短路径算法 Dijkstra Algorithm"></a>6.3 最短路径算法 Dijkstra Algorithm</h3><ul><li>基本的思路：<ul><li>在未访问的顶点中，寻找一个和目标距离最短的顶点V</li><li>如果没有找到，就停止，如果找到了，将V标记位已访问</li><li>对所有和V相邻的节点W，更新最多路径距离的值</li></ul></li><li>代码实现</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">void Dijkstra(MGraph Graph, int dist[], Vertex S)&#123;    &#x2F;&#x2F;count[MAX] means the number of shortest paths,count[S]&#x3D;1;    int visit[MAX] &#x3D; &#123;0&#125;, i, j;    int n &#x3D; Graph-&gt;Nv;    for (i &#x3D; 0; i &lt; n; i++)        dist[i] &#x3D; INF;    dist[S] &#x3D; 0;    for (;;)    &#123;        int u &#x3D; -1, v, min &#x3D; INF;        for (i &#x3D; 0; i &lt; n; i++)        &#123;            if (dist[i] &lt; min &amp;&amp; visit[i] &#x3D;&#x3D; 0)            &#123;                min &#x3D; dist[i];                u &#x3D; i;            &#125;        &#125;        if (u &#x3D;&#x3D; -1)            break;        visit[u] &#x3D; 1;        for (v &#x3D; 0; v &lt; n; v++)        &#123;            if (Graph-&gt;G[u][v] &lt; INF &amp;&amp; visit[v] &#x3D;&#x3D; 0)            &#123;                if (dist[v] &gt; dist[u] + Graph-&gt;G[u][v])                    dist[v] &#x3D; dist[u] + Graph-&gt;G[u][v];                &#x2F;&#x2F;count[v]&#x3D;count[u];                &#x2F;&#x2F;path[v]&#x3D;u;                &#x2F;&#x2F;if(dist[v]&#x3D;&#x3D;dist[u]+Graph-&gt;G[u][v])                &#x2F;&#x2F;count[v]+&#x3D;count[u];            &#125;        &#125;    &#125;    for (i &#x3D; 0; i &lt; n; i++)        if (dist[i] &#x3D;&#x3D; INF)            dist[i] &#x3D; -1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>算法的时间复杂度是$O(|V|^2+|E|)$ </li></ul><h3 id="6-4-网络流-Network-Flow"><a href="#6-4-网络流-Network-Flow" class="headerlink" title="6.4 网络流 Network Flow"></a>6.4 网络流 Network Flow</h3><ul><li><p>目标：在图G中找到从s出发到t的最大流，步骤如下</p><ul><li>在G中找到一条从s到t的路径</li><li>将这条路径的最短边长从每一条边中减去，并将这个数值加入结果中</li><li>更新图G并删除长度为0的边</li><li>重复上述步骤直到不存在s到t的路径</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> minlen<span class="token operator">=</span>INF<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">maxflow</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>result<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">search</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>e<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>e<span class="token punctuation">;</span>i<span class="token operator">!=</span>s<span class="token punctuation">;</span>i<span class="token operator">=</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>minlen<span class="token punctuation">)</span>                minlen<span class="token operator">=</span>G<span class="token punctuation">[</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>e<span class="token punctuation">;</span>i<span class="token operator">!=</span>s<span class="token punctuation">;</span>i<span class="token operator">=</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            G<span class="token punctuation">[</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-=</span>minlen<span class="token punctuation">;</span>            G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span>minlen<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        result<span class="token operator">+=</span>minlen<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> v<span class="token punctuation">,</span>i<span class="token punctuation">;</span>    rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    front<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>visit<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>visit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">[</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">;</span>    rear<span class="token operator">++</span><span class="token punctuation">;</span>    visit<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>rear<span class="token operator">-</span>front<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        v<span class="token operator">=</span>q<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        front<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>visit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                q<span class="token punctuation">[</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>                rear<span class="token operator">++</span><span class="token punctuation">;</span>                visit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>算法的时间复杂度是$O(|E|^2\log |V|)$ </p></li></ul><h3 id="6-5-最小生成树和DFS"><a href="#6-5-最小生成树和DFS" class="headerlink" title="6.5 最小生成树和DFS"></a>6.5 最小生成树和DFS</h3><ul><li><p>DFS的基本模式：从一个顶点V开始，遍历所有和V相邻并且未访问的顶点，需要递归地进行</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void DFS(Vertex v)&#123;    visit[V]&#x3D;1;    int w;    for(w&#x3D;0;w&lt;n;w++) &#123;        if(visit[w] &#x3D;&#x3D; 0 &amp;&amp; G[v][u] &lt; INF)            DFS(w);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>一个基本的应用：找连通分量</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">void ListComponents(Graph G)&#123;    for each v in G        if(visit[v]&#x3D;&#x3D;0) &#123;            DFS(v);            printf(&quot;\n&quot;);        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Prim算法和Kruskal算法都是贪心算法</p><ul><li>具体的算法看PPT就可以了，一种是DFS的算法，一种是BFS的算法</li></ul></li></ul><h3 id="6-6-一些历年卷里难以判断的题目"><a href="#6-6-一些历年卷里难以判断的题目" class="headerlink" title="6.6 一些历年卷里难以判断的题目"></a>6.6 一些历年卷里难以判断的题目</h3><ul><li><p>图论中一些难以判断的结论（都是对的）</p><ul><li>If <code>e</code> is the only shortest edge in the weighted graph G, then <code>e</code> must be in the minimum spanning tree of G.</li><li>If the BFS sequence of a graph is <code>1 2 3 4 ...</code>, and if there is an edge between vertices 1 and 4, then there must be an edge between the vertices 1 and 3.</li><li>In a directed graph G with at least two vertices, if DFS from any vertex can visit every other vertices, then the topological order must NOT exist.</li><li>Suppose that a graph is represented by an adjacency matrix. If there exist non-zero entries in the matrix, yet all the entries below the diagonal are zeros, then this graph must be a directed graph.</li><li>欧拉回路/欧拉路径：遍历图G中的每一条路径<ul><li>无向图存在欧拉回路，当且仅当该图的所有顶点度数都为偶数且连通</li><li>有向图存在欧拉回路，当且仅当所有的出度等于入度且图要连通</li></ul></li><li>哈密顿路径/哈密顿回路：恰好通过图G的每个节点一次</li></ul></li><li><p>Kruskal’s algorithm is to grow the minimum spanning tree by adding one edge, and thus an associated vertex, to the tree in each stage. （<strong>FALSE</strong>）</p></li><li><p>关于拓扑逻辑排序</p><ul><li>If a graph has a topological sequence, then its adjacency matrix must be triangular.<ul><li>错的，在无向图中不一定</li></ul></li><li>If <em>Vi</em> precedes <em>Vj</em> in a topological sequence, then there must be a path from <em>Vi</em> to <em>Vj</em>.<ul><li>错的，不一定有</li></ul></li><li>If the adjacency matrix is triangular, then the corresponding directed graph must have a unique topological sequence.<ul><li>错的，可以举出反例</li></ul></li><li>In a DAG, if for any pair of distinct vertices <em>Vi</em> and <em>Vj</em>, there is a path either from <em>Vi</em> to <em>V**j</em> or from <em>Vj</em> to <em>Vi</em>, then the DAG must have a unique topological sequence.<ul><li>对的</li></ul></li></ul></li></ul><h2 id="Chapter-7-Sort"><a href="#Chapter-7-Sort" class="headerlink" title="Chapter 7: Sort"></a>Chapter 7: Sort</h2><h3 id="7-1-插入排序"><a href="#7-1-插入排序" class="headerlink" title="7.1 插入排序"></a>7.1 插入排序</h3><ul><li><p>最好的情况是$O(N)$ 最坏的情况是$O(N^2)$ </p><ul><li>N个元素中的平均inversion个数为$I=\frac{N(N+1)}{4}$ 并且时间复杂度为$O(I+N)$ </li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InsertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j<span class="token punctuation">,</span> p<span class="token punctuation">,</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> p <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> p<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="7-2-希尔排序"><a href="#7-2-希尔排序" class="headerlink" title="7.2 希尔排序"></a>7.2 希尔排序</h3><ul><li><p>定义一系列间隔，每次按照间隔进行排序，并且每一轮的间隔不断减小，直到变成1</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> increment<span class="token punctuation">,</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>increment <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> increment <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> increment <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> increment<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> increment<span class="token punctuation">;</span> j <span class="token operator">-=</span> increment<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> increment<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> increment<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>最差的时间复杂度依然是平方级别的</li></ul></li></ul><h3 id="7-3-堆排序"><a href="#7-3-堆排序" class="headerlink" title="7.3 堆排序"></a>7.3 堆排序</h3><ul><li><p>用建堆+delete max操作来进行排序，时间复杂度为$O(N\lg N)$ </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">leftchild</span><span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token comment">//different from traditonal heap,a[] start from index 0;</span><span class="token keyword">void</span> <span class="token function">PercDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> child<span class="token punctuation">,</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">leftchild</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">=</span> child<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        child <span class="token operator">=</span> <span class="token function">leftchild</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">!=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>            child<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">)</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">//build heap</span>        <span class="token function">PrecDown</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token function">PercDown</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="7-4-归并排序"><a href="#7-4-归并排序" class="headerlink" title="7.4 归并排序"></a>7.4 归并排序</h3><ul><li><p>将数组分成两路进行排序然后将两个数组合并成一个，时间复杂度是$O(N\lg N)$</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void MSort(int a[], int tmp[], int left, int right)&#123;    int center &#x3D; (left + right) &#x2F; 2;    if (left &lt; right)    &#123;        MSort(a, tmp, left, center);        Msort(a, tmp, center + 1, right);        Merge(a, tmp, left, center + 1, right);    &#125;&#125;void MergeSort(int a, int n)&#123;    int tmp[Max];    Msort(a, tmp, 0, n - 1);    &#x2F;&#x2F;need O(n) extra space&#125;void Merge(int a[], int tmp[], int lpos, int rpos, int rightend)&#123;    int i, leftend, num, tmppos;    leftend &#x3D; rpos - 1;    tmppos &#x3D; lpos;    num &#x3D; rightend - lpos + 1;    while (lpos &lt;&#x3D; leftend &amp;&amp; rpos &lt;&#x3D; rightend)    &#123;        if (a[lpos] &lt;&#x3D; a[rpos])            tmp[tmppos++] &#x3D; a[lpos++];        else            tmp[tmppos++] &#x3D; a[rpos++];    &#125;    while (lpos &lt;&#x3D; leftend)        tmp[tmppos++] &#x3D; a[lpos++];    while (rpos &lt;&#x3D; rightend)        tmp[tmppos++] &#x3D; a[rpos++];    for (i &#x3D; 0; i &lt; num; i++, rightend--)        a[rightend] &#x3D; tmp[rightend];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一种迭代式的实现方式</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">merge_pass</span><span class="token punctuation">(</span>ElementType list<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ElementType sorted<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>ElementType list<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ElementType extra<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* the extra space required */</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">/* current length of sublist being merged */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;</span> N<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">merge_pass</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> extra<span class="token punctuation">,</span> N<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* merge list into extra */</span>        <span class="token function">output</span><span class="token punctuation">(</span>extra<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>        length <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">merge_pass</span><span class="token punctuation">(</span>extra<span class="token punctuation">,</span> list<span class="token punctuation">,</span> N<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* merge extra back to list */</span>        <span class="token function">output</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>        length <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">merge_pass</span><span class="token punctuation">(</span>ElementType list<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ElementType sorted<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> length<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>        x <span class="token operator">=</span> i<span class="token punctuation">;</span>        y <span class="token operator">=</span> i <span class="token operator">+</span> length<span class="token punctuation">;</span>        z <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> i <span class="token operator">+</span> length <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> length <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&lt;</span> list<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>                sorted<span class="token punctuation">[</span>z<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>x<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                sorted<span class="token punctuation">[</span>z<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>y<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> i <span class="token operator">+</span> length<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> i <span class="token operator">+</span> length<span class="token punctuation">)</span>                sorted<span class="token punctuation">[</span>z<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>x<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> length<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> length<span class="token punctuation">)</span>                sorted<span class="token punctuation">[</span>z<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>y<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-5-快速排序：已知的最快排序方式"><a href="#7-5-快速排序：已知的最快排序方式" class="headerlink" title="7.5 快速排序：已知的最快排序方式"></a>7.5 快速排序：已知的最快排序方式</h3><ul><li>需要选择一个pivot，每次将比pivot效地放到左边，大的放到右边<ul><li>最坏的复杂度依然时平方复杂度，但是最优的复杂度是$O(N\lg N)$，并且平均复杂度是$O(N\lg N)$</li><li>一个结论：基于比较的排序方法的时间复杂度至少是$O(N\lg N)$级别的</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">median3</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> center <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> center<span class="token punctuation">)</span>        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>center<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>center<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>center<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//these steps makes a[left]&lt;=a[center]&lt;=a[right]</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>center<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//hide pivot</span>        <span class="token comment">//only need to sort a[left+1]~ a[right-2]</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span>right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Qsort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> pivot<span class="token punctuation">;</span>    pivot <span class="token operator">=</span> <span class="token function">median3</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span> <span class="token operator">></span> pivot<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>            <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Qsort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Qsort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Qsort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-6-桶排序，基数排序"><a href="#7-6-桶排序，基数排序" class="headerlink" title="7.6 桶排序，基数排序"></a>7.6 桶排序，基数排序</h3><ul><li>桶排序：时间换空间的经典方法</li><li>基数排序：用Least Significant Digit first(LSD)的方法进行排序<ul><li>具体的可以看PPT怎么进行操作</li></ul></li></ul><h3 id="7-7-总结："><a href="#7-7-总结：" class="headerlink" title="7.7 总结："></a>7.7 总结：</h3><h4 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h4><ul><li>不稳定的排序：堆排序，快速排序，希尔排序，直接选择排序</li><li>稳定的排序：基数排序，冒泡排序，插入排序，归并排序</li></ul><h4 id="数组排序呈现的特征"><a href="#数组排序呈现的特征" class="headerlink" title="数组排序呈现的特征"></a>数组排序呈现的特征</h4><ul><li>堆排序：一般没什么特征</li><li>归并排序：排序中会出现连续若干个数字已经排好了顺序</li><li>快速排序：有一些数，前面的都比这个数小，后面的都比他大，具体要看run了多少次</li><li>选择排序：每一次都会选出最大或者最小的数排在最后应该出现的位置</li></ul><h2 id="Chapter-8-Hash"><a href="#Chapter-8-Hash" class="headerlink" title="Chapter 8: Hash"></a>Chapter 8: Hash</h2><h3 id="8-1-定义和基本概念"><a href="#8-1-定义和基本概念" class="headerlink" title="8.1 定义和基本概念"></a>8.1 定义和基本概念</h3><ul><li>哈希函数f(x)的结果表示x在哈希表中的位置</li><li>T表示不同的x的个数</li><li>n表示哈希表中的位置个数</li><li>b表示哈希表中bucket的个数</li><li>s表示槽的个数</li><li>identifier density  = n / T</li><li>loading density $\lambda=n/sb$ </li><li>collision 冲突：两个值被放到了同一个bucket中</li><li>overflow 溢出：bucket超过了承载的上限</li></ul><h3 id="8-2-解决collision"><a href="#8-2-解决collision" class="headerlink" title="8.2 解决collision"></a>8.2 解决collision</h3><ul><li>需要找到另一个空的地方来放置待放入的元素</li><li>常用的方法：<ul><li>线性探查，平方探查，看PPT和做题就可以理解两种方法是怎么操作的</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象程序设计</title>
      <link href="2021/05/03/oop/"/>
      <url>2021/05/03/oop/</url>
      
        <content type="html"><![CDATA[<h1 id="OOP-Review"><a href="#OOP-Review" class="headerlink" title="OOP-Review"></a>OOP-Review</h1><h4 id="RandomStar"><a href="#RandomStar" class="headerlink" title="RandomStar"></a>RandomStar</h4><h2 id="1-C-的新特性"><a href="#1-C-的新特性" class="headerlink" title="1. C++的新特性"></a>1. C++的新特性</h2><h3 id="1-0-输入输出流"><a href="#1-0-输入输出流" class="headerlink" title="1.0 输入输出流"></a>1.0 输入输出流</h3><ul><li>C++可以使用输入输出流<code>(cin, cout)</code>进行输出，比如<code>cout&lt;&lt;&quot;Hello World&quot;;</code> 需要包含<strong>头文件</strong><code>#include&lt;iostream&gt;</code> </li><li>文件的输入输出, 使用ofstream和ifstream</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;istream&gt;#include&lt;string&gt;using namespace std;int main()&#123;    string str&#x3D;&quot;Hello World!&quot;;    ofstream fout(&quot;out.txt&quot;);    fout&lt;&lt;str&lt;&lt;endl;    ifstream fin(&quot;out.txt&quot;);    string str1,str2;    fin&gt;&gt;str1&gt;&gt;str2;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-变量和动态内存分配"><a href="#1-1-变量和动态内存分配" class="headerlink" title="1.1 变量和动态内存分配"></a>1.1 变量和动态内存分配</h3><ul><li><p>C++中的变量类型</p><ul><li>global variable 全局变量，存储在<strong>全局变量区</strong> <ul><li>可以在不同的cpp文件之间共享，可以使用关键字<code>extern</code> 来使用别的cpp文件中的全局变量</li></ul></li><li>static global variable <strong>静态全局变量</strong>，不能在cpp文件之间共享</li><li>local variable 存储在<strong>栈</strong>区上</li><li>static local variable 静态局部变量<ul><li>存储在全局变量区</li><li>在初次使用的时候初始化，keeps its value between visit to the function</li></ul></li><li>allocated variable 动态分配的变量<ul><li>存储在内存的堆结构中</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string s&#x3D;&quot;hello&quot;;string *ps&#x3D;&amp;s;(*ps).length();ps-&gt;length();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>C++动态内存分配</p><ul><li><p>new用于动态分配内存给变量，如<code>new int</code>，<code>new double[1000]</code></p><ul><li><p>与malloc的区别：<strong>malloc不执行类的构造函数</strong>，而new出新的对象的时候会执行对象的构造函数<code>new Class_Name[x]</code>会执行x次Class_Name的构造函数</p></li><li><p><strong>内存泄漏</strong> Memory Leak</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>上面这段代码中一开始为指针p分配了一段内存空间并赋值了123，但是第三行代码又为p赋值了一段新的内存空间，原来的内存空间存储了123，但是这一段内存空间已经没有指针指向，因此<strong>不能访问，也不能删除</strong>，造成了内存泄漏</li></ul></li></ul></li><li><p>delete用于删除动态分配的内存</p><ul><li><p>用法 <code>delete p; </code> <code>delete[] p;</code> </p></li><li><p>和new类似，delete会执行所删除对象的构造函数，不能delete没有定义过的变量，同一个变量不能delete两次</p></li><li><p>两个指针p1,p2指向同一个数据，如果p1被delete了，p2也不能访问原本p1指向的变量的值，因为delete删除的是内存里的数据</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token keyword">new</span> p1<span class="token punctuation">;</span><span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">delete</span> p1<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">// error!!!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>指向同一个数据的两个指针实际上只是两个不同的变量名而已，delete删除的不是变量名而是数据</li></ul></li></ul></li></ul></li></ul><h3 id="1-2-引用-Reference"><a href="#1-2-引用-Reference" class="headerlink" title="1.2 引用 Reference"></a>1.2 引用 Reference</h3><ul><li>a new type in C++， 相当于给变量取了一个别名，使用方法为<code>type &amp;refname = name;</code> 引用的对象<strong>不能</strong>是表达式</li><li>引用和指针的区别<ul><li>不能定义<strong>空引用</strong>，引用必须连接到一块合法的内存</li><li>一旦引用被初始化为一个对象<strong>就不能更改</strong> </li><li>引用在创建的时候必须要<strong>初始化</strong> </li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *f(int *x)&#123;    (*x)++;    return x;&#125;int &amp;g(int &amp;x)&#123;    x++;    return x;&#125;int x;int &amp;h()&#123;    return x;&#125;int main()&#123;    int a&#x3D;0;    f(&amp;a);    g(a);    h()&#x3D;16; &#x2F;&#x2F;这里全局变量x被赋值为16&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-const类型"><a href="#1-3-const类型" class="headerlink" title="1.3 const类型"></a>1.3 const类型</h3><ul><li><p>用于定义常量类型，如<code>const int x=12345;</code>, const类型的变量在初始化之后就不能改变其值，const型变量不能在连接单元外使用</p></li><li><p>Run-time constants 运行时常量</p><ul><li>数组的定义时的长度值必须在<strong>编译期</strong>就已知，所以宏定义中的常数可以作为数组长度，而<code>int n; int a[n]</code>这样的语法就是错误的，不过现在似乎有了编译器优化，在Dev-cpp中这样写也可以通过编译</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int size&#x3D;100;int a[size];&#x2F;&#x2F;OKint x;cin&gt;&gt;x;const int size&#x3D;x;int a[size];&#x2F;&#x2F;Error!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>const和指针pointer</p><ul><li>常量指针：<code>char * const p = &quot;abc&quot;;</code> <strong>不能赋予这个指针新的地址</strong>，相当于地址是const类型，但是p指向的值可以改变</li><li><code>const char* p = &quot;abc&quot;; </code> 这种情况下p指向的是一个const char类型的值，因此<strong>指向的值不能改变</strong>，而指针指向的对象可以改变</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;第一种情况是q是一个const指针，但是q指向的东西可以变char * const q &#x3D;&quot;abc&quot;;*q&#x3D;&#39;c&#39;; &#x2F;&#x2F; OKq++; &#x2F;&#x2F; Error!&#x2F;&#x2F;第二种情况下，(*q)是一个const的值，此时q所指向的值不能变const char *p &#x3D; &quot;abc&quot;;*p&#x3D;&#39;c&#39;;&#x2F;&#x2F;error!&#x2F;&#x2F;区别这三种东西string p1&#x3D;&quot;zyc&quot;;const string *p&#x3D;&amp;p1;string const* p&#x3D;&amp;p1;string *const p&#x3D;&amp;p1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不能将const类型的变量赋值给对应的指针，因为可能会带来const变量的改变，这是const类型的变量不允许的</li><li>可以把非const类型的值赋给对应的const型变量，函数中可以将参数设置为const类型表明这些参数在函数中不能被修改原本的值，也可以将返回值类型设置为const表示返回值不能被修改</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;struct student&#123;    int id;&#125;;void foo(const student *ps)&#123;    &#x2F;&#x2F;*ps could not be changed in the function    cout&lt;&lt;ps-&gt;id&lt;&lt;endl;    cout&lt;&lt;(*ps).id&lt;&lt;endl;&#125;void bar(const student &amp;s)&#123;    &#x2F;&#x2F;s could not be changed in the function    cout&lt;&lt;s.id&lt;&lt;endl;&#125;int main()&#123;    student s;    s.id&#x3D;2;    foo(&amp;s);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>char * s=&quot;Hello World!&quot;;</code>实质上是<code>const char *</code>类型，不要去修改s中的内容，这是一种<strong>未定义的行为</strong>(undefined behavior)，应该写成 <code>char s[]=&quot;Hello World!&quot;;</code> </li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int main()&#123;    const char *s1&#x3D;&quot;Hello World&quot;;    const char *s2&#x3D;&quot;Hello World&quot;;        cout&lt;&lt;(void*)s1&lt;&lt;endl;    cout&lt;&lt;(void*)s2&lt;&lt;endl;    return 0;    &#x2F;&#x2F;输出的结果是s1和s2的地址，他们的结果是一样的&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-类-class"><a href="#2-类-class" class="headerlink" title="2. 类 class"></a>2. 类 class</h2><h3 id="2-0-类的基本概念"><a href="#2-0-类的基本概念" class="headerlink" title="2.0 类的基本概念"></a>2.0 类的基本概念</h3><ul><li>C++中的对象=属性+操作 objects=attributes+operations，对于面向对象的编程而言，任何东西都是一个对象，任何对象都有对应的类型，程序就是一系列对象互相之间传递信息来完成功能<ul><li>C++的类包含成员变量和成员函数</li><li>C++中class的定义，具体实现和调用可以分成三个文件<ul><li>头文件header是具体实现和调用之间的接口，每个类的定义需要用1个头文件</li></ul></li><li><code>::</code>操作符可以用来访问类中的内容</li></ul></li></ul><h3 id="2-1-构造函数和析构函数"><a href="#2-1-构造函数和析构函数" class="headerlink" title="2.1 构造函数和析构函数"></a>2.1 构造函数和析构函数</h3><ul><li><p>constructor 构造函数</p><ul><li>构造函数的函数名和类的名字相同，可以传入一些参数用来初始化一个对象，在类的对象被定义的时候会自动调用构造函数</li><li>default constructor 默认构造函数，不需要参数也可以使用的构造函数</li><li>初始化列表：在函数签名后面，大括号之前直接对类中定义的变量进行赋值<ul><li>const类型的成员变量初始化<strong>只能用初始化列表</strong> </li><li>构造函数的执行分为两个阶段：初始化阶段和函数执行阶段，会先执行初始化列表里的赋值，在进入函数主体进行对应的操作</li></ul></li></ul></li><li><p>Destructor 析构函数</p><ul><li>析构函数的函数名是类名前面加一个~，析构函数不需要参数，在类的生命周期结束的时候会<strong>被编译器自动调用</strong> </li></ul></li><li><p>function overloading 函数重载：</p><ul><li>函数名相同而参数的个数和类型不同的几个函数构成重载关系，一个类可以有多个不同的构造函数来解决不同情况下的构造</li><li>default value：缺省值，可以在函数参数表中直接声明一些参数的值，但是必须要从右往左，当传入的参数缺省时函数默认将已经声明的值作为参数的值</li></ul></li><li><p>constant object常量对象</p><ul><li>需要加const声明，在声明之后就不能改变这个对象内部变量的值</li><li>会有一些成员函数不能正常使用</li><li><strong>在成员函数参数表后面加const可以成为const型成员函数，const类型的成员函数不能修改成员变量的值</strong><ul><li><p>const声明写在函数的开头表示函数的返回值类型是const</p></li><li><p>const声明写在函数签名的末尾表示这个成员函数<strong>不能修改类中定义的成员变量</strong>，被称为<strong>常成员函数</strong> </p><ul><li><p>但是如果是成员变量中有指针，并不能保证指针指向的内容不被修改</p></li><li><p>const类型的函数和非const类型的函数也可以构成重载关系，比如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123;public:    void foo() &#123;        cout &lt;&lt; &quot;A::foo();&quot; &lt;&lt; endl;    &#125;    void foo() const &#123;        cout &lt;&lt; &quot;A::foo() const;&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    A a;    a.foo(); &#x2F;&#x2F;访问的是非const类型的foo    const A aa;    aa.foo(); &#x2F;&#x2F;访问的是const类型的foo    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>const类型的成员函数的使用规则如下：</p><ul><li>non-const成员函数不能调用const类型对象的成员变量，而const类型可以访问</li><li>const类型函数不会改变任何成员变量的值</li><li>构成重载关系的时候，const类型的对象只能调用const类型的成员函数，不能调用non-const，而非const类型的对象<strong>优先调用non-const的成员函数</strong>，如果没有non-const再调用const类型的</li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><p>copy constructor拷贝构造函数</p><ul><li><p>把一个对象直接赋值给另一个对象，一般的形式为<code>class_name(const class_name &amp; copy_class_var</code>)`，通过拷贝构造函数可以实现对象之间的互相赋值</p></li><li><p>如果定义变量时直接给变量用同类型的变量赋值，调用的就是拷贝构造函数，如果是定义之后再赋值，就是调用了重载之后的等号，比如下面这一段代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123;  A() &#123;&#125;    A(const A&amp; a) &#123;&#125;  A&amp; operator&#x3D;(const A&amp; a) &#123;&#125;&#125;;int main()&#123;    A a;     A b &#x3D; a; &#x2F;&#x2F;调用拷贝构造函数    A c;    c &#x3D; a; &#x2F;&#x2F;调用重载之后的等号&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>C++中的拷贝：<strong>浅拷贝</strong>和<strong>深拷贝</strong> </p><ul><li>浅拷贝：在原来已有的内存中增加一个新的指针指向这一段内存</li><li>比如<code>string s1=&quot;zyc&quot;; string s2(s1);</code>  就是一种浅拷贝 </li><li>深拷贝：分配一块新的内存，复制对应的值，并定义一个新的指针指向这一块内存</li><li>缺省的拷贝构造函数和赋值运算符进行的都是浅拷贝</li><li>拷贝构造函数和赋值运算符的区别<ul><li>拷贝构造函数是在对象被创建的时候调用的、</li><li>赋值运算符只能使用于已经存在的对象，也就是进行赋值之前，这个对象已经被某个构造函数构造出来了</li></ul></li><li>例如</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;struct Person&#123;    char *name;    Person(const char *s)&#123;        name&#x3D;new char[strlen(s)+1];        strcpy(name,s);    &#125;    ~Person()&#123;        delete[] name;    &#125;&#125;&#x2F;&#x2F;不需要拷贝构造函数的一种方式Person bar(const char *s)&#123;    cout&lt;&lt;&quot;in bar()&quot;&lt;&lt;endl;    return Person(s);&#125;int main()&#123;    Person p1(&quot;Trump&quot;);    Person p2&#x3D;p1;    cout&lt;&lt;(void *)p1.name&lt;&lt;endl;    cout&lt;&lt;(void *)p2.name&lt;&lt;endl; &#x2F;&#x2F;会发现输出的地址是一样的，说明指针在默认情况下也进行了copy,若要避免则应该自己编写拷贝构造函数        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2-2-static类型"><a href="#2-2-static类型" class="headerlink" title="2.2 static类型"></a>2.2 static类型</h3><ul><li><p>类中的成员(变量和函数)分为两种</p><ul><li>静态成员：在类内所有对象之间共享</li><li>实例成员：只能在某个具体的对象中调用</li><li><strong>静态函数不能访问实例成员</strong> </li></ul></li><li><p>之前已经讲到了static类型的全局变量只在当前文件有效，不能通过extern跨文件调用，而函数中的static类型的变量在<strong>第一次调用</strong>的时候会被初始化，之后再调用该函数这个static类型的变量<strong>保持上一次函数调用结束时的值</strong> </p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;class A&#123;    piblic:    A() &#123;cout&lt;&lt;&quot;A::A()&quot;&lt;&lt;endl;&#125;    ~A()&#123;cout&lt;&lt;&quot;A::~A()&quot;&lt;&lt;endl;&#125;&#125;void f(int n)&#123;    if(x&gt;10)    static A a;    cout&lt;&lt;&quot;f()&quot;&lt;&lt;endl;&#125;int main()&#123;    cout&lt;&lt;&quot;start&quot;&lt;&lt;endl;    f(1);    f(11);    return 0;&#125;&#x2F;&#x2F;此时只有在第二次调用时a才会被构造&#x2F;&#x2F;无论什么情况，A的构造和析构函数只会被执行一次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>类中的static</p><ul><li><p>类中定义的static类型的变量是<strong>静态成员变量</strong>，其值会在这个类的<strong>所有成员之间共享</strong> </p><ul><li>non-const类型的静态成员变量需要在类的外面进行定义，比如：</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class A &#123;public:    static int count;    A() &#123;        A::count++;    &#125;&#125;;int A::count &#x3D; 0; &#x2F;&#x2F; 在类的外部赋值的时候不需要说明static，但是需要注明A::，否则就是一个新的变量int main()&#123;    A* array &#x3D; new A[100];    cout&lt;&lt;A::count&lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>const类型的静态成员变量作为类内共享的一个常量，也需要在类的外部进行定义，此时要写出关键字const，并且这个静态成员变量是不能被改变的</li></ul></li><li><p>静态成员函数：</p><ul><li><strong>可以访问类定义中的静态成员变量</strong>，但是<strong>不能直接访问普通的</strong>成员变量</li><li>需要在函数定义之前加static关键字</li></ul></li></ul></li></ul><h3 id="2-3-Inline-Function内联函数"><a href="#2-3-Inline-Function内联函数" class="headerlink" title="2.3 Inline Function内联函数"></a>2.3 Inline Function内联函数</h3><ul><li>需要在函数名前面加关键字<code>inline</code> <ul><li>内联函数在编译期会被编译器在调用处直接扩展为一个完整的函数，因此可以减少运行时调用函数的cost</li><li>内联函数的定义和函数主体部分都应该写在<strong>头文件</strong>中</li><li>本质是空间换时间</li><li>class中的函数都是<strong>默认inline</strong>的</li></ul></li><li>an inline function is expanded in place, like a preprocessormacro, so the overhead of the function call is eliminated,不需要函数调用产生的开销，由编译器<strong>直接优化</strong>，但是可能会使得需要编译的代码量增大(虽然写的人是看不出来的)，主要作用是减小函数调用时的开销，一般在函数比较小的时候才会使用</li></ul><h3 id="2-4-继承Inheritance"><a href="#2-4-继承Inheritance" class="headerlink" title="2.4 继承Inheritance"></a>2.4 继承Inheritance</h3><ul><li><p>composition 组合：把其他的类作为自己的成员变量</p></li><li><p>Inheritance：从基类中继承生成派生类</p><ul><li>派生类<strong>继承了基类的所有变量和成员函数</strong> </li><li>派生类中<strong>不能直接访问</strong>基类的private的变量和成员函数，但是可以通过基类的成员函数来访问这些成员函数和变量</li><li>派生类的构造函数<ul><li><p>可以在派生类的构造函数中<strong>调用</strong>基类的构造函数</p></li><li><p>派生类在被构造的时候会<strong>先调用基类的构造函数</strong>，再调用派生类的构造函数，析构的时候先调用派生类的析构函数，再调用基类的析构函数</p><ul><li>如果派生类没有定义构造函数，则直接调用基类的构造函数</li><li>如果派生类定义了构造函数，在执行之前会先调用基类的构造函数，如果派生类的构造函数中没有显式调用基类的构造函数，则会选择调用基类的无参构造函数</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123;public:    int i;    A(int ii &#x3D; 0): i(ii) &#123;        cout&lt;&lt;&quot;A(): &quot;&lt;&lt;i&lt;&lt;endl;    &#125;&#125;;class B: public A &#123;public:    int i;    A a;    B(int ii &#x3D; 0): i(ii) &#123;        cout&lt;&lt;&quot;B(): &quot;&lt;&lt;i&lt;&lt;endl;    &#125;&#125;;int main()&#123;    B b(100);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>当继承和组合两种情况同时出现时，先构造基类，再构造派生类中组合的其他类，再构造派生类，析构的时候类似 </p><ul><li>Base class is always constructed first</li><li>就算组合的类在<strong>初始化列表或者构造函数中没有调用</strong>构造函数，C++编译器也会自动调用这个类默认的构造函数</li></ul></li></ul></li><li>派生类中可以对基类函数进行重载，此时如果派生类对象调用对应的函数按照派生类中的同名函数执行<ul><li>仍然调用基类的方法<code>object.Base::function()</code> </li></ul></li><li>class和struct的区别：class中的变量和函数<strong>默认为private</strong>，struct中的函数默认为public</li><li>访问控制<ul><li>public：所有情况下可见</li><li>protected：可以被自己/派生类和友元函数访问</li><li>private：对于自己和友元函数可见</li></ul></li><li>继承的种类：public，private，protected继承，继承之后的基类变量的访问控制取原本类型和继承类型中较严格的</li><li>可以通过<strong>强制类型转换</strong>把派生类的对象转化为基类的对象</li></ul></li></ul><h3 id="2-5-友元-friend"><a href="#2-5-友元-friend" class="headerlink" title="2.5 友元 friend"></a>2.5 友元 friend</h3><ul><li>友元函数<ul><li>在类中声明一个全局函数或者其他类的成员函数为<code>friend</code></li><li>可以使这些函数拥有访问类内private和protected类型的变量和函数的权限</li><li>友元函数也可以是一个类，这种情况下被称为是友元类，整个类和所有的成员都是友元</li><li>友元函数本身不是那个类的成员函数，函数签名里不需要<code>className::</code>来表示是这个类的成员函数，直接作为普通函数即可</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123;private:    int val;public:    A(int value): val(value) &#123;        cout&lt;&lt;&quot;A()&quot;&lt;&lt;endl;    &#125;    friend void showValue(A a);&#125;;void showValue(A a)&#123;    cout&lt;&lt;a.val&lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2-6-多态和虚函数"><a href="#2-6-多态和虚函数" class="headerlink" title="2.6 多态和虚函数"></a>2.6 多态和虚函数</h3><ul><li><p>多态 Polymorphism</p><ul><li><p>同一段代码可以产生不同效果</p></li><li><p>对于继承体系中的某一系列同名函数，不同的类型会调用不用的函数</p></li><li><p>一般情况下，有继承关系的类之间有函数构成重载关系，依然会根据变量类型来调用对应的函数，比如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class A&#123;public:    virtual void foo() &#123;        cout&lt;&lt;1&lt;&lt;endl;    &#125;&#125;;class B: public A&#123;public:    virtual void foo() &#123;        cout&lt;&lt;2&lt;&lt;endl;    &#125;&#125;;int main()&#123;    A a;    B b;    a.foo();    b.foo();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>此时运行的结果是1和2，即A型的变量的foo函数是基类中的，B类型的变量的foo函数是派生类中的</li></ul></li></ul></li><li><p>静态链接</p><ul><li><p>函数的调用在程序开始运行之前就已经确定了</p></li><li><p>对于像下面这样的情况，基类的指针(引用)指向派生类，并且调用了基类中也存在的同名函数，最终调用的都是基类的同名函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">protected</span><span class="token operator">:</span>      <span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">;</span>   <span class="token keyword">public</span><span class="token operator">:</span>      <span class="token function">Shape</span><span class="token punctuation">(</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>         width <span class="token operator">=</span> a<span class="token punctuation">;</span>         height <span class="token operator">=</span> b<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">int</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>         cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent class area :"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Shape</span></span><span class="token punctuation">&#123;</span>   <span class="token keyword">public</span><span class="token operator">:</span>      <span class="token function">Rectangle</span><span class="token punctuation">(</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">Shape</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>      <span class="token keyword">int</span> <span class="token function">area</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>          cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Rectangle class area :"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token punctuation">(</span>width <span class="token operator">*</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Triangle</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Shape</span></span><span class="token punctuation">&#123;</span>   <span class="token keyword">public</span><span class="token operator">:</span>      <span class="token function">Triangle</span><span class="token punctuation">(</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">Shape</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>      <span class="token keyword">int</span> <span class="token function">area</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>          cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Triangle class area :"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token punctuation">(</span>width <span class="token operator">*</span> height <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   Shape <span class="token operator">*</span>shape<span class="token punctuation">;</span>   Rectangle <span class="token function">rec</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   Triangle  <span class="token function">tri</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   shape <span class="token operator">=</span> <span class="token operator">&amp;</span>rec<span class="token punctuation">;</span>   shape<span class="token operator">-></span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   shape <span class="token operator">=</span> <span class="token operator">&amp;</span>tri<span class="token punctuation">;</span>   shape<span class="token operator">-></span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>虚函数 Virtual Function</p><ul><li><p>一种用于<strong>实现多态</strong>的机制，核心理念是通过基类访问派生类定义的函数</p><ul><li>这种方式称为<strong>动态</strong>链接 </li></ul></li><li><p>用于区分派生类中和基类同名的方法函数，需要将<strong>基类</strong>的成员函数类型声明为virtual</p><ul><li>基类中的<strong>析构函数一定要为虚函数</strong>，否则会出现对象释放错误 </li></ul></li><li><p>纯虚函数：<code>virtual int func() = 0;</code> 表明该函数没有主体，基类中没有给出有意义的实现方式，需要在派生类中进行扩展</p></li><li><p>override语法：派生类中可以用override关键字来声明，表示对基类虚函数的重载</p></li><li><p>虚函数需要借助指针和引用达到多态的效果</p><ul><li>如果基类指针/引用<strong>指向基类</strong>，那就正常调用基类的相关成员函数</li><li>如果基类指针<strong>指向派生类</strong>，则调用的时候会调用派生类的成员函数</li><li>派生类指针<strong>不能</strong>指向基类</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;public:    virtual void foo()&#123;        cout&lt;&lt;&quot;A&quot;&lt;&lt;endl;    &#125;&#125;;class B&#123;public:    virtual void foo()&#123;        cout&lt;&lt;&quot;B&quot;&lt;&lt;endl;    &#125;&#125;int main()&#123;  A *a&#x3D;new B();    a-&gt;foo(); &#x2F;&#x2F;结果为B  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>虚函数的实现方式：<strong>虚函数表</strong> virtual table </p><ul><li>每一个有虚函数的类都会有一个虚函数表，该类的任何对象中都存放着虚函数表的指针，虚函数表中<strong>列出了该类的虚函数地址</strong> <ul><li>虚函数表是一个指针数组，里面存放了一系列虚函数的指针</li><li>虚函数的调用需要经过虚函数表的查询，非虚函数的调用不需要经过虚函数表</li><li>虚函数表在代码的编译阶段就完成了构造</li><li>一个类只有一张虚函数表，每一个对象都有指向虚函数表的一个指针<code>__vptr</code> </li></ul></li><li>多态的函数调用语句被编译成一系列根据基类指针所指向的对象存放的虚函数表的地址，在从虚函数表中查找地址调用对应的虚函数</li><li>事实上虚函数会给函数加上一个新的参数，是一个指针，占用4字节</li></ul></li></ul></li><li><p>接口(C++抽象类)</p><ul><li>描述了一个类应该有的功能和行为，但是不用在这个类中实现，而是在派生类中实现</li><li>可以使用纯虚函数来实现抽象类的定义，比如：</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Shape &#123;public:    virtual double getArea() &#x3D; 0;    Shape(int a, int b): length(a), width(b) &#123;&#125;protected:    int length;    int width;&#125;;class Rectangle: public Shape &#123;public:    double getArea() &#123;        return length * width;    &#125;&#125;;class Triangle: public Shape &#123;public:    double getArea() &#123;        return length * width &#x2F; 2;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-虚函数使用总结"><a href="#2-7-虚函数使用总结" class="headerlink" title="2.7 虚函数使用总结"></a>2.7 虚函数使用总结</h3><ul><li>情况1：基类和派生类都不是virtual<ul><li>此时对于基类的对象和基类的指针，执行的就是基类的f，对于派生类的执行的就是派生类的f</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123;public:    void f() &#123;        cout &lt;&lt; &quot;af&quot; &lt;&lt; endl;    &#125;&#125;;class B: public A &#123;public:    void f() &#123;        cout &lt;&lt; &quot;bf&quot; &lt;&lt;endl;    &#125;&#125;;int main()&#123;    A a;    B b;    a.f();    b.f();    A* pb &#x3D; &amp;b;    pb-&gt;f();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>情况2：派生类中的同名函数是虚函数：无影响，和1一模一样</p></li><li><p>情况3：基类中的是虚函数，派生类中不注明是虚函数：此时派生类的对象和指向派生类的指针执行的都是派生类的函数f，基类的对象和指向基类对象的指针执行的都是基类的函数f</p></li><li><p>总结：</p><ul><li><p>virtual的虚函数关键字是<strong>向下负责</strong>的，派生类声明virtual对基类无任何影响</p></li><li><p>对于指针和引用而言</p><ul><li>不是虚函数的时候，调用的函数取决于指针和引用的变量类型(基类指针调用基类，派生类指针调用派生类)</li><li>是虚函数的时候，调用函数取决于指针和引用指向的变量类型(指向基类调用基类，指向派生类调用派生类)</li><li>当然如果派生类里没有新的同名函数，那么执行的都是基类里的</li><li>要注意派生类指针不能直接指向基类的对象</li><li>如果虚函数里还需要调用其他函数，调用的规则也和上面的一样，比如下面有个历年卷上面的神题：</li></ul></li><li><p>历年卷上的一个题目：写出程序的输出</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class B &#123;public:    void f() &#123;        cout &lt;&lt; &quot;bf&quot; &lt;&lt; endl;    &#125;    virtual void vf() &#123;        cout &lt;&lt; &quot;bvf&quot; &lt;&lt; endl;    &#125;    void ff() &#123;        vf();        f();    &#125;    virtual void vff() &#123;        vf();        f();    &#125;&#125;;class D: public B &#123;public:    void f() &#123;        cout &lt;&lt; &quot;df&quot; &lt;&lt; endl;    &#125;    void ff() &#123;        f();        vf();    &#125;    void vf() &#123;        cout &lt;&lt; &quot;dvf&quot; &lt;&lt;endl;    &#125;&#125;;int main()&#123;    D d;    B* pb &#x3D; &amp;d;    pb-&gt;f();    pb-&gt;ff();    pb-&gt;vf();    pb-&gt;vff();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>这道题的分析过程如下：</p><ul><li>首先调用f，而f不是虚函数，所以根据指针类型调用了B中的f，输出bf</li><li>再调用ff，因为ff也不是虚函数，所以调用B中的ff，B中的ff调用了vf和f，而vf是虚函数，B类型指针指向的是D，所以调用D中的vf，输出dvf，调用f则和上面一样输出bf</li><li>再调用vf，由于vf是虚函数，所以要调用D中的vf，输出dvf</li><li>再调用vff，虽然是虚函数但是D中没有定义同名函数，所以调用B中的vff，vff中调用vf和f，同2一样输出的是dvf和bf</li><li>所以最终的输出是</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">bfdvfbfdvfdvfbf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>这道题涵盖了单继承虚函数的所有情况</p></li></ul></li></ul></li><li><p>基类虚函数的优先级高于派生类中的需要强制类型转换的同名函数</p><ul><li>比如下面一段代码中</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    A<span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>    pa<span class="token operator">-></span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这里输出的结果是1，事实上两个f并不构成虚函数的关系，因为f(1)中1是int类型，所以优先调用了对int匹配度高的</li><li>事实上如果是f(1.1)输出的结果仍然是1，并且CLion会提示参数需要类型转换</li><li>事实上两个f不构成虚函数的多态关系，所以调用哪个并不看指针指向的对象，而是看指针本身的类型！</li></ul></li></ul><h3 id="2-8-强制类型转换"><a href="#2-8-强制类型转换" class="headerlink" title="2.8 强制类型转换"></a>2.8 强制类型转换</h3><h4 id="2-8-1-static-cast"><a href="#2-8-1-static-cast" class="headerlink" title="2.8.1 static_cast"></a>2.8.1 static_cast</h4><ul><li><p><code>static_cast</code> 用于数据类型的强制转换，有这样几种用法</p><ul><li>基本数据类型的转换，比如char转换成int</li><li>在类的体系中把基类和派生类的指针和引用进行转换<ul><li>向上转换是安全的</li><li>向下转换是不安全的</li><li>只能在有相互联系的类型中进行相互转换，不一定包含虚函数</li></ul></li><li>把空指针转换成目标类型的空指针</li><li>把任何类型转换成void类型</li></ul></li><li><p>static_cast不能转换掉有const的变量</p></li></ul><h4 id="2-8-2-const-cast"><a href="#2-8-2-const-cast" class="headerlink" title="2.8.2 const_cast"></a>2.8.2 const_cast</h4><ul><li><code>const_cast</code> 可以强制去掉const的常数特性，<strong>只能用在指针和引用</strong>上面<ul><li>常量指针被转化成非常量的指针，仍然指向原来的对象</li><li>常量引用被转换成为非常量的引用，仍指向原来的对象</li></ul></li><li>来看一段代码<ul><li>打印出来的结果是a=10，而p和q所指向的值是20，a的地址和pq指向的地址是一样的</li><li>事实上第五行的赋值是一种未定义行为，最好别用</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int a &#x3D; 10;const int *p &#x3D; &amp;a;int *q;q &#x3D; const_cast&lt;int *&gt;(p);*q &#x3D; 20;cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; *q &lt;&lt; endl;cout &lt;&lt; &amp;a &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; q &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-8-3-reinterpret-cast"><a href="#2-8-3-reinterpret-cast" class="headerlink" title="2.8.3 reinterpret_cast"></a>2.8.3 reinterpret_cast</h4><ul><li><code>reinterpret_cast</code> 主要有三种用途<ul><li>改变指针或者引用的类型</li><li>将指针或者引用转换成为足够长的整形</li><li>将整型编程指针或者引用类型</li></ul></li></ul><h4 id="2-8-4-dynamic-cast"><a href="#2-8-4-dynamic-cast" class="headerlink" title="2.8.4 dynamic_cast"></a>2.8.4 dynamic_cast</h4><ul><li><p>跟其他几个不同，其他几个都是编译时完成的，<code>dynamic_cast</code> 是在运行时进行类型检查的</p></li><li><p>不能用于内置的基本数据类型的强制转换</p></li><li><p>如果成功的，将返回指向类的指针或者引用，转换失败的话会返回NULL</p></li><li><p>转换时基类一定要有虚函数，否则无法通过编译</p><ul><li>原因是虚函数表名这个类希望可以用基类指针指向派生类，这样转换才有意义</li></ul></li><li><p>在类的向上转换的时候，和<code>static_cast</code> 效果一样，但是向下转换的时候比<code>static_cast</code> 更安全，因此要求也更高</p></li><li><p>来看一段代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()&#123;    A a;    B b;    A *ap &#x3D; &amp;a;    if(dynamic_cast&lt;B*&gt;(ap)) &#123;        cout &lt;&lt; &quot;OK1&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;Fail&quot; &lt;&lt; endl;    &#125;    if(static_cast&lt;B*&gt;(ap)) &#123;        cout &lt;&lt; &quot;OK2&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;Fail&quot; &lt;&lt; endl;    &#125;    ap &#x3D; &amp;b;    if(dynamic_cast&lt;B*&gt;(ap)) &#123;        cout &lt;&lt; &quot;OK3&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;Fail&quot; &lt;&lt; endl;    &#125;    if(static_cast&lt;B*&gt;(ap)) &#123;        cout &lt;&lt; &quot;OK4&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;Fail&quot; &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>运行的结果是第一个失败，其他的都成功</li><li>推测导致这个结果的原因：<ul><li>当ap指向派生类的时候，进行强制类型转换变成派生类是可以成功的</li><li>当ap指向基类的时候，<code>dynamic_cast</code> 转换是否成功取决于指针指向的类型和即将转换的类型是不是一样，不一样就会失败，返回一个NULL，而static是可以成功的</li><li>其实是更安全的机制导致dynamic的检查更多，要求更高</li></ul></li></ul></li></ul><h2 id="3-重载"><a href="#3-重载" class="headerlink" title="3. 重载"></a>3. 重载</h2><h3 id="3-0-函数的重载"><a href="#3-0-函数的重载" class="headerlink" title="3.0 函数的重载"></a>3.0 函数的重载</h3><ul><li><p>多个同名函数的参数的个数或者类型不相同，这几个函数就构成重载关系</p><ul><li><p>不能仅通过返回值类型的不同来形成函数的重载，事实上函数重载和返回值类型的关系不大</p></li><li><p>调用的时候优先调用匹配度最高的重载函数，重载的优先级是：</p><ul><li>先找完全匹配的普通函数</li><li>再找模板函数</li><li>再找需要隐式转换的函数</li></ul></li><li><p>当没有参数类型恰好匹配的重载函数的时候，就会将参数进行隐式转换之后来寻找可以调用的重载函数，此时如果重载函数有多个符合条件，就会产生error</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void foo(int a, int b)&#123;    cout&lt;&lt;1&lt;&lt;endl;&#125;void foo(double a, double b)&#123;    cout&lt;&lt;2&lt;&lt;endl;&#125;int main()&#123;    foo(1, 2);    foo(1.0, 2.0);    foo(1, 2.0); &#x2F;&#x2F; 这一行是有语法错误的！&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="3-1-运算符的重载"><a href="#3-1-运算符的重载" class="headerlink" title="3.1 运算符的重载"></a>3.1 运算符的重载</h3><ul><li><p>重载的一些基本性质</p><ul><li>大部分运算符都可以重载</li><li><code>.    ::   ?:  </code>之类的运算符不能重载，sizeof，typeid，static之类的<strong>关键字不能重载</strong> </li><li>不能重载不存在的运算符</li><li>必须对于整个class或者enumeration type进行运算符的重载</li><li>重载之后的运算符依然保持<strong>原来一样的运算优先级和操作数的个数</strong> </li></ul></li><li><p>运算符重载的基本语法</p><ul><li>在类定义中对member function进行重载<code>return_type class_name::operator运算符(parameters)</code> 此时参数为对应运算符所需参数-1</li><li>对外部函数进行重载<code>返回值类型 operator运算符(参数表)</code> 此时参数个数和对应的运算符的所需个数相同<ul><li>如果要访问类的private内容，需要声明这个重载函数为<strong>友元</strong> </li><li>单目运算符一般声明为成员函数，双目运算符一般作为外部的函数</li><li>[ ] ( ) -&gt; 等运算符必须作为成员函数</li></ul></li><li>前缀的++和后缀的++<ul><li>区别：后缀的++参数表是有个int类型的变量作为参数的</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Integer&amp; operator++();  &#x2F;&#x2F;prefix++Integer operator++(int x); &#x2F;&#x2F;postfix++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>比较大小关系的运算符重载时，可以通过<strong>代码的复用</strong>减少不必要的代码量</p></li><li><p>自定义的<strong>类型转换</strong> </p><ul><li>例如 <code>Rational::operator double() const &#123;&#125;;</code></li><li>隐式类型转换：<ul><li>Single-argument constructors</li><li>implicit type conversion operators</li><li>避免隐式转换的方法：把复制构造函数声明为explicit，表示不能进行隐式的类型转换</li></ul></li></ul></li></ul><h3 id="3-2-输入输出流的重载"><a href="#3-2-输入输出流的重载" class="headerlink" title="3.2 输入输出流的重载"></a>3.2 输入输出流的重载</h3><ul><li><p>stream的种类</p><ul><li>Text stream 用ASCII码来解析，包括files和character buffers</li><li>Binary stream 二进制数据，no translation</li></ul></li><li><p>stream的类型：</p><ul><li>cin标准输入，使用流提取运算符&gt;&gt;，在C++标准库的istream中定义</li><li>cout标准输出，使用流插入运算符&lt;&lt;，在ostream中定义</li><li>cerr标准错误提示(unbuffered error)</li><li>clog标准错误提示(buffered error)</li></ul></li><li><p>对&gt;&gt;和&lt;&lt;的重载</p><ul><li>Has to be a 2-argument free function</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">istream&amp; operator&gt;&gt;(istream&amp; is, T&amp; obj)&#123;    &#x2F;&#x2F;special way to read in obj    return is;    &#x2F;&#x2F;Return an istream&amp; for chaining&#125;&#x2F;&#x2F;&lt;&lt;的重载方式与之类似ostream&amp; operator&lt;&lt;(ostream&amp; os, T&amp; obj)&#123;    return os;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>控制输出的格式，使用头文件<code>#include&lt;iomanip&gt;</code></li><li>其他的输入输出的方式：<ul><li><code>int get()</code> 支持单个字符读入<ul><li>Returns the <strong>next character</strong> in the stream</li><li>Returns EOF if no characters left</li></ul></li><li><code>get(char *buf, int limit, char delim=&#39;\n&#39;)</code></li><li><code>getline(char *buf, int limit, char delim=&#39;\n&#39;)</code></li></ul></li></ul><h2 id="4-模板"><a href="#4-模板" class="headerlink" title="4. 模板"></a>4. 模板</h2><h3 id="4-1-namespace-命名空间"><a href="#4-1-namespace-命名空间" class="headerlink" title="4.1 namespace 命名空间"></a>4.1 namespace 命名空间</h3><ul><li><p>使用命名空间来划分全局的各类类名可以避免名字的冲突，可以在不同的命名空间里定义相同的变量名</p><ul><li>在引用的时候加上命名空间的限制符就可以了</li><li>或者也可以用<code>using namespace xxx</code> 来说明程序中接下来用哪个命名空间中的东西</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">namespace space1&#123;    string name &#x3D; &quot;randomstar&quot;;&#125;namespace space2&#123;    string name &#x3D; &quot;ToyamaKasumi&quot;;&#125;int main()&#123;    cout&lt;&lt;space1::name&lt;&lt;endl;    using namespace space2;    cout&lt;&lt;name&lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-2-template编程"><a href="#4-2-template编程" class="headerlink" title="4.2 template编程"></a>4.2 template编程</h3><ul><li><p>模板编程是一种复用代码的手段，是generic programming(泛型编程)，把变量的类型当作参数来声明</p></li><li><p>函数模板：使用关键字template 后面加若干个变量作为类型声明一个函数模板，类型变量可以代替函数的返回值类型，参数类型和函数中的变量的类型</p><ul><li>函数模板需要<strong>实例化</strong>(instantiation)之后再使用，如果没有被调用就不会被实例化<ul><li>实例化是讲模板函数中的模板替换为对应的变量类型，然后生成一个对应的函数</li></ul></li><li>函数模板在使用过程中不能发生参数和返回值的类型转换，必须要<strong>类型完全匹配才能使用</strong></li><li><h2 id="函数重载时候的优先级"><a href="#函数重载时候的优先级" class="headerlink" title="函数重载时候的优先级"></a>函数重载时候的<strong>优先级</strong></h2><ul><li>先找是否有完全匹配的普通函数</li><li>再找是否有完全匹配的模板函数</li><li>再找有没有通过进行隐式类型转换可以调用的函数</li></ul></li></ul></li><li><p>类模板</p><ul><li>和函数模板差不多，template中声明的既可以是类内各种需要变量类型的地方</li><li>模板类也可以继承非模板类，也可以继承模板类(需要实例化)</li><li>非模板类可以继承自模板类(需要实例化)</li></ul></li><li><p>Expression parameter</p><ul><li>模板中的可以声明一些常数，class和typename的类型名可以有默认值default value，比如<code>template&lt;typename T = int&gt;</code> </li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T, int bounds &#x3D; 100&gt;class FixedVector&#123;public:T&amp; operator[](int x);    T elements[bounds];&#125;;template &lt;class T, int bounds&gt;T&amp; FixedVector&lt;T, bounds&gt;::operator[] (int i)&#123;return elements[i]; &#x2F;&#x2F;no error checking&#125;&#x2F;&#x2F;usageFixedVector&lt;int, 50&gt; v1;FixedVector&lt;int, 10*10&gt; v2;FixedVector&lt;int&gt; v3 &#x2F;&#x2F;default value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Specialization 特化–用于萃取器</p><ul><li><p>全特化：将模板类中所有的类型参数赋予明确的类型，并写了一个类名和主模板类名相同的类，这个类就是全特化类</p><ul><li>全特化之后，已经失去了template的特性</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">bool</span> <span class="token function">compare</span><span class="token punctuation">(</span>T x<span class="token punctuation">,</span> T y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x<span class="token operator">></span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 这个就是对上面写的模板函数的全特化</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">bool</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x<span class="token operator">></span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>偏特化：只给模板类赋一部分的类型，得到的偏特化类/函数可以作为一个子模版使用</p><ul><li>还保留了一部分template的功能</li></ul></li><li><p>模板类调用的<strong>优先级</strong></p><ul><li>全特化类&gt;偏特化类&gt;主版本的模板类（就是直接调用模板类，最常见的用法）</li><li>有隐式转换的优先级比较低，先考虑所有不需要隐式转换的模板，再考虑需要隐式转换的模板</li></ul></li></ul></li></ul><h3 id="4-3-STL和迭代器"><a href="#4-3-STL和迭代器" class="headerlink" title="4.3 STL和迭代器"></a>4.3 STL和迭代器</h3><ul><li><p>STL=Standard Template Library 是标准库的一部分，使用C++STL可以减少开发时间，提高可读性和<strong>鲁棒性</strong> ，STL包含了：</p><ul><li>容器</li><li>迭代器</li><li>函数</li></ul></li><li><p>STL容器的使用：刻在DNA里，不需要整理</p><ul><li>关于map：map的key<strong>必须是</strong>可以满足<strong>可以排序</strong>性质的，如果是自定义的类需要<strong>重载&lt;函数</strong>，否则这个类不能作为key值</li></ul></li><li><p>迭代器：<code>STL&lt;parameters&gt;::iterator  xxx</code></p><ul><li><p>迭代器是一种顺序访问容器的方式：Generalization of pointers</p></li><li><p>两个特殊的迭代器：begin( ) 和 end( )分别表示容器的<strong>头和尾</strong> </p><ul><li>很多时候end并不能达到，因此到结束的判断条件往往是<code>!=stl.end()</code> </li></ul></li><li><p>迭代器支持的操作</p></li><li><p><code>iter++</code> <code>iter+=2</code>(不是任何容器的迭代器都可以)</p><ul><li><code>*iter</code> </li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">  list&lt;int&gt; L;  list&lt;int&gt;::iterator li;  li&#x3D;L.begin();  L.erase(li); &#x2F;&#x2F; li&#x3D;L.erase(li);++li;&#x2F;&#x2F;error!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>可以看成是一种<strong>泛化的指针</strong> </p></li></ul></li></ul><h2 id="5-Exceptions-异常处理"><a href="#5-Exceptions-异常处理" class="headerlink" title="5. Exceptions 异常处理"></a>5. Exceptions 异常处理</h2><ul><li><p>用于异常处理的语法</p><ul><li><p><code>try&#123; &#125; catch&#123; &#125;</code> ：捕获throw抛出的异常</p><ul><li> <code>catch (...) </code>表示捕捉<strong>所有可能的异常</strong> </li><li>try括号中的代码被称为保护代码</li></ul></li><li><p>throw语句：抛出异常</p><ul><li><code>throw exp;</code> 抛出一个表达式：throw的参数可以是任何的表达式，表达式中的类型决定了抛出的结果的类型</li><li><code>throw;</code> 只有在catch子句中有效，把原本捕捉到的异常抛出</li></ul></li></ul></li><li><p>异常处理的执行过程</p><ul><li>程序按照正常的顺序执行，到达try语句，开始执行try内的保护段</li><li>如果在保护段执行期间没有发生异常，那么跳过所有的catch</li><li>如果保护段的执行期间有调用的任何函数中有异常，则可以通过throw创建一个异常对象并抛出，程序转到对应的catch处理段</li><li>首先要按顺序寻找匹配的catch处理器，如果没有找到，则<code>terminate( )</code> 会被自动调用，该函数会调用abort终止程序<ul><li>如果在函数中进行异常处理并且触发了terminate，那么终止的是当前函数</li><li>异常类型需要严格的匹配</li></ul></li><li>如果找到了匹配的catch处理程序，并且通过值进行捕获，则其形参通过拷贝异常对象进行初始化，在形参被初始化之后，展开栈的过程开始，开始对对应的try块中，从开始到异常丢弃地点之间创建的所有局部对象的析构</li></ul></li><li><p>C++中自带的异常的继承体系，定义在头文件<code>&lt;exception&gt;</code> 中</p><ul><li>what方法给出了产生异常的原因，是异常类之间都有的公共方法，已经被所有的子异常类重载</li><li>自定义的异常类：需要继承exception类</li></ul></li></ul><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200527083001264.png" alt="image-20200527083001264" style="zoom:80%;" /><ul><li>函数定义的异常声明<ul><li>可以在函数名后面加<code>noexcept</code>关键字，说明该函数在运行的过程中<strong>不抛出任何异常</strong>，如果还是产生了异常，就会调用<code>std::terminate</code>终止程序</li><li>可以在函数声明中列出所有可能抛出的异常类型，比如<code>double f(int, int) throw(int);</code> 如果是throw()表示不抛出一场，就算函数里有throw也不会执行</li></ul></li><li>throw会导致一个函数没有执行完毕，但是在函数throw之前会执行所有<strong>局部变量的析构函数</strong><ul><li>最好不要在析构函数中抛出异常</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class T&#123;    T()&#123;        cout&lt;&lt;&quot;T()&quot;&lt;&lt;endl;    &#125;    ~T()&#123;        cout&lt;&lt;&quot;~T()&quot;&lt;&lt;endl;    &#125;&#125;void foo()&#123;    T t;    throw 1;&#125;int main()&#123;    try&#123;        foo();    &#125;    catch(...)&#123;        cout&lt;&lt;&quot;Catched!&quot;&lt;&lt;endl;    &#125;    return 0;&#125;&#x2F;&#x2F;运行的结果是T()~T()Catched<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-Smart-Pointer-智能指针"><a href="#6-Smart-Pointer-智能指针" class="headerlink" title="6. Smart Pointer 智能指针"></a>6. Smart Pointer 智能指针</h2><ul><li><p>普通指针管理内存容易造成内存泄漏(比如用完忘记释放)，C++提供了智能指针用于内存的管理</p><ul><li>智能指针使用了一种RAII(资源获取即初始化)技术对普通的指针进行了封装，使得智能指针实质上是一个对象，但是行为表现得像一个指针</li><li>智能指针的相关内容包含在头文件</li></ul></li><li><p>标准库中支持的智能指针类型</p><ul><li><code>std::unique_ptr</code>只允许这个指针来管理对应的资源，<strong>不允许指针之间的拷贝</strong>，但是<ul><li>不允许进行指针的赋值和拷贝</li><li>可以用**<code>move</code>方法来移动指针的所有权**，比如<code>unique_ptr&lt;int&gt; p2 = move(p1);</code> </li><li>可以用**<code>release</code>方法**来释放指针的所有权</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;public:    A()&#123;        cout&lt;&lt;&quot;A()&quot;&lt;&lt;endl;    &#125;    ~A()&#123;        cout&lt;&lt;&quot;~A()&quot;&lt;&lt;endl;    &#125;    void foo()&#123;        cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;    &#125;&#125;int main()&#123;    &#123;        unique_ptr&lt;A&gt; pa(new (A));        pa-&gt;foo();  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>std::shared_ptr</code>非独占的指针，可以多个指针管理一个对象。shared_ptr使用<strong>引用计数</strong>，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是<strong>线程安全</strong>的，但是对象的读取需要<strong>加锁</strong> </p><ul><li>可以用<code>use_count</code>函数来查看某个对象拥有的指针的个数</li><li>可以用<code>get</code>函数来获取原始指针</li><li>不能用一个原始指针初始化多个<code>shared_ptr</code> 否则会造成内存多次释放</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;memory></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptra <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    srd<span class="token operator">::</span>shared_prt<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptrb</span><span class="token punctuation">(</span>ptra<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>ptra<span class="token punctuation">.</span>use_count<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">//输出的结果是2</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>std::weak_ptr</code>是没用重载*和-&gt;操作符，没有普通指针具有的行为，最大的作用在于协助其他指针的工作，查看对象中的资源使用情况</p><ul><li>weak_ptr可以通过一个shared_ptr或者weak_ptr来进行构造，获取观测权，但是weak_ptr<strong>不会造成指针引用计数的增加</strong> </li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统原理</title>
      <link href="2021/05/03/pcs/"/>
      <url>2021/05/03/pcs/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统原理Review"><a href="#计算机系统原理Review" class="headerlink" title="计算机系统原理Review"></a>计算机系统原理Review</h1><h3 id="源自-非-常-天-空"><a href="#源自-非-常-天-空" class="headerlink" title="源自 非 常 天 空"></a>源自 非 常 天 空</h3><h2 id="0-计算机基本知识"><a href="#0-计算机基本知识" class="headerlink" title="0.计算机基本知识"></a>0.计算机基本知识</h2><ul><li><p>计算机系统原理(feat Mr.Lou)荣获感动软工十大垃圾课前三名</p></li><li><p>软件的分类</p><ul><li>System software系统软件<ul><li>OS 操作系统</li><li>Database 数据库</li><li>Server 服务器</li><li>Compiler：以C语言为例，编译器将C语言转换成汇编语言，再由汇编器转换成machine language二进制串</li></ul></li><li>Application software 应用软件<ul><li>其他各种用途的东西</li></ul></li></ul></li><li><p>计算机硬件基本知识</p><ul><li><p>Motherboard <strong>主板</strong>包含 I/O devices，memory，processor三个部分</p><ul><li><p>Memory：用于存储running programs and data needed，每块内存包含8个集成电路</p></li><li><p>Processor：用于处理运算等操作，CPU(central processor unit)</p><p>内部结构</p></li></ul></li></ul></li></ul><ul><li><p>计算机的5个基本组成部分</p><ul><li>Input，Output，Memory，Data path，Control</li></ul></li><li><p>计算机性能评价参数</p><ul><li>主频：CPU内数字脉冲信号震荡的频率   </li><li>CPU时钟周期：节拍脉冲或者T周期，是处理操作的最基本的单位</li><li>机器字长：计算机可以直接处理的二进制数据的位数，位数大则运算精度高</li><li>响应时间</li><li>吞吐量：系统在一定时间内能够处理的请求数量(对于总线和存储器有不同的含义)</li></ul></li><li><p>计算机中的信息表示</p><ul><li>bit是最小的单位，1byte=8bits，1kb=1024bytes，依次往上</li><li>1个字节就是8位二进制，而汉字在计算机中占2个字节</li></ul></li></ul><h2 id="1-MIPS-指令系统"><a href="#1-MIPS-指令系统" class="headerlink" title="1. MIPS 指令系统"></a>1. MIPS 指令系统</h2><h3 id="1-1-基本的MIPS指令"><a href="#1-1-基本的MIPS指令" class="headerlink" title="1.1 基本的MIPS指令"></a>1.1 基本的MIPS指令</h3><ul><li><p>Operands 操作数</p><ul><li>算术指令的操作数一定存放在在寄存器(registers)中<ul><li>MIPS体系中有32个寄存器，每个寄存器有32bits</li></ul></li><li>寄存器中可以用<code>$s0-$s7</code>来存储变量，其<strong>编号为16-23</strong><ul><li>这和C语言中的<code>register int i;</code>进行的操作相同</li></ul></li><li>可以用<code>$t0,$t1,…</code>来存储一些临时变量，编号为8-15，各寄存器的功能和对应编号如下</li></ul></li><li><p>Data transfer instructions 数据传输指令</p><ul><li>需要获取数据在内存的地址</li><li>读取数据用lw，存储数据用sw，<strong>寄存器中存储了数据在内存中的地址</strong>  </li><li>Offset 偏移量：数据传输指令中的常数，表示读取多少位</li><li>Base Register：用于存储<strong>基地址</strong>的寄存器(比如数组的基地址)<ul><li>MIPS中的地址偏移量和数组下标之间的关系是<strong>4倍</strong>，比如数组A的基地址在<code>$s3</code>中，要获取A[8]，则需要指令<code>lw $t0,32($s3)</code>  </li><li>原因是内存中一次只能读出<strong>4字节内存中的一行</strong>，也就是1word的长度，事实上一条MIPS指令的长度就是1word</li></ul></li></ul></li><li><p>MIPS指令对应的机器码格式</p><ul><li>R型指令：<code>OP+RS+RT+RD+shamt+funct </code> </li><li>I型指令：<code>OP+RS+RT+address</code> </li><li>OP是对应的<strong>操作码</strong>，RS,RT分别是第一个和第二个操作寄存器，RD是<strong>目标寄存器</strong>，shamt是偏移量，func是函数对应的编码<ul><li>R型指令的操作码没记错的话都是<code>00000</code> </li></ul></li><li>所有的<strong>MIPS指令都是32位</strong>的，其中OP6位，寄存器都是5位，shamt是5位，funct是6位，address是16位 <ul><li>这是设计的原则：good design demands good compromises</li><li>计算机的两条原则<ul><li>指令用数字表示</li><li>程序可以存储在内存中，像数字一样读写</li></ul></li></ul></li></ul></li></ul><h3 id="1-2-条件判断指令"><a href="#1-2-条件判断指令" class="headerlink" title="1.2 条件判断指令"></a>1.2 条件判断指令</h3><ul><li><p>选择判断型指令</p><ul><li><code>beq register1,register2,L1 </code> 和<code>bne register1,register2,L1 </code> <ul><li>L1是一个行标号，可以在每行MIPS指令前写，跳转的时候就按照标号所在的位置进行跳转</li><li>相当于C语言中的goto</li></ul></li></ul></li><li><p>例子：实现一个简单的loop，其中变量g,h,i,j存储在s1-s4而数组A的基地址存储在s5</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Loop<span class="token operator">:</span>g<span class="token operator">=</span>g<span class="token operator">+</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">+</span>j<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span>h<span class="token punctuation">)</span> <span class="token keyword">goto</span> Loop<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">Loop:add $t1,$s3,$s3 #t1&#x3D;2*i  add $t1,$t1,$t1  add $t1,$t1,$s5 #address if A[i]  lw $t0,0($s1)  add $s1,$s2,$t0 #g&#x3D;g+A[i]  add $s3,$s3,$s4 #i&#x3D;i+j  bne $s2,$s3,Loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>跳转指令jr，用法是<code>jr $r</code> r的计算方式是当前所在地址+4*要跳转的行数<ul><li>一个函数结束的时候一定要写<code>jr $ra</code> 来返回主函数</li></ul></li></ul></li></ul><h3 id="1-3-Procedure-Instructions-过程调用指令"><a href="#1-3-Procedure-Instructions-过程调用指令" class="headerlink" title="1.3 Procedure Instructions 过程调用指令"></a>1.3 Procedure Instructions 过程调用指令</h3><ul><li>用于过程调用的寄存器和指令<ul><li><code>$a0-$a3</code> 是4个传递参数到函数的寄存器</li><li><code>$v0-$v1</code>是2个用于存储返回值的寄存器</li><li><code>$ra</code> 用于返回地址的寄存器</li><li><code>jal</code> (jump and link) 用于跳转到一个函数中，后面的参数为要跳转的地址，使用<code>jar $ra</code>返回主函数</li><li><code>$sp</code> 一个栈指针，MIPS汇编中的栈从高地址往低地址扩展，支持Push和Pop两种操作</li></ul></li></ul><h4 id="1-3-1-caller-saved和callee-saved寄存器"><a href="#1-3-1-caller-saved和callee-saved寄存器" class="headerlink" title="1.3.1 caller-saved和callee-saved寄存器"></a>1.3.1 caller-saved和callee-saved寄存器</h4><ul><li>Caller-saved register 易失性寄存器：用于保存每个调用过程中<strong>不需要在各个调用之间保留的</strong>临时变量</li><li>Callee-saved register 非易失性寄存器，用于<strong>保存</strong>需要在每个调用过程中保留的临时变量<ul><li>MIPS在函数调用的过程中需要保留<code>$s0-$s7</code> 和全局变量<code>$gp</code> 和栈指针<code>$sp</code>还有<code>$fp</code> </li></ul></li></ul><h4 id="1-3-2-案例1：编写一个简单的函数调用"><a href="#1-3-2-案例1：编写一个简单的函数调用" class="headerlink" title="1.3.2 案例1：编写一个简单的函数调用"></a>1.3.2 案例1：编写一个简单的函数调用</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span>  <span class="token function">leaf_example</span> <span class="token punctuation">(</span> <span class="token keyword">int</span>  g<span class="token punctuation">,</span>  <span class="token keyword">int</span>  h<span class="token punctuation">,</span>  <span class="token keyword">int</span>  i<span class="token punctuation">,</span>  <span class="token keyword">int</span>   j <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> f<span class="token punctuation">;</span>    f<span class="token operator">=</span><span class="token punctuation">(</span>g<span class="token operator">+</span>h<span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>其对应的MIPS汇编代码如下</p><ul><li><p>Assume: g ~ j —- r0 ~ r3    f —- r4  </p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">Leaf:addi $sp,$sp,-12 #adjust stack to make room for 3 items        sw $t1,8($sp)        sw $t0,4($sp)        sw $s0,0($sp)        add $t0,$a0,$a1#g+h        add $t1,$a2,$a3#i+j        sub $s0,$t0,$t1#f&#x3D;(g+h)-(i+j)        add $v0,$s0,$zero#return value in v0        lw * 3 #restore register for caller        add $sp,$sp,12        jr $ra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>往往在函数调用的时候把下一行的地址写在寄存器ra中，因此函数运行结束之后可以用<code>jr $ra</code> 指令返回到函数调用的下一句继续执行程序</p></li><li><p>函数编写的时候，s0-s7的寄存器需要被<strong>保护</strong>，不能在函数中使用使用的，t0-t9存储临时变量，可以视情况调用</p></li></ul></li></ul><h4 id="1-3-3-案例2：循环调用-Nested-Procedure"><a href="#1-3-3-案例2：循环调用-Nested-Procedure" class="headerlink" title="1.3.3 案例2：循环调用 Nested Procedure"></a>1.3.3 案例2：循环调用 Nested Procedure</h4><ul><li>简单的递归函数</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对应的MIPS汇编如下：</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">fact:add $sp,$sp,-8sw $ra,4($sp)sw $a0,0($sp)slti $t0,$a0,1 #test for n&lt;1beq $t0,$zero,L1add $v0,$zero,1 #return 1add $sp,$sp,8jr $ra #return to after jL1:addi $a0,$a0,-1jal fact #call fact with n-12000:lw $a0, 0($sp)      lw $ra, 4($sp)      addi $sp,$sp,8mul $v0,$a0,$v0jr $ra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>$fp</code>提供了一了一个stable base register</li><li><code>$gp</code>指向静态变量static variables</li></ul><h3 id="1-4-Character-Instruction-字符指令"><a href="#1-4-Character-Instruction-字符指令" class="headerlink" title="1.4  Character Instruction 字符指令"></a>1.4  Character Instruction 字符指令</h3><ul><li>操作字节的MIPS指令<ul><li>Load byte <code>lb $t0,0($sp)</code> 读取字节</li><li>Store byte <code>sb $t0,0($sp)</code> 存储字节</li><li>MIPS中表示字符串的三种方法<ul><li>在string的开头先写好长度</li><li>维护一个表示string长度的变量</li><li>在末尾使用结束标志表示一个字符串的末尾(C语言的choice)、</li></ul></li><li>同时还有</li></ul></li></ul><h4 id="案例-strcpy的MIPS实现"><a href="#案例-strcpy的MIPS实现" class="headerlink" title="案例 strcpy的MIPS实现"></a>案例 strcpy的MIPS实现</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> y<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>        i<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>其对应的MIPS代码如下，其中x和y的首地址位于a0和a1</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">strcpy:addi $sp,$sp,-4sw $s0,0(sp)        add $s0,$zero,$zero #i&#x3D;0L1:add $t1,$a1,$s0 # address of y[i] in $t1lb $t2,0($t1) add $t3,$a0,$s0sb $t2,0($t3)add $s0,$s0,1bne $t2,$zero,L1lw $s0,0($sp) # end of the string add $sp,$sp,4 # pop 1 word off the stackjr $ra #return <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-寻址模式"><a href="#1-5-寻址模式" class="headerlink" title="1.5 寻址模式"></a>1.5 寻址模式</h3><ul><li>Immediate addressing 立即数寻址<ul><li>在I型指令中出现，I型指令中的后16位作为一个二进制数字来使用</li><li>立即数有时候是地址，有时候是运算数</li></ul></li><li><strong>跳转</strong>寻址<ul><li>比如J指令前六位是000010，后面26位就表示要跳转到的地址<ul><li>这里的26位需要乘以4变成PC form</li></ul></li></ul></li><li>分支语句的寻址——相对寻址<ul><li>对于bne之类的分支语句的寻址，计算机采用<strong>相对寻址</strong><ul><li>PC(Program Counter)计算方式是<code>PC+4+offset*4</code>，offset是分支指令后16位</li></ul></li><li>原因是每条MIPS指令都是4字节长</li></ul></li><li>MIPS中的寻址方式的总结<ul><li>寄存器寻址：通过寄存器的编号来找到对应的寄存器，常见于R型指令</li><li>基地址寻址：用寄存器中存储的地址到内存中去寻址，比如lw和sw</li><li>立即数寻址：通过I型指令中的<strong>立即数</strong>来寻址</li><li>PC相对寻址：通过PC+4寻址</li><li>伪直接寻址：J型指令中经常出现</li></ul></li></ul><h3 id="1-6-MIPS指令总结"><a href="#1-6-MIPS指令总结" class="headerlink" title="1.6 MIPS指令总结"></a>1.6 MIPS指令总结</h3><ul><li><p>MIPS指令的Operands</p><ul><li>32 registers</li><li>Memory words</li></ul></li><li><p>MIPS编程中的注意点</p><ul><li>汇编程序可以不遵循编程原则</li><li>函数可以直接跳出</li><li>形参超过四个可以用栈来存储参数，在函数中弹出栈，返回值超过2个也要用堆栈，当然可以打破规则用闲置的寄存器传递参数</li><li>传递参数和获取返回值的寄存器a0-a3和v0-v1一般不直接参与运算</li></ul></li><li><p>C语言程序在计算机中的编译过程</p><ul><li>编译compiling：将C程序转化为汇编语言程序</li><li>汇编assembling：将汇编语言程序转化为机器码</li><li>链接linking：将object-modules(含各个库)转化成可执行程序</li></ul></li></ul><h3 id="Extra：文件的一些背景知识"><a href="#Extra：文件的一些背景知识" class="headerlink" title="Extra：文件的一些背景知识"></a>Extra：文件的一些背景知识</h3><ul><li><p>文件存储在硬盘的逻辑分区中，具体来说是扇区，一般为32KB</p><ul><li><p>100个1字节的文件占据了100*32KB的空间，而100KB的内容占据了4*32KB</p></li><li><p>文件的起始扇区存在目录中，多个扇区的顺序存在FAT表中，文件删除的时候需要在目录中先清空文件名，再在FAT表中设置各扇区为空闲</p></li><li><p>目录也是一个文件，每个文件在目录中是一条记录</p></li><li><p>内存/磁盘碎片整理</p><ul><li>文件分配的原理：从0开始，找到一块整块的能存下则放置文件，否则就进行分散分配</li><li>内存用于执行某个程序，则从0开始，找到一块整块的能存下，则分配邮与文件删除和内存释放造成碎片</li></ul></li></ul></li><li><p>链接库</p><ul><li>分为静态链接库和动态链接库，静态链接库可以直接链接，动态链接库作为外部调用</li><li>Windows系统中动态链接库的后缀是dll，静态链接库的后缀是lib</li><li>Linux系统中动态链接库的后缀是so，静态是a</li></ul></li><li><p>MIPS体系下的内存动态分配：从低位到高位依次是</p><ul><li>保留区，Text区</li><li>static data区</li><li>dynamic data区</li><li>stack</li></ul></li></ul><h3 id="1-7-MIPS-需要补充的内容"><a href="#1-7-MIPS-需要补充的内容" class="headerlink" title="1.7 MIPS 需要补充的内容"></a>1.7 MIPS 需要补充的内容</h3><h4 id="1-7-1-伪指令"><a href="#1-7-1-伪指令" class="headerlink" title="1.7.1 伪指令"></a>1.7.1 伪指令</h4><ul><li>伪指令：没有基于硬件实现，而是用现有的指令组合而成的一些功能<ul><li><code>move $rd, $rs</code>：值的拷贝， 实现的功能是rd=rs</li><li><code>blt $rs, $rt, RR</code> 比较地址的大小，如果rt的地址比较大则进行跳转</li></ul></li></ul><h4 id="1-7-2-系统调用"><a href="#1-7-2-系统调用" class="headerlink" title="1.7.2 系统调用"></a>1.7.2 系统调用</h4><ul><li><p>MIPS中的系统调用相当于一个内部中断，调用系统程序</p><ul><li>指令的格式是<code>syscall</code> 进行系统调用</li><li>系统调用会读取<code>$v0</code> 寄存器中的数字，根据不同的数字来执行不同的系统调用，将结果保存在a系列或者f系列的寄存器中</li></ul></li><li><p>系统调用的一个实例</p><ul><li>这个系统调用的作用就是把寄存器t0中的数字打印出来</li></ul></li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">li  $v0, 1           # service 1 is print integeradd $a0, $t0, $zero  # load desired value into argument register $a0, using pseudo-opsyscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="案例1：实现一个swap函数"><a href="#案例1：实现一个swap函数" class="headerlink" title="案例1：实现一个swap函数"></a>案例1：实现一个swap函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    temp<span class="token operator">=</span>v<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    v<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对应的MIPS代码如下，其中v的基地址在a0，k在a1，temp是t0</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">swap:add $t1,$a1,$a1add $t1,$t1,$t1add $t1,$a0,$t1 # t1 has the address of v[k]lw $t0,0($t1)lw $t2,4($t1)sw $t2,0($t1)sw $t0,4($t1)jr $ra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="案例2：指针和数组的区别"><a href="#案例2：指针和数组的区别" class="headerlink" title="案例2：指针和数组的区别"></a>案例2：指针和数组的区别</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">clear1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">clear2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第一种函数的MIPS实现<ul><li>只要size是正数就可以工作</li></ul></li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">move $t0,$zeroloop1:add $t1,$t0,$t0add $t1,$t1,$t1 # i*4add $t2,$a0,$t1 # address of a[i]sw $zero,0($t2)addi $t0,$t0,1slt $t3,$t0,$a1bne $t3,$zero,loop1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第二种函数的MIPS实现</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">move $t0,$a0 #p&#x3D;&amp;a[0]add $t1,$a1,$a1add $t1,$t1,$t1add $t2,$0,$t1 #t2&#x3D;&amp;a[size]loop2:sw $zero,0($t0) #*p&#x3D;0addi $t0,$t0,4 #p&#x3D;p+4slt $t3,$t0,$t2 # p&lt;&amp;array[size] ?bne $t3,$zero,loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-Arithmetic-for-computer-计算机运算"><a href="#2-Arithmetic-for-computer-计算机运算" class="headerlink" title="2.  Arithmetic for computer 计算机运算"></a>2.  Arithmetic for computer 计算机运算</h2><h3 id="2-1-数据表示：浮点数-无浮点数"><a href="#2-1-数据表示：浮点数-无浮点数" class="headerlink" title="2.1 数据表示：浮点数/无浮点数"></a>2.1 数据表示：浮点数/无浮点数</h3><h4 id="2-1-1-二进制数的表示"><a href="#2-1-1-二进制数的表示" class="headerlink" title="2.1.1 二进制数的表示"></a>2.1.1 二进制数的表示</h4><ul><li>K进制的数的表示方式 $N=\sum\limits_{i=m}\limits^{n-1}b_i\times K^i$ 其中0-n-1是整数位，-1到m是小数位<ul><li>无符号数：n位二进制无符号数可以表示的值的范围是：0到$2^n-1$ </li><li>有符号数：把最高位用来表示数的正负，0表示正数，1表负数<ul><li>存在的问题：存在正0(0000 0000)和负0(1000 0000)两种0</li></ul></li></ul></li></ul><ul><li>二进制数的一些操作<ul><li>对应的十进制数的计算方式是：对于n位有符号的二进制数，最高位的权重是$-2^{n-1}$,其余位的权重是$2^{n-1}$,将权重相加就得到了对应的十进制数</li><li>二进制的位扩展(sign extension)：把符号位扩展到高位的每一位 <ul><li>比如4位的1010扩展成8位就是11111010</li></ul></li><li>大小比较(MIPS指令)<ul><li>有符号数之间的比较用slt和slti(和立即数比较)</li><li>无符号数之间的比较用sltu和sltiu</li></ul></li></ul></li></ul><h4 id="2-1-2-各种二进制码"><a href="#2-1-2-各种二进制码" class="headerlink" title="2.1.2 各种二进制码"></a>2.1.2 各种二进制码</h4><ul><li><p><strong>有符号数</strong>的三种🐎：原码，反码，补码和移码</p><ul><li><p>能用这些码表示的都按照有符号数来处理</p></li><li><p>原码：由符号位+绝对值组成，最高位是符号位0或1，其余位是原本数字的<strong>绝对值</strong>表示</p></li><li><p>反码：由原码到补码的一种中间形式</p><ul><li>正数的反码就是其本身</li><li>负数的反码是<strong>符号位不变</strong>，其他位依次取反</li></ul></li><li><p><strong>Two’s Complement</strong> 补码</p><ul><li>正数的补码还是本身，负数的补码<strong>按位取反之后加1</strong>，对于负的整数$[X]_{c}=2^{n+1}-|X|$ </li></ul></li><li><p>overflow</p><ul><li>对于N位二进制数，如果数值小于$-2^{N-1}$或者大于$2^{N-1}-1$即为溢出</li><li>无符号数不考虑溢出的情况</li></ul></li><li><p>移码(biased-code)的表示</p><ul><li>由符号位+绝对值组成，计算的方法是<strong>补码的最高位取反</strong><ul><li>比如-128的补码是1000 0000，其对应的移码就是0000 0000</li><li>127的补码是0111 1111，其移码就是1111 1111</li></ul></li></ul></li></ul></li><li><p>三种🐎的比较(8位数字的情况下)</p><table><thead><tr><th>类型</th><th>原码</th><th>补码</th><th>移码</th></tr></thead><tbody><tr><td>范围</td><td>-127-127</td><td>-128-127</td><td>-128-127</td></tr><tr><td>最小数</td><td>1111 1111</td><td>1000 0000</td><td>1000 0000</td></tr><tr><td>最大数(+127)</td><td>0111 1111</td><td>0000 0000</td><td>1111 1111</td></tr><tr><td>0</td><td>0000 0000<br />1000 0000</td><td>0000 0000</td><td>1000 0000</td></tr><tr><td>优点</td><td>直观</td><td>加减运算方便</td><td>大小上数码完全一致</td></tr><tr><td>缺点</td><td>同号异号，运算麻烦</td><td>大小比较需要单独处理</td><td>符号位和别的码不同</td></tr></tbody></table></li></ul><h3 id="2-2-汉字系统"><a href="#2-2-汉字系统" class="headerlink" title="2.2 汉字系统"></a>2.2 汉字系统</h3><ul><li>ASCII码：美国信息交换标准码<ul><li>标准的ASCII码只有7位，但是为了方便计算机处理，扩展成了1字节(8位)</li><li>ASCII码中有128个字符，其中可打印字符96个，控制字符32个</li><li>后来因为128个字符不够又扩展了新的128个</li><li>常见的ASCII码：A位于65，a位于97</li></ul></li><li>汉字的表示<ul><li>GB2313区位码</li><li>输入码：五笔，拼音等等</li><li>字模码：<ul><li>用8x8的点阵表示ASCII码</li><li>用16x16的点阵表示汉字，可以用16个16位的二进制数来表示一个汉字</li></ul></li></ul></li></ul><h3 id="2-3-Addition-amp-Subtraction"><a href="#2-3-Addition-amp-Subtraction" class="headerlink" title="2.3 Addition &amp; Subtraction"></a>2.3 Addition &amp; Subtraction</h3><ul><li><p>加减法</p><ul><li><p>加法：原码直接相加，进位给下一位</p></li><li><p>减法：直接相减，或者将两个数的补码相加(此时得到的结果是补码)</p></li><li><p>overflow，比如1111 1111+1111 1010 = 1 1111 1001，1000 0001 + 1111 1110 = 0111 1111</p></li><li><p>MIPS中处理溢出的方式是<strong>interrupt</strong>，溢出指令的地址被<strong>保存在寄存器中</strong>，计算机跳到预定地址以为该异常调用适当的例程。中断的地址将被保存，以便在某些情况下程序可以在执行纠正代码后继续执行</p></li><li><p>其他的处理方式还有：在ALU中进行硬件检查；interrupt和EPC存储指令地址</p></li><li><p>符号数加法的MIPS代码</p></li><li><p>无符号数加法的MIPS代码</p></li><li><p>取相反数的运算方式：将数字和0进行nor运算</p></li></ul></li><li><p>加法器的设计</p><ul><li><p>最简单的一位ALU：进行and或者or操作</p><p><img src="/2021/05/03/pcs/image-20200808160951428.png" alt="image-20200808160951428"></p></li><li><p>一些名词的简称</p><ul><li>OF: overflow 判断是否溢出，最高进位和次高进位的<strong>异或</strong> </li><li>CF: CarryOut 进位的值</li><li>ZF：zero，当结果为0的时候ZF=1，否则是0</li><li>SF：符号位的判断，正0负1</li><li>PF：奇偶校验</li></ul></li><li><p>半加器 half adder(不能和进位Carryout进行运算)</p><ul><li><p><code>sum = a xor b</code>, <code>carry = a or b</code> 其设计如下</p><p><img src="/2021/05/03/pcs/image-20200808161040759.png" alt="image-20200808161040759"></p></li></ul></li><li><p>全加器 full adder</p><ul><li>运算规则,本位和$Sum=A\oplus B\oplus Carry$，进位$Carry=AB+BCarry+CarryA$ </li><li>二阶全加器的设计</li></ul><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200527153732006.png" alt="image-20200527153732006" style="zoom:80%;" /></li><li><p>1 bit的ALU的设计：包含AND, OR , ADD三种指令</p><ul><li>可以通过输入的值operation来控制输出结果，比如operation=0输出的就是and运算的结果</li><li>第一个Carry in的值是0</li></ul></li></ul><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200527154253716.png" alt="image-20200527154253716" style="zoom:80%;" /><ul><li><p>32-bit的ALU：实际上是32个1bit的ALU连接起来进行运算</p><ul><li>如果是逻辑运算，就是32个1bit的ALU分别输出对应位上逻辑运算的结果，然后输出</li><li>如果是算术运算，Carry In和Carry Out会在ALU之间按顺序传递下去，实现加法的进位</li></ul></li><li><p>1bit ALU的扩展：支持减法</p><ul><li>此时操作码还是3种，参数Binvert控制第二个运算数是否取反</li></ul><p><img src="/2021/05/03/pcs/image-20200808171032402.png" alt="image-20200808171032402"></p><ul><li>由于支持减法，因此ALU也可以支持大小的比较，比较大小的操作码为2<ul><li>加入一个Less输入作为大小判断时的输出</li></ul></li></ul></li><li><p>32-bit的完全ALU</p><img src="image-20200808183650715.png" alt="image-20200808183650715" style="zoom:80%;" /><ul><li>还可以对32个result添加一个zero检查器</li></ul></li><li><p>加法器的基本原理</p><ul><li>完全串行的进位方式，一次运算需要3个与门，2个或门，消耗2份的时间，完成32位全加法需要的时间是一次加法运算的的32倍</li><li>并行计算的进位方式，进位的ci计算全部转换成第一位的a0,b0,c0的=，依次进行迭代</li><li>先行进位(并行)用$g_i=a_ib_i,p_i=a_i+b_i$来简化运算</li><li>组内并行，组之间串行：4位一组</li></ul></li></ul></li><li><p>ALU：算术逻辑单元</p><ul><li><p>一个最基本的ALU的结构图如下图所示</p><img src="image-20200808183928282.png" alt="image-20200808183928282" style="zoom:80%;" /></li><li><p>ALU控制线路：000对应and，001对应or，010对应add，110对应sub，111对应less than</p></li></ul></li></ul><h3 id="2-4-Multiplication-amp-amp-Division"><a href="#2-4-Multiplication-amp-amp-Division" class="headerlink" title="2.4 Multiplication &amp;&amp; Division"></a>2.4 <strong>Multiplication</strong> &amp;&amp; Division</h3><ul><li><p>和十进制乘法一样，可以列竖式计算</p><ul><li>一一乘法口诀表：00得0，11得1，01得0，10得0</li><li>乘法得两个因数分别叫做multiplicand和multiplier</li></ul></li><li><p>乘法算法1</p><ul><li><p>Binary multiplication 列竖式计算，具体过程就和十进制一样</p></li><li><p>逻辑图：乘数是32位，被乘数，积和ALU是64位</p><ul><li><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200529102007327.png" alt="image-20200529102007327" style="zoom:80%;" /></li><li><p>需要32次迭代，计算非常缓慢，需要64位加法器1个，64位寄存器2个，32位寄存器1个，移位2次</p><img src="image-20200808191934189.png" alt="image-20200808191934189" style="zoom:80%;" /></li></ul></li></ul></li><li><p>乘法算法2</p><ul><li>Don’t shift the multiplicand，Instead,<strong>shift</strong> <strong>the</strong> <strong>product</strong>，Shift the multiplier</li><li>逻辑图，积的寄存器的左半边才会进行change</li></ul><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200529102827830.png" alt="image-20200529102827830" style="zoom:80%;" /><ul><li><p>2个64位的寄存器其中一个变成了32位</p><img src="image-20200808192241507.png" alt="image-20200808192241507" style="zoom:80%;" /></li></ul></li><li><p>乘法算法3</p><ul><li>1个32位加法器，1个64位寄存器，1个32位寄存器，移位操作1次</li></ul><img src="image-20200808193055418.png" alt="image-20200808193055418" style="zoom:67%;" /></li></ul><h4 id="2-4-1-有符号数的乘法"><a href="#2-4-1-有符号数的乘法" class="headerlink" title="2.4.1 有符号数的乘法"></a>2.4.1 有符号数的乘法</h4><ul><li><p>补码乘法</p><ul><li><p>$(A\times B)<em>{补}=A\times B</em>{补}$ 已知AB的补码，可以把A转换成原码和B的补码进行计算</p></li><li><p>无符号数的补码之积等于积的补码</p></li></ul></li><li><p><strong>Booth 算法</strong>⭐⭐⭐</p><ul><li>基本原理：用于<strong>二进制补码的相乘</strong>的运算，从最低位开始，只要这串数字为0就不执行任何操作，当遇到第一个1时执行一次减法，也就是减去被乘数和该位权值的积，对于后面的1不进行操作，再碰上0就加权值，如此往复</li><li>两个因数都用补码的形式参加乘法运算，<strong>结果是积的补码</strong></li><li>加速的原理<ul><li>Booth算法会导致addition减少而shift增加，如果shift的效率更高就会使得运算加快</li></ul></li><li>也就是需要判断连续的两位<ul><li>10 减去1所在位置的权重</li><li>00 不进行操作</li><li>11 不进行操作</li><li>01 加上0所在位置的权重</li><li>为了方便，把第-1位当作0来使用</li></ul></li></ul></li></ul><h4 id="2-4-2-二进制数的除法"><a href="#2-4-2-二进制数的除法" class="headerlink" title="2.4.2 二进制数的除法"></a>2.4.2 二进制数的除法</h4><ul><li><p>Dividend = quotient x divisor + remainder  被除数=商x除数+余数</p></li><li><p>算法1</p><ul><li>需要64位加法器1个，64位寄存器2个，32位寄存器1个，移位操作两次</li></ul><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200603141843168.png" alt="image-20200603141843168" style="zoom:80%;" /></li><li><p>算法2</p><ul><li>需要32位加法器1个，64位寄存器1个，32位寄存器2个，移位操作两次</li></ul><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200603142121548.png" alt="image-20200603142121548" style="zoom:67%;" /></li><li><p>算法3</p><ul><li><p>需要32位加法器1个，64位寄存器1个，32位寄存器1个，位移操作2次</p><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200603142319359.png" alt="image-20200603142319359" style="zoom:67%;" /></li></ul></li><li><p>有符号数的除法</p><ul><li>基本原则：计算商的时候把除数和被除数都当作正数，得出一个非负数的商，然后根据除数和被除数的符号确定商的符号，在根据关系计算余数<ul><li>比如7/2=3余1，而-7/2=-3余-1，7/-2=-3余1，-7/-2=3余1</li></ul></li><li>除数不能为0，负责会overflow</li></ul></li></ul><h3 id="2-5-Float-浮点数的表示——IEEE754标准"><a href="#2-5-Float-浮点数的表示——IEEE754标准" class="headerlink" title="2.5 Float 浮点数的表示——IEEE754标准"></a>2.5 Float 浮点数的表示——IEEE754标准</h3><ul><li><p>IEEE制定的舍入规则</p><ul><li>ceil 向上取整 </li><li>floor向下取整</li><li>int 抹去小数部分</li><li>三个特殊的数字 <code>NaN(Not a Number)</code>, 正负无穷大</li></ul></li><li><p>二进制的浮点数的表示方式是 <code>1.xxxxxxxx * 2^yyyyyy</code> ，类似于十进制中的科学计数法，</p><p>用公式表示为$x=(-1)^s\times 1.M\times 2^{E-127}$ </p><ul><li>E是阶码，一定是一个非负数，表示的范围是0-255(float中)，0-1023(double中)</li><li>M也叫significand，E叫exponent </li><li>浮点数的精度：用S+E+M的顺序来表示一个浮点数<ul><li>单精度浮点数(float)中s占1位，E占8位，M占23位，一共32位</li><li>双精度浮点数(double)中s占1位，E占11位，M占52位，一共64位</li></ul></li><li>浮点数进位的计算方式：<ul><li>先确定符号位S，将数字取绝对值</li><li>将数字转换到1.多的范围里，然后确定E，获取尾数M的十进制表示</li><li>将M转换成23位二进制，具体方法是不断*2，如果结果超过，取整数部分作为每一位上的结果</li><li><strong>注意尾数需要四舍五入，也就是计算24位，如果24位是1就在前23位向上进1</strong> </li></ul></li></ul></li><li><p>浮点数的加减法</p><ul><li>把十进制的全部转换成二进制浮点数的原码</li><li>将小数点对齐，进行加法运算</li><li>说了半天其实真的算起来加减乘除都要靠转化成十进制来计算</li></ul></li></ul><h2 id="3-CPU结构"><a href="#3-CPU结构" class="headerlink" title="3. CPU结构"></a>3. CPU结构</h2><h3 id="3-1-计算机的基本结构"><a href="#3-1-计算机的基本结构" class="headerlink" title="3.1 计算机的基本结构"></a>3.1 计算机的基本结构</h3><ul><li><p>计算机的组成结构</p><ul><li><p>CPU</p><ul><li>control unit 控制单元</li><li>datapath 数据通道<ul><li>path</li><li>ALU 算术逻辑单元</li><li>registers 寄存器</li></ul></li></ul></li><li><p>Memory 内存</p></li><li><p>I/O interface 输入/输出接口</p></li></ul></li><li><p>简单的MIPS实现原理</p><img src="image-20200809135614210.png" alt="image-20200809135614210" style="zoom:80%;" /><ul><li>不 言 而 喻 ，一 目 了 然</li></ul></li></ul><h3 id="3-2-基本的功能组件"><a href="#3-2-基本的功能组件" class="headerlink" title="3.2 基本的功能组件"></a>3.2 基本的功能组件</h3><p>这一部分貌似是数逻学的，没修过所以这里先学一学</p><ul><li><p>逻辑门电路：由于非常天空上的图非常难看，所以不贴图了</p><ul><li><p>与门电路：符号是半个椭圆型</p><p><img src="/2021/05/03/pcs/gateand.gif" alt="gateand"></p></li><li><p>或门电路：符号是月牙形</p><p><img src="/2021/05/03/pcs/gateor.gif" alt="gateor"></p></li><li><p>非门电路：符号是三角形+圆点</p><p><img src="/2021/05/03/pcs/gatenot.gif" alt="gatenot"></p></li><li><p>异或门电路：$(A\and \neg B)\or(\neg A\and B)$ 由两个与门和一个或门组合而成</p><p><img src="/2021/05/03/pcs/gatexor.gif" alt="gatexor"></p></li></ul></li><li><p>组合逻辑 combinational logic</p><ul><li><p>译码器 Decoder</p><ul><li><p>给出一组输入，所有输出端的输出只有一个与其他所有的输出都不同。译码器可以用于地址选择，如果译码器由n个输入端，有$2^n$个输出端，则是完全译码器</p></li><li><p>由若干个非门电路和与门电路组成</p><ul><li><p>2-4 译码器</p><p><img src="/2021/05/03/pcs/decode24.gif" alt="decode24"></p></li><li><p>3-8 译码器</p><p><img src="/2021/05/03/pcs/decode-1597027905491.gif" alt="decode"></p></li></ul></li></ul></li><li><p>多路选择器 MUX</p><ul><li><p>有多个数据输入，只能有一个数据输出，通过控制信号决定哪个输入被连接到输出端</p></li><li><p>通过控制信号，对输出进行筛选，信号是若干个0或1，通过<strong>非门和与门的组合</strong>使得恰好只有一个输入值会被原样输出，n位的信号刚好可以控制$2^n$个输入数据</p><p><img src="/2021/05/03/pcs/mux.gif" alt="mux"></p><ul><li><p>四个选择的多路选择器MUX实现原理</p><p><img src="/2021/05/03/pcs/mux4.gif" alt="mux4"></p></li></ul></li></ul></li><li><p>移位器 Shift</p><ul><li><p>使用<strong>移位寄存器</strong>或者<strong>多路选择器</strong>实现移位的操作，多路选择器的本质是<strong>空间换时间</strong>，利用复杂的设计提高位移速度</p></li><li><p>固定的移位可以直接通过输入输出线的错位来实现</p><p><img src="/2021/05/03/pcs/sft2.gif" alt="sft2"></p></li></ul></li><li><p>符号扩展 Sign Extend</p><ul><li><p>对于有符号的补码进行扩展，并且正数和负数的扩展方式不同，对于补码的扩展可以通过重复符号位的方式实现，对于无符号数的扩展</p><p><img src="/2021/05/03/pcs/signext.gif" alt="signext"></p></li></ul></li></ul></li><li><p>状态元件</p><ul><li>状态元件和组合逻辑的区别<ul><li>组合逻辑的输出只和输入值有关</li><li>状态原件的输出还<strong>和状态元件自身的状态有关</strong>，一般输入输出有一个时钟的延时</li></ul></li><li>寄存器单元<ul><li><p>输入的值有：clk时钟，<strong>RegWrite 写入控制</strong>，idat <strong>32位</strong>的输入数据</p></li><li><p>输出的值有：odat 32位的输出数据</p><p><img src="/2021/05/03/pcs/register.gif" alt="register"></p></li></ul></li></ul></li><li><p>复杂模块</p><ul><li><p>ALU 算术逻辑单元</p><ul><li><p>算术逻辑单元ALU可以执行算术逻辑运算，是CPU中最重要的运算部件</p></li><li><p>支持的运算包括加减法，逻辑and和or，以及slt，采用3位控制信号</p><ul><li>控制信号中000表示and，001表示or，010表示加法，110表示减法，111表示slt</li></ul><p><img src="/2021/05/03/pcs/image-20200809184700155.png" alt="image-20200809184700155"></p></li><li><p>32位ALU简化的示意图如下</p><p><img src="/2021/05/03/pcs/alu.gif" alt="alu"></p></li><li><p>输入：两个32位的数据，ALUop <strong>3位的操作码ALUoper</strong></p></li><li><p>输出：</p><ul><li>Result 32位的输出</li><li>zero零标志，这个值为1的时候表示结果为0，为0的时候表示结果不是0</li><li>carryout <strong>进位</strong>标志</li><li>overflow 溢出标志</li></ul></li></ul></li><li><p>ALU 控制器：为了让常见的运算(加减法)更加容易控制</p><ul><li><p>输入的内容：</p><ul><li>ALUop 两位的<strong>控制信号</strong></li><li>Func 指令的功能字段</li></ul></li><li><p>输出：ALUoper ——ALU的操作码，有3位</p><table><thead><tr><th>ALUop</th><th>Function Field(F5-F0)</th><th>ALU</th></tr></thead><tbody><tr><td>00</td><td>XXXXXX</td><td>010——add</td></tr><tr><td>01</td><td>XXXXXX</td><td>110——sub</td></tr><tr><td>1X</td><td>XX0000</td><td>010——add</td></tr><tr><td>1X</td><td>XX0010</td><td>110——sub</td></tr><tr><td>1X</td><td>XX0100</td><td>000——and</td></tr><tr><td>1X</td><td>XX0101</td><td>001——or</td></tr><tr><td>1X</td><td>XX1010</td><td>111——slt</td></tr></tbody></table></li><li><p>ALU控制器的示意图：</p><p><img src="/2021/05/03/pcs/aluctrc.gif" alt="aluctrc"></p></li></ul></li><li><p>算术逻辑单元的多级控制</p><ul><li><p>用ALU控制器控制ALU，示意图如下：</p><p><img src="/2021/05/03/pcs/aluctrl.gif" alt="aluctrl"></p></li></ul></li></ul></li><li><p>存储器</p><ul><li><p>存储器是多个寄存器和集合，由<strong>译码器</strong>选择指定的寄存器单元(通过地址)</p></li><li><p>存储器分为只读存储器和读写存储器</p><ul><li><p>指令存储器是<strong>只读</strong>存储器(Read Only Memory, ROM)</p></li><li><p>数据存储器是读写存储器(RAM) 可以根据读写控制信号，一次读/写一个32位的数据</p><ul><li>读写<strong>共用一个地址输入端</strong>，读写数据分别和存储器连接</li></ul><p><img src="/2021/05/03/pcs/image-20200809235040985.png" alt="image-20200809235040985"></p></li><li><p>存储器按照字节编址，MIPS采用了32位的<strong>地址线</strong>，可寻址空间为$2^{32}=4GB$， 数据线也是32位</p></li></ul></li><li><p><strong>寄存器组</strong>：</p><ul><li><p>寄存器组是CPU的主要部件</p></li><li><p>因为很多指令都有2-3个操作数，因此需要用寄存器组来实现多路同时读写</p></li><li><p>寄存器组的读</p><ul><li><p>32个32位的存储单元，由两路5位寄存器地址选择读出寄存器中的内容</p><p><img src="/2021/05/03/pcs/rgfr.gif" alt="rgfr"></p></li></ul></li><li><p>寄存器组的写</p><ul><li><p>由5位地址选择器选择写入的寄存器，数据端位32位</p></li><li><p>信号RehWrite 作为允许写入操作的控制信号</p><p><img src="/2021/05/03/pcs/rgfw.gif" alt="rgfw"></p></li></ul></li><li><p>寄存器组的整体结构图</p><p><img src="/2021/05/03/pcs/image-20200810001953782.png" alt="image-20200810001953782"></p></li><li><p>MIPS的一个寄存器组一共有32个32位的寄存器，编号为0-31，采用5位二进制寻址</p><ul><li><p>各个寄存器的功能之前已经提到过了，在第一部分MIPS指令系统里面</p><p><img src="/2021/05/03/pcs/regfile1.gif" alt="regfile1"></p></li><li><p>输入数据</p><ul><li>clk 时钟</li><li>rst 种植控制</li><li>regA，regB两路5位读的寄存器号，regW 一路写的寄存器号</li><li>wdat写入的数据</li><li>regWrite：1的时候表示允许写入</li></ul></li><li><p>输出：Adat，Bdat 二路32位读出的数据</p></li></ul></li></ul></li></ul></li></ul><h3 id="3-3-单指令数据通道"><a href="#3-3-单指令数据通道" class="headerlink" title="3.3 单指令数据通道"></a>3.3 单指令数据通道</h3><ul><li><p>PC组件</p><ul><li><p>在MIPS中，所有的指令都是等长的，每条指令4字节(32位)，在PC中，保存着当前执行指令的地址</p></li><li><p>PC的输出接到指令存储器的地址端，每条指令执行之后，PC+4，在下一个时钟的时候就自动转到执行下一条指令</p><p><img src="/2021/05/03/pcs/fetch.gif" alt="fetch"></p></li></ul></li><li><p>R指令的数据通道</p><ul><li><p>回忆：MIPS中R指令的格式为6位操作码+3个五位的操作数(rs,rt,rd 其中rd是目标寄存器)+5位shamt+6位func</p><p><img src="/2021/05/03/pcs/singlert.gif" alt="singlert"></p></li></ul></li><li><p>LW/SW指令的数据通道</p><ul><li><p>lw指令的格式：<code>100011+rs+rd+offset</code>, 表示<code>$rd=Memory[$rs + offset]</code> </p><p><img src="/2021/05/03/pcs/singlelw.gif" alt="singlelw"></p></li><li><p>sw 指令的格式<code>101011+rs+rt+offset</code> ，表示<code>Memory[$rs + offset] = $rt</code>  </p><p><img src="/2021/05/03/pcs/singlesw-1597027153950.gif" alt="singlesw"></p></li></ul></li><li><p>BEQ指令的数据通道</p><ul><li><p>BEQ指令：<code>pc+=4; if(r1==r2) PC+= address*4;</code> </p><p><img src="/2021/05/03/pcs/singlebeq.gif" alt="singlebeq"></p></li></ul></li><li><p>J指令：0-25位是一个address，<code>PC=&#123;PC[31-28], IR[25-0], &#123;00&#125;&#125;</code> </p><p><img src="/2021/05/03/pcs/singlej.gif" alt="singlej"></p></li><li><p>addi指令:<code>rd = rs + Data</code> </p></li></ul><p><img src="/2021/05/03/pcs/singleaddi.gif" alt="singleaddi"></p><h3 id="3-4-单时钟CPU数据通道"><a href="#3-4-单时钟CPU数据通道" class="headerlink" title="3.4 单时钟CPU数据通道"></a>3.4 单时钟CPU数据通道</h3><ul><li><p>接入和接出的实现原理</p><ul><li><p>分支接出：对于电路，从一组线接出或者部分接出都可以</p><p><img src="/2021/05/03/pcs/line.gif" alt="line"></p></li><li><p>多路接入：使用多路选择器MUX</p><ul><li><p>当有多个信号接入同一个输入端，不能直接合并，必须通过MUX选择性接入</p></li><li><p>通过控制信号来决定<strong>哪一个输入连接到输出</strong>端</p><p><img src="/2021/05/03/pcs/mux3.gif" alt="mux3"></p></li></ul></li></ul></li><li><p>指令的组合：可以通过多路选择器的设计将指令合并到一个数据通道中</p><ul><li><p>多路选择器对于不同的指令(R型，I型，J型)会选择不同的路径</p></li><li><p>需要刻在DNA里的单时钟CPU实现原理图：</p><p><img src="/2021/05/03/pcs/single1.gif" alt="single1"></p></li><li><p>新增control unit控制单元，可以发出一系列的<strong>控制信号</strong>，对不同的指令取不同的值</p><p><img src="/2021/05/03/pcs/sigctrl.gif" alt="sigctrl"></p><ul><li><p>控制信号控制了数据的流向和操作类型</p></li><li><p>可以将指令码各位进行逻辑and运算，保证一条线只有当操作码为对应指令的时候才是1，否则为0</p></li><li><p>控制单元内部原理示意图：</p><p><img src="/2021/05/03/pcs/ctrlunjt-1597029836258.gif" alt="ctrlunjt"></p></li><li><p>控制信号对应表</p><table><thead><tr><th>控制信号</th><th>R</th><th>LW</th><th>SW</th><th>BEQ</th></tr></thead><tbody><tr><td>RegDst</td><td>1</td><td>0</td><td>x</td><td>x</td></tr><tr><td>ALUsrc</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>ALUop</td><td>10</td><td>00</td><td>00</td><td>01</td></tr><tr><td>MemtoReg</td><td>0</td><td>1</td><td>x</td><td>x</td></tr><tr><td>RegWrite</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>MemRead</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>MemWrite</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>Branch</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></li><li><p>该数据通道的若干假设</p><ul><li>等长的指令结构，每条指令都是32-bit，其中最高的6位是操作码</li><li>内存以字节编址，32位的寻址范围</li><li>寄存器组公有32个32位的寄存器(5-bit寻址)，其中<ul><li>0号寄存器的值恒为0</li><li>31号寄存器是指令的地址寄存器，用于存放<strong>子程序的地址</strong> </li><li>29号是堆栈指针寄存器</li></ul></li><li>Memory，Register File，ALU的操作分别需要2，1，2个单位的时间，其他的时间可以忽略不计</li></ul></li></ul></li><li><p>各项指令执行所需要的时间统计表</p><table><thead><tr><th>指令</th><th>取指令</th><th>寄存器</th><th>运算</th><th>存储器</th><th>回写</th><th>合计</th><th>使用率</th></tr></thead><tbody><tr><td>R</td><td>2</td><td>1</td><td>2</td><td></td><td>1</td><td>6</td><td>44%</td></tr><tr><td>LW</td><td>2</td><td>1</td><td>2</td><td>2</td><td>1</td><td>8</td><td>24%</td></tr><tr><td>SW</td><td>2</td><td>1</td><td>2</td><td>2</td><td></td><td>7</td><td>12%</td></tr><tr><td>BEQ</td><td>2</td><td>1</td><td>2</td><td></td><td></td><td>5</td><td>18%</td></tr><tr><td>J</td><td>2</td><td></td><td></td><td></td><td></td><td>2</td><td>2%</td></tr></tbody></table><ul><li>指令执行的平均时间为6.34</li><li>在单数据通道中，每条指令只能设置一次各种控制信号，所以只能以需要时间最长的指令为一个时钟，也就是8<ul><li>执行效率：6.34/8=79.25% 比较低</li></ul></li></ul></li></ul></li><li><p>单时钟数据通道新增指令设计</p><ul><li><p>设计机器码的格式：操作码6位是固定的，其他的东西安排在剩下的26位里面</p></li><li><p>在原设计图上增加必要的组件和通路</p><ul><li>寄存器组和存储器，ALU等一般不变，可以实现新的指令功能</li></ul></li><li><p>添加新的控制信号：对于添加的新控制信号，一般原指令的默认值为0</p></li><li><p>举例：新增<code>push $r</code> 指令</p><ul><li>指令的执行过程</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">$sp&#x3D;$sp-4Memory[$sp]&#x3D;$r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>方案1：由于指令里只有一个操作数r，因此可以将sp直接涉及到指令里面，sp有读写操作，而r只读，需要增加额外的信号4，为了连接简便，将ALUsrc改为4选1<ul><li>指令格式是<code>000000+sp+r+sp+shamt+push</code> </li><li>控制信号中，ALUsrc设置为10</li></ul></li><li>方案2：4可以写在立即数中，但此时第三个寄存器不能放sp，需要R1连接到R3，作为写sp<ul><li>指令格式是<code>push+sp+r+0004</code> </li><li>信号设计：RegDst设置为10</li></ul></li></ul></li></ul></li></ul><h3 id="3-5-多时钟CPU设计"><a href="#3-5-多时钟CPU设计" class="headerlink" title="3.5 多时钟CPU设计"></a>3.5 多时钟CPU设计</h3><h4 id="3-5-1-DNA里的图"><a href="#3-5-1-DNA里的图" class="headerlink" title="3.5.1 DNA里的图"></a>3.5.1 DNA里的图</h4><ul><li><p>由于单时钟只能以耗时最长的指令为时钟，为了提高效率，可以考虑<strong>缩短时钟</strong>，以主要部件的执行时间为时钟，重新设置一遍控制信号</p><ul><li><p>每个部件在每个时钟<strong>分别执行各自的任务</strong>，在各个主要部件之间用寄存器存放临时的结果</p></li><li><p>IR：指令寄存器，MDR：内存数据寄存器</p><p><img src="/2021/05/03/pcs/datapathm.gif" alt="datapathm"></p></li><li><p>本数据通道基于如下假设——和单时钟基本一样</p><ul><li>等长的指令结构，每条指令都是32-bit，最高的六位是操作码</li><li>内存以字节编址，32位的寻址空间是4GB，有32个32位的寄存器</li><li>Memory，Register File和ALU的操作分别需要2，1，2个时间，其他的忽略不计</li><li>微指令有七个字段，分别是ALU，Reg，Mem，PC等等</li></ul></li><li><p>多周期CPU的数据通道(第二张需要<strong>刻在DNA里的图</strong>) </p><p><img src="/2021/05/03/pcs/mulc.gif" alt="mulc"></p></li></ul></li></ul><h4 id="3-5-2-基本指令的多周期运行过程"><a href="#3-5-2-基本指令的多周期运行过程" class="headerlink" title="3.5.2 基本指令的多周期运行过程"></a>3.5.2 基本指令的多周期运行过程</h4><ul><li><p>多时钟周期的五个执行阶段：每个指令需要<strong>3-5个周期</strong></p><ul><li><p>IF阶段：Instruction Fetch 获取指令,具体的步骤如下</p><ul><li>使用PC来获取需要执行的指令，放到指令寄存器中</li><li>PC+4然后把结果返回给PC(上面两步基本上是同步进行的</li><li>第一阶段所有的指令基本都是一样的</li></ul></li><li><p>其Register-Transfer Language(RTL) 是</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">IR <span class="token operator">=</span> Memory<span class="token punctuation">[</span>PC<span class="token punctuation">]</span><span class="token punctuation">;</span>PC <span class="token operator">=</span> PC <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>ID：指令得而<strong>译码</strong>和register fetch</p><ul><li><p>在需要的时候，读取寄存器rs和rt中的内容</p></li><li><p>如果是分支指令就需要计算分支的地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">A <span class="token operator">=</span> Reg<span class="token punctuation">[</span>IR<span class="token punctuation">[</span><span class="token number">25</span><span class="token operator">-</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>B <span class="token operator">=</span> Reg<span class="token punctuation">[</span>IR<span class="token punctuation">[</span><span class="token number">20</span><span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>ALUOut <span class="token operator">=</span> PC <span class="token operator">+</span> <span class="token punctuation">(</span>sign<span class="token operator">-</span><span class="token function">extend</span><span class="token punctuation">(</span>IR<span class="token punctuation">[</span><span class="token number">15</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>EX(BC)：执行，内存地址计算或者分支选择完成</p><ul><li>ALU根据指令类型执行一种指令</li><li>对于内存调用 <code>ALUOut = A + sign-extend(IR[15-0]);</code> </li><li>对于R型指令，<code>ALUOut = A op B;</code> </li><li>对于分支指令：<code>if (A == B) PC = ALUOut;</code> </li><li>对于jump指令，<code>PC = PC[31-28] + IR[25-0] &lt;&lt; 2;</code> </li></ul></li><li><p>MEM(WB)：<strong>内存访问</strong>或者R型指令的完成</p><ul><li>对于lw，<code>MDR = Memory[ALUOut];</code> </li><li>对于sw，<code>Memory[ALUOut] = B;</code> </li><li>对于R型的指令，<code>Reg[rd] = Reg[IR[15-11]] = ALUOut;</code> </li></ul></li><li><p>WB：write-back步骤</p><ul><li>对于lw指令，<code>Reg[rt]=Reg[IR[20-16]]= MDR;</code></li></ul></li><li><p>总结：</p><p><img src="/2021/05/03/pcs/image-20200822231538639.png" alt="image-20200822231538639"></p><ul><li>所以R型指令4割周期，J型指令和分支指令都是3个周期，内存读写都是5个周期</li></ul></li></ul><h4 id="3-5-3-控制信号和有限状态机"><a href="#3-5-3-控制信号和有限状态机" class="headerlink" title="3.5.3 控制信号和有限状态机"></a>3.5.3 控制信号和有限状态机</h4><ul><li><p>重要的控制信号和其作用</p><table><thead><tr><th>信号</th><th>设置为0时的作用</th><th>设置为1时的作用</th></tr></thead><tbody><tr><td>RegDst</td><td>设置目标寄存器为rt(20:16)</td><td>WB阶段设置目标寄存器为rd(15:11)</td></tr><tr><td>RegWrite</td><td>None</td><td>目标寄存器的输入时Write data input的值</td></tr><tr><td>ALUScrA</td><td>第一个ALU的操作数是PC</td><td>ALU的操作数来自A寄存器</td></tr><tr><td>MemRead</td><td>None</td><td>内存中输入地址指定的内容作为输出</td></tr><tr><td>MemWrite</td><td>None</td><td>内存中输入地址指定的位置的值变为输入的值</td></tr><tr><td>MemtoReg</td><td>写入寄存器中的输入数据来自ALUout</td><td>写入寄存器的数据来自MDA</td></tr><tr><td>IorD</td><td>PC向内存单元提供地址</td><td>ALUOut提供地址</td></tr><tr><td>IRWrite</td><td>None</td><td>内存的输出被写入IR</td></tr><tr><td>PCWrite</td><td>None</td><td>PC被改变，被PCSource控制</td></tr><tr><td>PCWriteCond</td><td>None</td><td>如果ALU的零输出active，PC被改变</td></tr></tbody></table><table><thead><tr><th>信号</th><th>值和对应的作用</th></tr></thead><tbody><tr><td>ALUOp</td><td>00：加法运算，01减法运算，10按照funct来决定ALU操作</td></tr><tr><td>ALUScrB</td><td>00：第二个输入ALU的是寄存器B<br /> 01：第二个输入是常数4<br /> 10：第二个输入是符号扩展的，IR的低16位<br /> 11：第二个输入是符号扩展的，IR的低16位移位了2位的结果</td></tr><tr><td>PCSource</td><td>00：ALU的输出(PC+4)被写回PC<br /> 01：分支目标地址被写回PC<br /> 10：J指令被写回PC</td></tr></tbody></table></li><li><p>有限状态机(Finte State Machine)</p><ul><li>表示各个阶段控制信号需要设置的值</li><li>第三张需要刻在DNA里的图</li></ul></li><li><p>第一个阶段都一样</p><p><img src="/2021/05/03/pcs/fsm0.gif" alt="fsm0"></p></li></ul><h3 id="3-6-微指令"><a href="#3-6-微指令" class="headerlink" title="3.6 微指令"></a>3.6 微指令</h3><ul><li><p>把FSM所有的控制信号预先存储在存储器中，每次只要从存储器中读到控制寄存器中，由控制存储器作为控制信号，接到相应的组件中</p><p><img src="/2021/05/03/pcs/ctrlreg.gif" alt="ctrlreg"></p><ul><li><p>存储控制信号的存储器叫做控制存储器control memory</p></li><li><p>核心是空间换时间，用一个存储器存储各类信号来缩短工作时间</p></li><li><p>有寄存控制器的多周期CPU数据通道</p><p><img src="/2021/05/03/pcs/mulo.gif" alt="mulo"></p></li><li><p>微程序控制器：</p><ul><li>控制寄存器：每一位接相应的控制信号</li><li>控制存储器：存放所有的控制信号</li><li>地址转移逻辑：决定下一条微指令的地址</li></ul></li><li><p>微程序控制逻辑</p><p><img src="/2021/05/03/pcs/microCtrl.gif" alt="microCtrl"></p><p><img src="/2021/05/03/pcs/image-20200812144217138.png" alt="image-20200812144217138"></p></li></ul></li><li><p>微指令编程</p><ul><li><p>为了便于微程序的编写，把控制信号分成了若干组：存储器，寄存器组，ALU，PC等七个字段</p><p><img src="/2021/05/03/pcs/micro2.gif" alt="micro2"></p></li><li><p>为了实现微程序的选择转移，增加标号和下一步指令两个字段</p></li></ul></li></ul><h3 id="3-7-流水线-pipline-和冒险-hazard"><a href="#3-7-流水线-pipline-和冒险-hazard" class="headerlink" title="3.7 流水线(pipline)和冒险(hazard)"></a>3.7 流水线(pipline)和冒险(hazard)</h3><ul><li>这一部分虽然上课没讲过但是历年卷里出现了选择题</li></ul><h4 id="3-7-1-流水线的基本原理"><a href="#3-7-1-流水线的基本原理" class="headerlink" title="3.7.1 流水线的基本原理"></a>3.7.1 流水线的基本原理</h4><ul><li><p>CPU的流水线技术本质上利用了时间的并行性，将原本需要串行的处理一定程度上并行化了，使得CPU的效率提高，原理如下图</p><p><img src="/2021/05/03/pcs/piplin1.gif" alt="piplin1"></p><ul><li>转换成指令的运行的原理如下</li></ul><p><img src="/2021/05/03/pcs/piplin2.gif" alt="piplin2"></p></li></ul><h4 id="3-7-2-冒险-hazard"><a href="#3-7-2-冒险-hazard" class="headerlink" title="3.7.2 冒险 hazard"></a>3.7.2 冒险 hazard</h4><ul><li>在流水线中我们希望当前每个时钟周期都有一条指令进入流水线可以执行，但是某些情况下下一条指令无法按照预期的开始执行，这种情况就是冒险hazard</li><li>冒险有三种：<ul><li>结构冒险：如果一条指令需要的<strong>硬件</strong>还在为之前的指令工作，而无法为这条指令提供服务</li><li>数据冒险：如果一条指令需要的数据正在被之前的指令操作，那么这条指令就无法执行<ul><li>解决方法：Forward data if possible</li></ul></li><li>控制冒险：如果需要执行的指令是由之前的运行结果决定的，而运行的结果还没有产生，就是控制冒险<ul><li>解决方法：stall the pipeline，Predict branch outcome， Delayed branch</li></ul></li><li>总结：硬件——结构冒险，数据——数据冒险，控制指令——控制冒险</li></ul></li></ul><h2 id="4-存储器"><a href="#4-存储器" class="headerlink" title="4. 存储器"></a>4. 存储器</h2><h3 id="4-0-存储器的分类"><a href="#4-0-存储器的分类" class="headerlink" title="4.0 存储器的分类"></a>4.0 存储器的分类</h3><ul><li>按照存储介质来分<ul><li>半导体: SRAM,DRAM,ROM,FLASH</li><li>磁介质: 磁带和磁盘</li><li>光介质: CDROM</li></ul></li><li>按照读写功能<ul><li>只读内存：ROM/CDROM</li><li>读写：FLASH,磁盘和磁带,RAM(随机内存，就是平时说的内存)</li></ul></li><li>按存储的易失性<ul><li>易失：RAM</li><li>非易失：ROM, 磁介质, CDROM</li></ul></li><li>按照在计算机系统中的作用分类<ul><li>主存储器：计算机运行的主要存储器，存放运行的程序和数据</li><li>辅助存储器：如外存</li><li>缓冲存储器：作为一些I/O的数据缓存</li><li>控制存储器：存放控制程序和数据</li></ul></li><li>存储器的<strong>分级结构</strong> <ul><li>快村：多级Cache</li><li>主存：RAM,ROM</li><li>外存：磁盘，磁带，CDROM</li></ul></li></ul><p><img src="/2021/05/03/pcs/mem7.gif" alt="mem7"></p><h3 id="4-1-存储器基础-amp-存储器管理"><a href="#4-1-存储器基础-amp-存储器管理" class="headerlink" title="4.1 存储器基础&amp;存储器管理"></a>4.1 存储器基础&amp;存储器管理</h3><ul><li><p>这一部分感觉就是了解一下，考试看起来不太会来考</p></li><li><p>存储器的存储结构</p><ul><li><p>位bit–位线–位面–字word–字扩展(条)–存储器(多条)</p></li><li><p>存储器的基本原理，通过X,Y地址译码在电容中存储，由于没有电源供电，反向漏电会导致保存的信息丢失，所以必须不断刷新</p></li><li><p>动态存储单元</p><ul><li><p>由于没有电源供电，存在的反向泄漏电流会使得保存的信息丢失，必须不断刷新</p><p><img src="/2021/05/03/pcs/refresh.gif" alt="refresh"></p></li></ul></li><li><p>**动态存储器(DRAM)**：需要定时刷新</p><ul><li>刷新周期：连续两次对整个存储器全部刷新的间隔时间</li><li>刷新的方式分为：集中刷新，分散刷新，异步刷新</li></ul></li></ul></li></ul><h4 id="4-1-1-芯片和存储器"><a href="#4-1-1-芯片和存储器" class="headerlink" title="4.1.1 芯片和存储器"></a>4.1.1 芯片和存储器</h4><ul><li><p>存储器的地址</p><ul><li><p>二四译码器：用两位的0-1信号控制四个数据的选择，对应每一组输入只有一个输出和别的输出不同，则可以将该输出选中</p><p><img src="/2021/05/03/pcs/decode24-1597060116440.gif" alt="decode24"></p></li><li><p>地址译码：</p><ul><li>利用译码器将多个<strong>一位的存储单元</strong>组成一个整体</li><li>所有的存储单元接在同一条数据线上，但是由于译码器的控制，只有一个单元没选中可以进行数据的读写，这时输入数据即为地址</li></ul><p><img src="/2021/05/03/pcs/decode-1597060136379.gif" alt="decode"></p></li><li><p>二维地址译码：以二维存储单元阵列组成一个整体，可以减少驱动</p><p><img src="/2021/05/03/pcs/bitmtx.gif" alt="bitmtx"></p></li><li><p>位扩展: </p><ul><li><p>在二位地址译码的基础上，将若干个存储单元阵列以相同的地址译码器选中</p></li><li><p>每个二维的阵列对应不同的数据线，则相同地址译码在不同二维阵列上对应的单元，合并为存储器，从位—&gt;字</p><p><img src="/2021/05/03/pcs/bitword.gif" alt="bitword"></p></li><li><p>这图有点抽象，给我看晕了</p><p><img src="/2021/05/03/pcs/bitmtz.gif" alt="bitmtz"></p></li><li><p>存储芯片：</p><ul><li><p>地址线：决定可寻址的范围</p></li><li><p>数据线：决定数据的位数</p></li><li><p>控制线：包括电源、读写控制、片选</p><p><img src="/2021/05/03/pcs/mem4.gif" alt="mem4"></p></li></ul></li></ul></li><li><p>字扩展</p><ul><li><p>从一个最基本的一位存储单元通过双译码器得到一个一位的存储位阵列面，将同样地址线的若干相同的位平面，接不同的数据线，封装得到一个存储芯片</p></li><li><p>地址高位交叉：</p><ul><li><p>高位的地址作片选，同一芯片的地址<strong>连续</strong></p></li><li><p>但是读取连续的地址单元需要多次读写</p><p><img src="/2021/05/03/pcs/mem32k.gif" alt="mem32k"></p></li></ul></li><li><p>地址低位交叉，同一芯片的地址不连续，但读取连续地址单元只需要一次</p><p><img src="/2021/05/03/pcs/mem32k1.gif" alt="mem32k1"></p></li><li><p>DOS系统的芯片</p><ul><li><p>只有1MB，由RAM,BIOS,ROM 组成</p><p><img src="/2021/05/03/pcs/memory.gif" alt="memory"></p></li></ul></li></ul></li></ul></li><li><p>一个关于芯片计算的题目</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Assume an 8Kx8bits memory is composed of 2Kx4bit chips. The first address of the chip which contains the address 0B1Fh is (____).A：0700hB：0800hC：0600hD：0000h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这道题应该这样分析，首先可以计算出需要<strong>8块芯片</strong>，而8K*8bits的内存需要13位地址，其中<strong>最高的三位是片选地址</strong>，低的十位是片内的地址，而0B1F的最高三位是010，对应第二片，因此其起始地址就是0000100000000000，也就是0x0800</li><li>这种题目的一般方法：先算需要几片，再算地址一共有几位，取最高的几位来看就行</li><li>字扩展和位扩展的分别：<ul><li>位扩展是指需要多少位来扩展成一个字，字扩展是指扩展成字之后扩展出更大的存储空间</li><li>上面这题中2K*4bit的芯片需要2片一起才能作为一个字，所以位扩展是2，又需要4个这样的组成8K*8bits的，所以字扩展是4</li></ul></li></ul></li></ul><h4 id="4-1-2-对齐和不对齐"><a href="#4-1-2-对齐和不对齐" class="headerlink" title="4.1.2 对齐和不对齐"></a>4.1.2 对齐和不对齐</h4><ul><li>计算机一般以字节作为寻址单位，即每一个字节一个地址<ul><li><p>对**字(4字节)**或者半字(2字节，short)寻址的时候，最低位字节地址为整个字或者半字的地址</p><ul><li>比如一个字的4个字节地址分别是10，11，12，13，则这个字的地址是10</li></ul></li><li><p>大端:一个字或半个字的高位字节位于地址小的字节为大端,BigEndian</p></li><li><p>小端:一个字或半字的高位字节位于地址大的字节为小端,LittleEndian</p></li><li><p>即高位在前为大端，低位在前为小端,例如，一个字0x12345678的地址为10，即要将这个字写到地址10，11，12，13中</p><ul><li>大端 0x12,0x34,0x56,0x78</li><li>小端 0x78,0x56,0x34,0x12</li></ul></li><li><p>对齐：当系统要访问存储器的一个字，刚好在硬件存储中是一个字，就是对齐访问。</p><ul><li>不对齐就是访问的时候不是一个硬件字，需要硬件多次读写</li></ul></li><li><p>16位zjie对齐与不对齐</p><ul><li>为了避免读写一个数据，不得不多次访问存储器，可以将存储器按低位交叉方式编址，也就是译码时用低位地址线来做片选信号</li><li>这样一来，地址连续的存储器单元，将对应于不同的存储器芯片(bank)，当系统要求读写连续地址数据时，就可以从不铜存储器同时读出到寄存器，然后由总线传送</li></ul></li><li><p>内存条：从一个最基本的一位存储单元，通过双译码器得到一个一位的存储位阵列面，将接同样地址线的若干相同的位平面，接不同的数据线封装得到一个存储芯片</p></li></ul></li></ul><h3 id="4-2-Cache的基本原理"><a href="#4-2-Cache的基本原理" class="headerlink" title="4.2 Cache的基本原理"></a>4.2 Cache的基本原理</h3><ul><li><p>存储器的层次结构 memory hierarchy</p><ul><li><p>最顶层是register 直接和CPU进行通信</p></li><li><p>下面是各级的memory</p><img src="memhiera.gif" alt="memhiera" style="zoom:80%;" /></li></ul></li><li><p>程序运行的两个局部性原理</p><ul><li>时间局部性：如果每个数据或者指令被引用了，那么不久之后可能将被再次引用</li><li>空间局部性：如果一个数据被引用了，那么邻近的单元也可能被引用</li></ul></li><li><p><strong>Cache(高速缓存)的原理</strong></p><ul><li><p>计算机只能按照既定的地址来确定一个数据的意义，而地址在转换存储器的时候要进行对应的转换</p><ul><li><p>计算机中的运算都是通过逻辑运算实现的，逻辑运算速度快，因此应该多使用逻辑运算</p></li><li><p>在地址转换中我们都把2的幂作为数量单位，比如块的大小，Cache的容量，Cache分组和页</p><img src="cache.gif" alt="cache" style="zoom:80%;" /></li></ul></li><li><p>cache技术的基础：SRAM和DRAM</p></li><li><p>cache根据两个局部性的原理，将程序中<strong>正在运行的部分</strong>调入cache中，来提高指令和数据的访问速度，物理存储和cache都被分成相同大小的块(block)作为最小的管理单元，从物理地址到cache地址的转换,有这样几种方法：(考试必考点)</p><ul><li><p><strong>直接映射</strong>：物理地址按照一定的方式固定映射到cache的某一块上，但是物理地址比cache中的地址要大，所以会有<strong>很多物理地址映射到同一个cache块上</strong>，为了标记是哪个物理块，假设cache一共有M块，则：</p><p><img src="/2021/05/03/pcs/cache4word.gif" alt="cache4word"></p><ul><li>cache中有一位<strong>有效位</strong>，1表明数据有效，0表名数据无效</li><li>物理块号：j=物理地址/块的大小</li><li>cache块号(索引号)：i=j mod M</li><li>TAG = j/M 要来记录区分不同的内存块</li><li>当cache中恰好有$2^n$ 个block的时候，对应的cache<strong>索引</strong>就是内存地址的最低n位 </li><li>cache中地址的形式：<code>TAG+Index+ByteOffset</code><ul><li>其中TAG+index构成cache块的地址</li><li>TAG就是物理地址的最高几位，cache块序位中间几位，最低的几位是块内的地址</li></ul></li><li>主存地址映射到cache中时，最高的几位是TAG，中间的几位地址是索引，最后几位地址是块内存储的信息</li></ul><blockquote><p>例题1：对于能存储16KB数据的<strong>直接映射</strong>cache，块的大小为4word，地址为32位，需要多少大的存储空间？</p><ul><li>数据的总大小是$2^{14}$字节， 而一个块的大小是$2^4$ 字节，因此一共有$2^{10}$ 个块</li><li>一个块的数据量是128bits(一次4个字，一个字是32bits，需要128位)</li><li>Tag需要的bits数量=address - index -block size = 32 - 10 -4 = 18bits<ul><li>其中4word需要16bits，因此block size是4</li></ul></li><li>有效位是1bit，一共需要19bits</li><li>所以cache的总的size就是 $2^{10}\times(128+18+1)=147000$ bits = 18.4 KB</li></ul></blockquote><blockquote><p>例题2：一个64块的cache，块的大小是16bytes，则字节地址为1200应该直接映射到哪里？</p><ul><li>这种情况的答案(block address) modulo (number of cache blocks)</li><li>而block的地址计算方式是 字节地址/每个块的大小 = 75</li><li>所以答案就是11</li></ul></blockquote><blockquote><p>这里记录例1类型的题目的<strong>通用解法</strong>：</p><ul><li>条件是32位的字节地址，直接映射的cache，有$2^n$个block，一个block的大小是$2^m$ word，因此需要n位作为index，m位用于查找块中的字，2位是字节的偏移信息</li><li>则TAG的大小是32-(n+m+2)</li><li>cache需要的总位数是block数量*(block的大小+有效位的大小+TAG大小)也就是<ul><li>$2^{n}(2^{m+2}\times 8+(32-m-n-2) +1)$ </li></ul></li><li>关于block size的计算：假设block是$2^m$个word的大小<ul><li>常识：word是计算机中存取的基本单位</li><li>为了定位是哪一个word，需要m位</li><li>而在word里面，为了定位是哪个字节，需要2位，所以一共需要m+2位，block size就是m+2 bits</li></ul></li></ul></blockquote></li><li><p>全相联：</p><img src="cachefull.gif" alt="cachefull" style="zoom:150%;" /><ul><li>直接映射每个物理块有固定的cache块很容易判断命中与否(比较TAG)，但造成cache块的闲置</li><li>考虑<strong>不固定的映射方式</strong>，当需要替换的时候就<strong>遍历cache中所有的块</strong>，覆盖今后<strong>最不可能用到的块</strong>，这样可以提高cache的<strong>命中率</strong><ul><li>类似于ads中装箱问题的best fit算法</li><li>理论上存在的替换方法：LRU,FIFO,RAND</li><li>虽然提高了命中率，但是时间效率降低了</li><li>大量TAG判断是否命中会使得硬件的设计非常复杂，如果采用顺序判断，由于在cache中，Cache与主存存取速度的差别在1-2个数量级，确定是否命中的时间太长，cache就失去意义了</li></ul></li><li>块地址：按照块确定的地址，把原地址除以块的大小即可，块内部分为块内地址</li><li>主存地址/块大小=TAG 余数作为block-offset</li></ul></li><li><p>组相联：组相连把cache中的块分成若干组，每一块和主存直接进行映射，当主存快映射到组里之后，具体替换组里的哪一块，通过全相联的方法来选择</p><ul><li>缝合怪</li></ul><img src="cache4way.gif" alt="cache4way"  /><ul><li>组相联是全相联和直接映射的折中，直接映射是一种n个组的组相联，全相联是1个组的组相联</li><li>主存块号/cache组数的商是TAG，余数是index(组的位置)</li><li>组相联和直接映射的区别：<ul><li>组相联分成了若干组直接映射，因此在每一组里，Index的位数减少了，而TAG的位数增加了</li><li>同样大小的cache，如果分成了$2^n$路组相联，那么相比于直接映射，index减少了n位，TAG增加了n位，实际上原理就是同样多的m个block分成了若干组，在每个组里面进行直接映射，所以块数相比于直接映射减少了，所以index的位数也变少了</li></ul></li></ul></li><li><p>楼教授有言曰：<strong>直接映射是个人承包，全相联是共产主义，组相联是家庭联产承包责任制</strong> </p></li></ul></li><li><p>不同映射方式的比较</p><ul><li>全相联的cache<strong>效率最好</strong>，但是块数多了就<strong>难以判断是否命中</strong></li><li>直接映射的cache效率低，但是命中率高，组相联的各项水平处于二者之间</li><li>其实就是因为直接映射和全相联是两种组相联的特殊情况，直接映射是1路组相联，全相联是m路组相联</li></ul></li><li><p>多级cache</p><ul><li>L1:一级cache，在<strong>处理器的内部</strong>，以核心频率工作</li><li>L2:以<strong>处理器一半的频率工作</strong>，和CPU一起封装</li><li>L3:在<strong>主板</strong>上，以总线频率工作</li></ul></li></ul></li><li><p>cache的命中和失配</p><ul><li>cache的命中(hit)：指CPU要访问的数据存储在了cache中</li><li>cache的失配(miss)：指CPU要访问的数据不在cache中，此时需要将这个数据所在的整个block放入cache中<ul><li>主要的失配种类<ul><li>compulsory misses 强制失配，第一次启动时总是失配<ul><li>可以通过加大块的大小降低失配率</li></ul></li><li>capacity misses 容量失配，cache的容量比主存小引起失配<ul><li>可以通过<strong>多级cache</strong>降低失配率</li></ul></li><li>conflict misses 相联失配，由于映射关系影响命中率<ul><li>可以把组相联改成全映射</li></ul></li></ul></li><li><strong>块越大则命中率越高</strong>，但是当cache容量较小的时候，块增大可能使得块数太少而减小命中率<ul><li>在<strong>cache总容量不变</strong>的时候，块越大则命中率更高，块的大小取决于<strong>硬件</strong> </li></ul></li><li>不同的替换策略<ul><li>cache失配需要读入新的数据到cache时，可以在几个块之间选择进行数据替换，选择的依据就是程序访问的局部性原理，有这样一些替换策略</li><li>LRU 最近最少使用的优先替换</li><li>LFU 使用频率最低的优先替换</li><li>FIFO 先进先出</li><li>Random 随机替换</li></ul></li></ul></li><li>命中率和失配率(miss rate)：命中和失配的信息所占的比例 </li></ul></li><li><p>保持cache-主存数据<strong>一致性</strong>的方式</p><ul><li>写通 Write-Through，在改写存储器内容时，主存和cache要一起改写<ul><li>优点是简单，缺点是写的速度很慢</li></ul></li><li>写回 Write-back 写数据的时候只写在cache中，在块替换的时候再将数据写道主存中<ul><li>优点是对同一个块多次读写的时候，最后一次才写入主存，速度快</li><li>缺点是<strong>控制比较复杂</strong>，可以设置dirty位改进</li></ul></li><li>写缓冲 Write-buffer 改写的时候先写到缓冲区中，避免速度过慢</li></ul></li><li><p>cache效率的衡量</p><ul><li>存取时间的计算：通常使用AMAT(平均内存访问时间)来检测cache的效率<ul><li>AMAT = (time for a hit) + (miss rate x miss penalty)</li><li>计算方法1：<ul><li>Tc是cache访问的时间，Tm是主存的访问时间，H是命中率</li><li>T=Tc+(1-H)Tm</li></ul></li><li>计算方法2：指令+数据<ul><li>Tc是cache访问的时间，Tm是主存的访问时间，Hi是指令的命中率，Hd是data的命中率，P是程序中LW/SW指令的比例</li><li>T=Ti+Td*p=(Tc+(1-Hi)Tm)+(Tc+(1-Hd)Tm)*p</li></ul></li></ul></li><li>CPU时间的计算<ul><li>CPU时间 = (CPU执行的周期数 + Memory-stall 时钟周期) * 一个时钟周期的时间<ul><li>$CPU_{time}=I\times CPI\times Clock$ </li></ul></li><li>Memory-stall 时钟周期 = 指令的数量 * 失配率 * 失配的penalty = read-stall cycles + write-stall cycles<ul><li>而read-stall cycles = program中read的次数 * 失配率 * 失配的penalty</li><li>write-stall cycles = program中write的次数 * 失配率 * 失配的penalty + write buffer stalls</li><li>因此其实Memory-stall的时钟周期 = 存储访问的次数 * 失配率 * penalty</li><li>这一部分感觉公式比较多，直接抄在A4纸上好了</li></ul></li></ul></li></ul></li></ul><h3 id="4-3-虚拟存储"><a href="#4-3-虚拟存储" class="headerlink" title="4.3 虚拟存储"></a>4.3 虚拟存储</h3><ul><li><p>实际上就是把主存当作磁盘的cache来使用</p></li><li><p>虚拟存储器是根据存储器访问的<strong>局部性原理</strong>，将内存中正在使用的调入真正的内存，而暂时不用的存入磁盘</p><ul><li><p>内存也叫<strong>物理存储器</strong> </p></li><li><p>假设对于32位的CPU，寻址空间为4G，设lw指令为<code>LW srd dat(srs)</code> 则直接寻址的模拟为<code>srd=Memory[srs+Dat]</code> </p></li><li><p>设内存的大小为16K，如果地址范围限定在16K内则可以直接寻址，而当访问的地址超过物理存储器时，理论上会出错，访问应该改成<code>srd=getMemory(srs+Dat)</code>,即为虚拟存储器的模拟函数</p><ul><li>page fault：内存中没有找到数据，需要从disk中检索</li><li>会产生巨大的miss penalty，一般选用write-back策略维持一致性</li></ul></li></ul></li><li><p>为了尽可能提高命中率，虚拟存储采取的是<strong>全相联</strong>的策略</p></li><li><p>虚拟存储器的几种实现方式</p><ul><li><p>单页映射：整个物理存储器为一页，则需要有标志表明物理存储器的4k为4G寻址中的哪一部分</p><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200515113627571.png" alt="image-20200515113627571" style="zoom:80%;" /></li><li><p>反向页表：整个<strong>物理存储器为一页</strong> </p><ul><li>页数太少会使得命中率降低，为了提高命中率可以增加页数，相应减小每页的大小</li></ul></li><li><p>设每一页为1K，在物理存储器端建立页表，记录物理页和虚拟页的对应关系</p><ul><li>页表的数量为 物理存储器的大小/每页的大小=4K/1K=4</li></ul><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200515120013915.png" alt="image-20200515120013915" style="zoom:80%;" /></li><li><p>正向页表：页表也可以建立在虚拟地址段</p><ul><li>页表也可以建立在虚拟地址端，则页表的规模为为4G/1k</li></ul><img src="C:\Users\74096\AppData\Roaming\Typora\typora-user-images\image-20200515120120252.png" alt="image-20200515120120252" style="zoom:80%;" /></li><li><p>页表的优化</p><ul><li>页表实际上也存储在存储器中，设有<strong>页表地址寄存器PTR</strong>来保存页表的基地址</li><li>为了提高页表的访问速度，可以设置<strong>页表的cache：TLB</strong> </li><li>为了减小页表的的大小，可以：设置段界、使用分级页表 </li></ul></li></ul></li><li><p>虚拟存储的原理</p><ul><li><p>根据局部性原理，可以把程序需要用到的整个存储空间划分成一个个大小相同的页，把其中一些页放在主存中，而其他的页在需要的时候再建立或者放在磁盘中</p><ul><li>分页管理是因为<strong>硬件上容易实现</strong> </li><li>建立页表来管理页，如果该页在主存中，就记录下地址，如果不在，则在页表上标记不存在</li><li>当程序需要调用某个存储单元的内容时，先根据线性地址，算出所在的页，然后查询页表，如果在主存中就直接存取，如果不在就是一个page fault，要把主存中的某一页存入磁盘，再把要访问的页调入主存中使用(该过程使用LRU算法)</li></ul></li><li><p>几个重要的计算公式</p><ul><li><p>页表的大小 = 表的项数 * 每个表项需要的位数</p></li><li><p>表的项数 = 虚拟地址的空间 / 每页的大小</p></li><li><p>每个表项的位数 = log(物理地址空间 / 每页的大小) + 适当控制位数(很多时候是4位)，但是一般凑成整字(32bits)</p><p><img src="/2021/05/03/pcs/image-20200811164945930.png" alt="image-20200811164945930"></p></li></ul></li><li><p>虚拟地址的换算</p><p><img src="/2021/05/03/pcs/tlb.gif" alt="tlb"></p></li><li><p>TLB原理</p><p><img src="/2021/05/03/pcs/virche.gif" alt="virche"></p><ul><li>在4G的存储空间中，如果按照4K来分页，则可以分出1M页，每个页表项为4B，则一个页表的大小为4MB</li></ul></li><li><p>但是由于局部性原理，页表在某个时刻使用的也只有仅仅几页，因此可以把经常用的一些虚拟页号和对应的物理地址写到cache中，即为TLB</p><ul><li>则程序在调用某个存储单元的同时，根据线性地址算出所在的页，先查TLB，如果有就直接获取物理地址进行存取，如果没有则说明没有写在TLB中，需要去查页表，按照page fault的情况进行</li></ul></li></ul></li><li><p>虚拟存储的整体逻辑</p></li></ul><img src="viradd.gif" alt="viradd" style="zoom:80%;" /><h3 id="4-4-保护模式"><a href="#4-4-保护模式" class="headerlink" title="4.4 保护模式"></a>4.4 保护模式</h3><ul><li><p>cache和虚拟存储的比较</p><table><thead><tr><th></th><th>cache</th><th>虚拟存储</th></tr></thead><tbody><tr><td>实现</td><td>硬件</td><td>操作系统+少量硬件支持</td></tr><tr><td>写策略</td><td>write-back/write-through</td><td>write back</td></tr><tr><td>替换策略</td><td>LRU/FIFO/LFU/Random</td><td>LRU</td></tr><tr><td>交换单元</td><td>block</td><td>page</td></tr><tr><td>映射方式</td><td>直接映射，全相联，组相联</td><td>全相联</td></tr><tr><td>寻址方式</td><td>全硬件，相联存储器</td><td>Page-Table页表/TLB快表/分级页表</td></tr></tbody></table><ul><li>原理上讲二者差不多，差距主要在存储存取的速度上<ul><li>虚拟存储中存储器和磁盘的差距在6个数量级以上</li><li>cache和主存储器的存取速度相差1-2个数量级</li></ul></li></ul></li><li><p>实模式和保护模式下的地址转换：</p><ul><li>物理地址：机器中真正具有的存储空间，程序只有在物理存储器中才能被执行</li><li>页表项：32位，高20位是页基地址的最高20位，由于按照页来交换，因此页的基地址的低12位都是0，所以低的12位都被用作属性控制<ul><li>第11-9位是AVL，记录页的使用情况，比如LRU</li><li>第7位是D，表示是否该写过</li><li>第1位是R的时候表示读写，0的时候表示只读</li><li>第0位是P，第6位是A</li></ul></li><li>逻辑地址：<ul><li>在程序中使用的地址，在intel中由段和偏移组成，段和便宜可以转换成线性地址</li><li>没有虚拟存储的话，线性地址就是物理地址，转换方式是<ul><li>物理地(20位)  = 段(16位) * 16 + 偏移16位</li></ul></li><li>286以后段寄存器中的高13位就是表钟的索引，低的三位中TI一位描述所在的表，RPL两位描述特权级<ul><li>段在线性地址中的基地址在8字节的段描述里给出，根据段寄存器的值，在段描述表中找到对应的段描述</li><li>线性地址 32位 = 段基地址 32 位 + 偏移32位</li><li>每个8字节段描述的：分成4条，每条2字节<ul><li>第1条第1个字节和第2条的第2字节，第3条的2个字节加起来是32位段基地址</li><li>其他的都是一些控制位数，具体的太细了</li></ul></li></ul></li></ul></li><li>线性地址(虚拟地址)<ul><li>在MIPS结构中，基本为程序中的地址(lw, sw) ，在PC中就是存储器的物理地址</li><li>在286以后，线性地址为虚拟地址，也就是程序中可以寻址的存储空间，一个程序的运行，并不一定要所有的内容同时调入存储器才能执行，往往在一个时间内，只需要其中的一部分在存储器中，而其他的部分可以存在磁盘上，需要时再调用</li><li>虚拟存储技术使得程序员<strong>不必考虑实际存储器的大小</strong>，而<strong>由OS来负责计题的存储器的使用</strong> </li></ul></li></ul></li></ul><h2 id="5-I-O系统"><a href="#5-I-O系统" class="headerlink" title="5. I/O系统"></a>5. I/O系统</h2><h3 id="5-1-I-O系统的基本介绍"><a href="#5-1-I-O系统的基本介绍" class="headerlink" title="5.1 I/O系统的基本介绍"></a>5.1 I/O系统的基本介绍</h3><ul><li><p>I/O 设备的三个要素</p><ul><li>behavior 表现：输入/输出/存储</li><li>partner 参与者：是人还是机器</li><li>data rate 数据速度：数据能在I/O设备和主存/处理器之间传输的<strong>最大</strong>速度</li></ul></li><li><p>I/O设备的评价标准</p><ul><li>带宽 banwidth——最重要的评价指标</li><li>带宽可以从以下两个方面来评价<ul><li>一次可以move多少数据</li><li>每个单位时间可以作多少次I/O操作</li></ul></li></ul></li><li><p>常见的I/O设备</p><ul><li>键盘，鼠标，音响，Scanner，打印机，显示屏，磁盘，磁带</li></ul></li></ul><h3 id="5-2-磁盘"><a href="#5-2-磁盘" class="headerlink" title="5.2 磁盘"></a>5.2 磁盘</h3><ul><li><p>这一部分DBS里也有涉及到，不过DBS好像不太考这一部分的内容</p></li><li><p>磁盘的两种类型</p><ul><li>floppy disk 软盘</li><li>hard disk 硬盘：容量更大，访问效率更高，有多个盘，由如下几个部分构成<ul><li>platter 盘：每个盘的两个表面都是可以记录的</li><li>tracks 磁道：每个磁盘的表面被划分成若干磁道</li><li>sectors 扇区：每个磁道被划分为若干扇区<ul><li>扇区是磁盘读写的<strong>基本单位</strong> </li></ul></li></ul></li><li>磁盘的基本参数<ul><li>引导扇区：<ul><li>扇区1：BOOT区</li><li>扇区2-10：FAT-1，11-19：FAT-2</li><li>扇区20-31：目录区</li><li>扇区32及以后是数据区</li></ul></li><li>FAT表：每个磁盘有两个相同的FAT表，硬盘中一般为16位，现在往往是32位<ul><li>0000 未用簇</li><li>0001-FFEF 下一个簇号</li><li>FFF0-FFF6 保留位</li><li>FFF7 坏簇</li><li>FFF8-FFFF 最后簇，表示文件结尾</li></ul></li></ul></li></ul></li><li><p>磁盘的访问</p><ul><li>访问的过程<ul><li>seek：把读写头放置到正确的磁道上面(寻道时间)<ul><li>相关的数据有最小访问时间，最大访问时间，平均访问时间</li></ul></li><li>rotation latency：等待找到目标扇区的时间<ul><li>平均延迟是disk周期的一半<ul><li>计算公式：$latency = \frac{0.5}{RPM}$ </li></ul></li><li>RPM：每分钟的转数(rounds per minutes)，计算的时候需要将RPM转换成round per 毫秒</li></ul></li><li>transfer：传输一个扇区的时间(1KB/sector) 和转速相关</li><li>disk controller：控制磁盘和内存之间的传输</li></ul></li><li>访问时间的计算：<ul><li>seek+latency+transfer+controller 一般是毫秒的级别</li></ul></li><li>几个重要的评估标准<ul><li>MTTF 平均failure时间</li><li>MTTR 平均repair时间</li><li>MTBF = MTTF + MTTR</li><li>可用性 = MTTF / MTBF</li></ul></li><li>提高MTTF的方法<ul><li>避免错误的访问</li><li>容忍错误：使用冗余来允许服务在出现故障的情况下遵守服务规范</li><li>错误预报</li></ul></li></ul></li><li><p>RAID：<strong>廉价磁盘的冗余序列</strong> </p><ul><li>用一系列便宜的磁盘代替一个大磁盘，来提高磁盘的效率</li></ul></li></ul><h3 id="5-3-总线-bus"><a href="#5-3-总线-bus" class="headerlink" title="5.3 总线 bus"></a>5.3 总线 bus</h3><h4 id="5-3-1-基本概念"><a href="#5-3-1-基本概念" class="headerlink" title="5.3.1 基本概念"></a>5.3.1 基本概念</h4><ul><li><p>总线是构成计算机系统的互联机构，是多个系统功能部件之间进行数据传输的公共通路，分为</p><ul><li>控制线：用于传递各类<strong>信号</strong>和存储数据线中信息的信息</li><li>数据线：传递信息(数据，地址，复杂的指令)<ul><li>细分的话可以分为地址线和数据线</li></ul></li></ul></li><li><p>总线和内存，I/O设备的数据交换方式有两种</p><ul><li>内存映射I/O方式：内存与I/O系统采用共用的控制、地址和数据线<ul><li>内存和接口部件共享一个地址空间，各自拥有不同的地址端，读写的指令和内存读写的指令也是一样的</li></ul></li><li>独立I/O编址：共享地址线和数据线，但是用不同的控制线</li></ul></li><li><p>总线的工作原理：</p><ul><li><p>input操作：</p><ul><li><p>控制线传输一个写的请求到内存，数据线传递地址</p><p><img src="/2021/05/03/pcs/image-20200816200659984.png" alt="image-20200816200659984"></p></li><li><p>内存主备好之后会给设备发送信号，然后在内存中写入数据，设备不需要等待数据的存储完成</p><p><img src="/2021/05/03/pcs/image-20200816200654542.png" alt="image-20200816200654542"></p></li></ul></li><li><p>output操作：</p><ul><li><p>处理器通过控制线发送read请求，数据线传递地址</p><p><img src="/2021/05/03/pcs/image-20200816200314148.png" alt="image-20200816200314148"></p></li><li><p>内存进行数据的访问</p><p><img src="/2021/05/03/pcs/image-20200816200320389.png" alt="image-20200816200320389"></p></li><li><p>通过控制线将数据传输出去，目标设备会存储总线上传递过来的数据</p><p><img src="/2021/05/03/pcs/image-20200816200325255.png" alt="image-20200816200325255"></p></li></ul></li></ul></li><li><p>总线的分类：</p><ul><li>一个单处理器的总线分为如下三类<ul><li>内部总线：CPU内部连接各寄存器和运算部件之间的总线</li><li>系统总线：CPU同计算机系统的其他<strong>高速功能部件</strong>(如存储器)等互相连接的总线</li><li>I/O总线：中低速I/O设备之间互相连接的总线，比如SCSI</li></ul></li><li>backplane总线(高速，标准化的总线，我也不知道属于哪一类)，比如PCI</li><li>processor-memory总线(短而高速，自定义设计的)</li></ul></li><li><p>总线的特性：</p><ul><li>物理特性：包括总线的根数，插头插座的形状，引脚线的排列方式</li><li>功能特性：描述总线中每一根线的功能</li><li>电气特性：定义每一根线上信号的传递方向和有效电平范围，输入CPU的信号是IN，CPU发出的是OUT</li><li>时间特性：定义了每根线在什么时候有效，规定了总线上个信号的有效的时序关系</li></ul></li><li><p>总线的标准化：下面是总线的一系列标准</p><ul><li>SCSI(small computer system interface,，小型计算机系统接口)</li><li>PCI(peripheral component interconnect，外部组件互联)</li><li>IPI(intelligent peripheral interface，智能外部接口)</li><li>IBMPC-AT IBMPC-XT</li><li>ISA EISA</li></ul></li><li><p>同步传输和异步传输</p><ul><li>同步传输：使用时钟和同步协议，每个设备必须在同一个速度和时钟下操作</li><li>异步传输：使用握手协议(handshaking)或者选通(stubing)的策略<ul><li>此时CPU，接口和I/O设备有不同的时钟周期</li></ul></li></ul></li></ul><h4 id="5-3-2-总线的仲裁-Arbitration"><a href="#5-3-2-总线的仲裁-Arbitration" class="headerlink" title="5.3.2 总线的仲裁 Arbitration"></a>5.3.2 总线的仲裁 <strong>Arbitration</strong></h4><ul><li><p>当多个主设备同时争夺总线的控制权的时候，由总线仲裁部件授权给其中一个主设备</p><ul><li>bus master主设备：处理器总会是一个bus master(<del>bus master的任务罢了</del>)</li></ul></li><li><p>CAN采用优先级方式，TCP/IP采用CSMA/CD级制，而RS-485采用<strong>主机轮询</strong>的机制</p><ul><li>链式查询：所有的设备共用一条总线请求与相应，当总线控制器接到总线的请求之后，总线授权信号串行地在I/O接口之间传递，将控制权交给第一个有总线请求的I/O接口<ul><li>离中央仲裁器近的设备优先级高</li><li>容易扩充设备</li><li>对电路故障非常敏感</li><li>优先级是固定的，如果优先级高的设备请求非常频繁，优先级低的可能一直不能使用总线</li></ul></li><li>计数器定时查询：总线控制器按顺序查询各个接口，如果有请求就响应请求并记录设备的地址<ul><li>每次查询可以从固定的地址开始(优先级固定)，也可以从上一次相应的设备开始(循环优先级)，每个设备使用总线有相同的优先级</li><li>为传送设备地址需要增加的总线的数量是<strong>log2 设备数</strong> </li></ul></li><li>独立请求：每一个共享总线的设备均有一对请求线和授权线，当需要使用的时候就发出请求信息，控制器独立决定响应哪个设备<ul><li>响应时间快，不用逐个查询</li><li>优先级控制比较灵活</li><li>可以屏蔽某些设备的请求</li></ul></li></ul></li><li><p>分布仲裁方式：</p><ul><li>不需要中央仲裁器，每个潜在的主方功能模块<strong>都有自己的仲裁号和仲裁器</strong>，当它们有总线请求的时候会把仲裁号发到仲裁总线上，每个仲裁器将得到的信号和自己的比较，如果仲裁总线上的号大，则不会响应这个仲裁器的请求，并撤销仲裁号，最后获胜的保留在总线上</li></ul></li></ul><h3 id="5-4-数据传输和控制"><a href="#5-4-数据传输和控制" class="headerlink" title="5.4 数据传输和控制"></a>5.4 数据传输和控制</h3><ul><li>程序查询的方式<ul><li>先检查外设的状态，允许时再进行数据的I/O传送</li><li>缺点是外设一般比较慢，CPU必须不断检查外设状态，效率很低</li></ul></li><li>I/O设备的特性<ul><li>通过处理器，被多个程序共用</li><li>使用中断来交流I/O操作的信息</li><li>需要三种不同类型的交流<ul><li>OS必须能够给I/O设备发送命令<ul><li>通过内存映射的I/O：发送地址给I/O设备</li><li>特殊的I/O指令</li><li>命令端口/数据端口：静态寄存器，指令</li></ul></li><li>当I/O设备完成一个操作或者抛出异常的时候，设备必须通知OS</li><li>数据必须在内存和I/O设备之间传输</li></ul></li></ul></li></ul><h4 id="5-4-0-数据传输的控制"><a href="#5-4-0-数据传输的控制" class="headerlink" title="5.4.0 数据传输的控制"></a>5.4.0 数据传输的控制</h4><ul><li><p>I/O系统的数据传输的控制：</p><ul><li><p>三种模式</p><ul><li>polling 轮询：处理器定期检查设备的<strong>状态位</strong>，来确定是否到了下一次I/O操作的时间</li><li>interrupt 中断：当一个设备想要告知处理器需要完成一些操作时，让处理器中断<ul><li>不会检查接口设备的状态位</li></ul></li><li>DMA：设备<strong>直接从内存</strong>中进行数据传输，绕过处理器<pre><code>![image-20200816234817962](image-20200816234817962.png)</code></pre></li></ul></li><li><p>三种模式的比较：</p><ul><li>轮询的缺点：<strong>耗时</strong>，当CPU周期性地轮询I/O设备的时候，I/O设备可能没有请求或者还没有准备好</li><li>如果I/O操作是中断驱动的，OS可以在数据被读写的时候进行别的task<ul><li>中断驱动的优点就是可以进行<strong>并行</strong> </li></ul></li><li>DMA不需要处理器的控制，所以比较省时间</li><li>轮询，中断和DMA中，对<strong>硬件支持要求最低的是轮询</strong> </li></ul></li></ul></li></ul><h4 id="5-4-1-中断"><a href="#5-4-1-中断" class="headerlink" title="5.4.1 中断"></a>5.4.1 中断</h4><ul><li>中断 Interrupt<ul><li>中断的类型：<ul><li>内部中断<ul><li>软件中断：指令中断，是按照中断的级制进行的此程序调用</li><li>硬件异常：内部出错产生的异常中断</li></ul></li><li>外部中断：I/O设备请求产生的中断</li></ul></li><li>屏蔽中断和非屏蔽中断 NMI：外设中断可以屏蔽</li><li>中断服务程序：中断发生的时候，系统中处理中断事件的程序</li><li>中断向量：中断服务程序在内存中的入口地址，实模式下分段：偏移，共四个字节，保护模式下是8字节终端描述</li><li>中断向量表：PC系统共有256个中断，中断向量表就是所有中断向量的集合<ul><li>实模式下一共有4*256=1KB</li><li>保护模式下是中断描述表的形式</li></ul></li></ul></li><li>中断的优先级<ul><li>多个I/O设备发起中断请求的时候，需要确定设备的优先级，优先级高的设备的中断请求先响应</li><li>一般来说数据传输率高的设备(比如磁盘)的优先级比较高，数据传输率比较低的设备的优先级比较低(比如键盘)</li><li>判断优先级的方法：<ul><li>硬件方法：中断优先级判别电路<ul><li>菊花链(daisy chain)方法：将所有的终端设备串行连接构成优先级电路</li></ul></li><li>软件方法：采用轮询的方式来确定优先级，中断源的</li></ul></li></ul></li></ul><h4 id="5-4-2-DMA"><a href="#5-4-2-DMA" class="headerlink" title="5.4.2 DMA"></a>5.4.2 DMA</h4><ul><li><p>DMA方式</p><ul><li><p>DMA：直接存储器存取 Direct Memory Access，不需要经过处理器，由DMA控制器控制，在外设和主存储器之间进行数据传送，CPU通过DMA控制器对传输方式进行设置，不直接控制传输的过程</p></li><li><p>DMA传送过程：</p><ul><li>预处理：由CPU对DMA控制器进行设置，确定数据传送的方式，存储器地址和传送的数据量</li></ul></li><li><p>DMA：由DMA控制器接管总线和存储器的读写控制，进行外设和存储器之间的直接数据传送</p></li><li><p>DMA结束：DMA控制通过中断通知CPU DMA结束了，通过执行中断服务程序对DMA结果进行检查，确定是否继续DMA</p></li></ul></li><li><p>DMA时期的CPU工作方式：</p><ul><li><p>停止总线和存储器的访问：DMA控制器接管了总线和存储器的控制，CPU停止对于总线和存储器的访问</p><ul><li>控制比较简单，但是CPU效率很低</li></ul></li><li><p>周期挪用：DMA大部分时间用在外部设备的读写中，总线和存储器有相当的时间处于等待状态，CPU利用这段时间访问总线和存储器</p><ul><li>效率提高，控制复杂</li></ul></li><li><p>轮流访问：两者的折中，将DMA过程划分成较小的周期，由CPU和DMA控制器交替进行总线和存储器的访问</p><p>  <img src="/2021/05/03/pcs/datran5.gif" alt="datran5"></p></li></ul></li></ul><h2 id="楼教授有言曰：计算机总是有一种方法，是最简单和最理想方式的妥协"><a href="#楼教授有言曰：计算机总是有一种方法，是最简单和最理想方式的妥协" class="headerlink" title="楼教授有言曰：计算机总是有一种方法，是最简单和最理想方式的妥协"></a>楼教授有言曰：<strong>计算机总是有一种方法，是最简单和最理想方式的妥协</strong></h2>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级数据结构与算法分析</title>
      <link href="2021/05/03/ads/"/>
      <url>2021/05/03/ads/</url>
      
        <content type="html"><![CDATA[<h1 id="ADS-Review"><a href="#ADS-Review" class="headerlink" title="ADS-Review"></a>ADS-Review</h1><h2 id="1-Advanced-Data-Structure"><a href="#1-Advanced-Data-Structure" class="headerlink" title="1. Advanced Data Structure"></a>1. Advanced Data Structure</h2><h3 id="1-1-Tree"><a href="#1-1-Tree" class="headerlink" title="1.1 Tree"></a>1.1 Tree</h3><h4 id="1-1-1-AVL-Tree"><a href="#1-1-1-AVL-Tree" class="headerlink" title="1.1.1 AVL Tree"></a>1.1.1 AVL Tree</h4><ul><li><p>根本目标：用二叉搜索树来<strong>提高搜索的速度</strong></p></li><li><p>AVL树的定义</p><ul><li>空树是height balanced的</li><li>对于任何一个节点，左右子树的高度差的绝对值不超过1<ul><li>高度的定义：<strong>空节点的高是1，没有儿子的节点(学名是叶节点)高为0</strong>，否则就是儿子中高的最大值+1</li></ul></li></ul></li><li><p><strong>树的旋转rotation</strong></p><ul><li><p>当高度差的约束被打破的时候就需要进行旋转，有LL,RR,LR,RL四种旋转方式</p></li><li><p>LL型旋转</p></li><li><p>RR型旋转，基本就是LL型旋转的镜像对称</p></li><li></li><li><p>RL型旋转</p></li></ul></li><li><p>对于高度为k(空树的高度为0 )的AVL树，它的<strong>最小节点个数</strong>为(最大的节点个数肯定是K层全满的时候)</p></li></ul><p>$$<br>n_{k}=n_{k-1}+n_{k-2}+1\<br>n_k=F_{k+2}-1\<br>so\quad k=\ln(n)<br>$$</p><h4 id="1-1-2-Splay-Tree"><a href="#1-1-2-Splay-Tree" class="headerlink" title="1.1.2 Splay Tree"></a>1.1.2 Splay Tree</h4><ul><li><p>目标：从<strong>空树开始</strong>，任何M次连续的操作一共最多消耗$O(M\log N)$的时间</p><ul><li>必须要从一棵空树开始</li><li>具体做法：在树中，每次有节点被访问到，就将其<strong>旋转到根节点</strong></li></ul></li><li><p>旋转的方法</p><ul><li><p>如果父节点是根节点，直接把父子旋转即可</p></li><li><p>如果父节点不是根节点</p><ul><li><p>zig-zag</p></li><li><p>zig-zig</p></li></ul></li><li><p>每次要将被访问的节点按照上述规则<strong>旋转到根节点</strong>上为止</p></li></ul></li><li><p>删除的操作步骤</p><ul><li>找到要删除的节点X，将其旋转到根节点(这也是access)</li><li>把根节点删除，产生左右两棵子树</li><li>在左子树上找到最大的节点旋转到根节点，并且把右子树接到左子树的右边</li></ul></li></ul><h4 id="1-1-3-Red-Black-Tree"><a href="#1-1-3-Red-Black-Tree" class="headerlink" title="1.1.3 Red-Black Tree"></a>1.1.3 Red-Black Tree</h4><ul><li><p>红黑树的定义</p><ul><li>红黑树是一种二叉搜索树，并且节点的颜色为红色或者黑色</li><li>红黑树的<strong>根节点是黑色</strong> </li><li>叶节点都是黑色的(叶节点是NULL的时候把NULL也视为黑色的节点)</li><li>红色节点的两个儿子一定都是黑色节点</li><li>对于每一个节点，所有的从该节点出发到达后代的叶节点的简单路径包含相同数量的黑色节点</li></ul></li><li><p>black height of node x: <code>bh(x)</code></p><ul><li>节点的black height表示从x<strong>到叶节点的路径中黑色节点</strong>的个数 </li><li>性质：<ul><li>有N个节点的红黑树的高度最多为$2\ln (N+1)$ </li><li>$bh(Tree)&gt;=\frac{h(Tree)}{2}$ </li></ul></li></ul></li><li><p>红黑树的操作</p><ul><li><p>插入insert</p><ul><li><p><strong>先当作普通的BST插入</strong>并且将该<strong>节点作为红色节点</strong>，但是这么做会破坏红黑树的性质，需要进行旋转</p></li><li><p>分情况判断怎么旋转</p><ul><li><p>case1：插入的节点在父节点的右侧且叔叔节点是红色的：父节点和叔节点变成红色</p></li><li><p>case2：插入的节点在左侧而且叔叔是红色</p></li><li><p>case3：叔节点是黑色的，不论左右儿子都要进行<strong>旋转成如下图所示之后换成一黑带两红</strong></p></li></ul></li><li><p>插入的时间复杂度是$O(\log N)$ 插入之后需要从底下不断向上调整多次，直到满足红黑树的所有性质</p></li></ul></li><li><p>删除 delete</p><ul><li>删除的节点是<strong>叶节点</strong>：让其父节点指向NULL，保持不变</li><li>删除的节点度数为1：用孩子代替原本的节点</li><li>删除的节点度数为2：用最大的左儿子或者最小的右儿子代替节点</li><li>当删除的节点是红色节点时性质不会被破坏，删除的节点是黑色的时候可能会破坏一些性质</li></ul></li><li><p>Number of rotations</p><ul><li>红黑树在Insert中旋转次数不超过2，删除的过程中旋转次数不超过3</li></ul></li></ul></li></ul><h4 id="1-1-4-B-Tree"><a href="#1-1-4-B-Tree" class="headerlink" title="1.1.4 B+ Tree"></a>1.1.4 B+ Tree</h4><ul><li>M阶的B+树的定义<ul><li>根节点是叶节点或者根节点有<code>2~M</code>个儿子 </li><li>根以外的<strong>非叶节点</strong>有<code>[M/2]~M</code>个儿子，每个<strong>叶节点</strong>内含<code>[M/2]~M</code>个元素<ul><li>B+树的儿子指的不是节点里的几个数据，而是节点向下指出来的新节点</li><li>每个节点的key数是子节点数-1，画图的时候key分布在两个指向儿子的箭头之间</li><li>key值的确定方法：等于key右边第一个指针对应的子节点的最左边的值</li></ul></li><li>所有的叶节点的深度相同</li><li>B+ tree of order 4 也被称为2-3-4树， order3的被称为2-3 tree</li></ul></li><li>B+树的插入算法<ul><li>对于order M， 有N个元素的B+树而言 $T=O(\frac{M}{\log M}\log N)$</li><li> B+树的深度 $Depth(M,N)=O([\log_{[M/2]}N])$ , 找到插入位置的事件复杂度是log N</li><li>对于order3的B+树而言，非叶节点的索引个数在有三个儿子时需要两个，否则只需要一个索引</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">Btree  <span class="token function">Insert</span> <span class="token punctuation">(</span> ElementType X<span class="token punctuation">,</span>  Btree T <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Search from root to leaf <span class="token keyword">for</span> X and find the proper leaf node<span class="token punctuation">;</span>Insert X<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span> this node has M<span class="token operator">+</span><span class="token number">1</span> keys <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    split it into <span class="token number">2</span> nodes with <span class="token punctuation">[</span><span class="token punctuation">(</span>M<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> and <span class="token punctuation">[</span><span class="token punctuation">(</span>M<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> keys<span class="token punctuation">,</span> respectively<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>this node is the root<span class="token punctuation">)</span>        create a new root with two children<span class="token punctuation">;</span>    check its parent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//算法的描述：找到合适的位置先插入，如果叶节点的keys数量超过了M，则分裂成两个，然后向上继续合并和拆分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Deletion</strong> <strong>is similar to insertion except that the root is removed when it loses two children</strong> 删除和插入的做法相似，不过当一个根节点失去两个儿子时就要删除</li></ul><h3 id="1-2-Invert-File-Index"><a href="#1-2-Invert-File-Index" class="headerlink" title="1.2 Invert File Index"></a>1.2 Invert File Index</h3><ul><li><p>Term-Document Incidence Matrix 文档关联矩阵</p><ul><li>a matrix of the appearance of each word in each doc</li><li>如果单词在某篇文章中出现，则对应的矩阵上位置的值为1，否则为0，若干篇文章的出现情况可以得到若干个二进制字符串<ul><li>只关注一个单词<strong>出现与否</strong>，并不关注出现的<strong>频率</strong></li></ul></li><li>用<strong>逻辑运算</strong>可以考察单词在doc中的出现情况</li></ul></li><li><p>Inverted File Index 倒排文件索引</p><ul><li>Index is a mechanism for locating a given  term in a text 一种在文章中定位给定单词的方法</li><li>Inverted File contains a list of pointers to all occurrences of that term in the text<ul><li>索引的方式  单词—&lt;次数；依次列出每一篇出现的doc的编号&gt;</li><li>更nb的索引方式  单词—-&lt;次数；(出现的doc的编号；该doc中每一个出现的位置)&gt;</li></ul></li></ul></li><li><p>Index generator 索引生成器</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>read a document D<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span>read a term T in D<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Find</span><span class="token punctuation">(</span>Dictionary<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token operator">==</span>false<span class="token punctuation">)</span><span class="token function">Insert</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>Get T's position list<span class="token punctuation">;</span>Insert a node to T's posting list<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>write the inverted index to disk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>While accessing a term by hashing in an inverted file index, range searches are expensive.</li><li>读取时的简单处理 <ul><li>word stemming 碰到一个单词的多种形式和时态的时候只保留一种root形式</li><li>stop words 面对一些出现频率高但是useless的单词时不统计，比如a，the等</li></ul></li><li>当存储空间不足时<ul><li>using the memory block and merge them in the end 采用多块内存存储</li><li>distributed indexing 分布式索引<ul><li>term-partitioned index 按词语来划分</li><li>document-partitioned index 按照文档的编号来划分</li></ul></li><li>dynamic index 动态索引<ul><li>不常索引的doc将会被删除</li><li>索引由main index+auxiliary index构成</li></ul></li></ul></li><li>Thresholding 阈值<ul><li><strong>document：只检索前面x个按权重排序的文档</strong><ul><li>对于布尔查询无效</li><li>会遗漏一些重要的文档，因为有截断</li></ul></li><li><strong>query：把带查询的terms按照出现的频率升序排序</strong></li><li>要区分两种不同的阈值各自的作用</li></ul></li><li>搜索引擎的评价标准<ul><li>how fast does it index 索引有多快</li><li>how fast does it search 搜索有多快</li><li>Expressiveness of query language 查询语言的表现</li></ul></li><li>Relevance measurement<ul><li>准确率precision $P_R=R_R/(R_R+I_R)$</li><li>召回率 recall $R_R=(R_R+R_N)$</li></ul></li></ul><h3 id="1-3-Heap"><a href="#1-3-Heap" class="headerlink" title="1.3 Heap"></a>1.3 Heap</h3><h4 id="1-3-1-Leftist-Heap-左倾堆"><a href="#1-3-1-Leftist-Heap-左倾堆" class="headerlink" title="1.3.1 Leftist Heap 左倾堆"></a>1.3.1 Leftist Heap 左倾堆</h4><ul><li><p>NPL(x) – Null path length</p><ul><li>对于任意一个节点x，通往<strong>一个没有两个子节点的节点的最短路径长</strong>称为NPL(x)，空节点的NPL值为-1</li><li>计算方法：NPL(x) = min { NPL(c)  c is a child of X} +1</li></ul></li><li><p>左倾堆的性质</p><ul><li>对于每个节点，<strong>左儿子的NPL值不小于右儿子的NPL值</strong>，所以整体看起来向左倾斜<ul><li>npl值看的是从自己出发的，但是左倾堆的性质是儿子的npl值满足条件</li></ul></li><li>左倾堆实际上是一种不平衡的二叉树，它的数据结构定义如下</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token punctuation">&#123;</span>    ElementType Element<span class="token punctuation">;</span>PriorityQueue Left<span class="token punctuation">;</span>PriorityQueue Right<span class="token punctuation">;</span><span class="token keyword">int</span>Npl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对于一个右路径有r个节点的左倾堆，至少一共有$2^r-1$个节点</p></li><li><p>左倾堆的合并</p><ul><li><p>递归方法：</p><ul><li>每次合并需要比较两个左倾堆的根节点的大小，将大的合并在小的上面</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">PriorityQueue <span class="token function">Merge</span><span class="token punctuation">(</span>PriorityQueue H1<span class="token punctuation">,</span>PriorityQueue H2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>H1<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> H2<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>H2<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> H1<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>H1<span class="token operator">-></span>Element<span class="token operator">&lt;</span>H2<span class="token operator">-></span>Element<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">Merge1</span><span class="token punctuation">(</span>H1<span class="token punctuation">,</span>H2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">Merge1</span><span class="token punctuation">(</span>H2<span class="token punctuation">,</span>H1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> PriorityQueue <span class="token function">Merge1</span><span class="token punctuation">(</span> PriorityQueue H1<span class="token punctuation">,</span> PriorityQueue H2 <span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> H1<span class="token operator">-></span>Left <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token comment">/* single node */</span>H1<span class="token operator">-></span>Left <span class="token operator">=</span> H2<span class="token punctuation">;</span><span class="token comment">/* H1->Right is already NULL     and H1->Npl is already 0 */</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>H1<span class="token operator">-></span>Right <span class="token operator">=</span> <span class="token function">Merge</span><span class="token punctuation">(</span> H1<span class="token operator">-></span>Right<span class="token punctuation">,</span> H2 <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* Step 1 &amp; 2 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span> H1<span class="token operator">-></span>Left<span class="token operator">-></span>Npl <span class="token operator">&lt;</span> H1<span class="token operator">-></span>Right<span class="token operator">-></span>Npl <span class="token punctuation">)</span><span class="token function">SwapChildren</span><span class="token punctuation">(</span> H1 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Step 3 */</span>H1<span class="token operator">-></span>Npl <span class="token operator">=</span> H1<span class="token operator">-></span>Right<span class="token operator">-></span>Npl <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">/* end else */</span><span class="token keyword">return</span> H1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//The time complexity is O(log N)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>迭代方法</p><ul><li>将两个堆拆分成若干条right paths，将它们从小到大合并成一个</li><li>自上而下互换左右子节点，当子树不满足左倾堆性质的时候</li></ul></li><li><p><strong>Insertion is merely a special case of merging.</strong></p><ul><li>插入当作特殊的merge进行处理即可</li></ul></li></ul></li><li><p>左倾堆的Delete Min</p><ul><li>删除根节点</li><li>将左右子树作为两个左倾堆进行合并</li></ul></li></ul><h4 id="1-3-2-Skew-Heap-斜堆"><a href="#1-3-2-Skew-Heap-斜堆" class="headerlink" title="1.3.2 Skew Heap 斜堆"></a>1.3.2 Skew Heap 斜堆</h4><ul><li>斜堆是左倾堆的一种简单形式，它使得对于斜堆的连续M次操作最多消耗$O(M\log N)$的时间</li><li>相比左倾堆的特点<ul><li><strong>Skew heaps have the advantage that</strong> <strong>no extra space</strong> <strong>is required to maintain path lengths and</strong> <strong>no tests</strong> <strong>are required to determine when to swap children.</strong> 不需要额外存储NPL值，交换左右子节点的时候不需要test</li><li>It is an open problem to determine precisely the expected right path length of both leftist and skew heaps.</li></ul></li><li>相比于普通的二项堆，Skew heaps are advantageous because of their ability to merge more quickly than balanced binary heaps. The worst case time complexities for Merge, Insert, and DeleteMin are all <em>O</em>(<em>N</em>), while the amorited complexities for Merge, Insert, and DeleteMin are all <em>O</em>(<em>logN</em>).</li><li>斜堆的Merge<ul><li>Always swap the left and right children except that the largest of all the nodes on the right paths does not have its children swapped. </li><li>人类语言描述merge的过程<ul><li>NULL和NULL合并无事发生</li><li>NULL和非空斜堆合并的结果是非空斜堆</li><li>如果两个非空的斜堆合并，取根节点值比较小的作为新的根节点，让另一个堆和其右儿子进行合并后作为新的右儿子，合并完成之后交换左右子节点(<strong>不是镜像对称</strong>，只要交换左右儿子)</li></ul></li><li><strong>把insert当成是一个点和一个斜堆的merge</strong> </li></ul></li><li>斜堆的摊还分析<ul><li>将操作后的根节点作为$D_i$</li><li>势能函数的选取：number of heavy nodes<ul><li>heavy nodes：if the number of descendants of p’s right subtree is at least half of the number of descendants of p, and light otherwise.</li><li>The only nodes whose heavy/light status can change are nodes that are initially on the right path</li></ul></li><li>对于斜堆而言，插入，合并，删除的<strong>最坏情况的复杂度</strong>都是$O(N)$, 三种操作的<strong>摊还代价</strong>都是$O(\log N)$ </li></ul></li></ul><h4 id="1-3-3-Binomial-Queue-二项队列"><a href="#1-3-3-Binomial-Queue-二项队列" class="headerlink" title="1.3.3 Binomial Queue 二项队列"></a>1.3.3 Binomial Queue 二项队列</h4><ul><li><p>定义：二项队列是<strong>一系列</strong>heap-order的tree，每一棵树是一个binomial tree</p></li><li><p>binomial tree 二项树</p><ul><li>高度为0的二项树是一个单节点的树</li><li>高度为k的二项树是由两个高度为k-1的二项树拼接而成的，formed by attaching a binomial tree to the root of another binomial tree of height k-1;</li><li>$B_k$ has k children and have $2^k$ nodes, the number of nodes in depth d is $C(k,d)$</li></ul></li><li><p>二项队列</p><ul><li>不同高度的二项树只能存在一个，如果存在两个相同的就要进行合并,数据结构的表示如下</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BinNode</span> <span class="token operator">*</span>Position<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Collection</span> <span class="token operator">*</span>BinQueue<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BinNode</span> <span class="token operator">*</span>BinTree<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">BinNode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> Element<span class="token punctuation">;</span>    Postion LeftChild<span class="token punctuation">;</span>    Postion NextSibling<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token class-name">Collection</span> <span class="token punctuation">&#123;</span> <span class="token keyword">int</span> CurrentSize<span class="token punctuation">;</span>  <span class="token comment">/* total number of nodes */</span>BinTreeTheTrees<span class="token punctuation">[</span> MaxTrees <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>支持的operation</p><ul><li><p>FindMin</p><ul><li>找到每棵树的根节点中的最小值即可</li><li>时间复杂度最多为$O(\log N)$ </li><li>可以用维护一个变量来存储一个二项堆列中的最小值，每次更新的时候检查该值是否改变，这样一来FindMin消耗<strong>常数时间</strong> </li></ul></li><li><p>Merge</p><ul><li>将两个高度相同的二项队列进行合并</li><li>将两棵高度相同的二项树合并成新的二项树，取小的作为根节点，如果有三棵树(进位产生了一棵)则随机选两棵树合并<ul><li>两个二项树合并的算法</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">BinTree <span class="token function">CombineTrees</span><span class="token punctuation">(</span> BinTree T1<span class="token punctuation">,</span> BinTree T2 <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">/* merge equal-sized T1 and T2 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span> T1<span class="token operator">-></span>Element <span class="token operator">></span> T2<span class="token operator">-></span>Element <span class="token punctuation">)</span><span class="token comment">/* attach the larger one to the smaller one */</span><span class="token keyword">return</span> <span class="token function">CombineTrees</span><span class="token punctuation">(</span> T2<span class="token punctuation">,</span> T1 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* insert T2 to the front of the children list of T1 */</span>T2<span class="token operator">-></span>NextSibling <span class="token operator">=</span> T1<span class="token operator">-></span>LeftChild<span class="token punctuation">;</span>T1<span class="token operator">-></span>LeftChild <span class="token operator">=</span> T2<span class="token punctuation">;</span><span class="token keyword">return</span> T1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度为$O(\log N)$ </li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">BinQueue  <span class="token function">Merge</span><span class="token punctuation">(</span> BinQueue H1<span class="token punctuation">,</span> BinQueue H2 <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>BinTree T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> Carry <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> H1<span class="token operator">-></span>CurrentSize <span class="token operator">+</span> H2<span class="token operator">-></span> CurrentSize <span class="token operator">></span> Capacity <span class="token punctuation">)</span>  <span class="token function">ErrorMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>H1<span class="token operator">-></span>CurrentSize <span class="token operator">+=</span> H2<span class="token operator">-></span> CurrentSize<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span> H1<span class="token operator">-></span>CurrentSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">*=</span><span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    T1 <span class="token operator">=</span> H1<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         T2 <span class="token operator">=</span> H2<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/*current trees */</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span> <span class="token number">4</span><span class="token operator">*</span><span class="token operator">!</span><span class="token operator">!</span>Carry <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span><span class="token operator">!</span><span class="token operator">!</span>T2 <span class="token operator">+</span> <span class="token operator">!</span><span class="token operator">!</span>T1 <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token comment">/* 000 */</span> <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token comment">/* 001 */</span>  <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token comment">/* 010 */</span>  H1<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> T2<span class="token punctuation">;</span> H2<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span> <span class="token comment">/* 100 */</span>  H1<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Carry<span class="token punctuation">;</span> Carry <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span> <span class="token comment">/* 011 */</span>  Carry <span class="token operator">=</span> <span class="token function">CombineTrees</span><span class="token punctuation">(</span> T1<span class="token punctuation">,</span> T2 <span class="token punctuation">)</span><span class="token punctuation">;</span>            H1<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H2<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span> <span class="token comment">/* 101 */</span>  Carry <span class="token operator">=</span> <span class="token function">CombineTrees</span><span class="token punctuation">(</span> T1<span class="token punctuation">,</span> Carry <span class="token punctuation">)</span><span class="token punctuation">;</span>            H1<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span> <span class="token comment">/* 110 */</span>  Carry <span class="token operator">=</span> <span class="token function">CombineTrees</span><span class="token punctuation">(</span> T2<span class="token punctuation">,</span> Carry <span class="token punctuation">)</span><span class="token punctuation">;</span>            H2<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span> <span class="token comment">/* 111 */</span>  H1<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Carry<span class="token punctuation">;</span>             Carry <span class="token operator">=</span> <span class="token function">CombineTrees</span><span class="token punctuation">(</span> T1<span class="token punctuation">,</span> T2 <span class="token punctuation">)</span><span class="token punctuation">;</span>             H2<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">/* end switch */</span><span class="token punctuation">&#125;</span> <span class="token comment">/* end for-loop */</span><span class="token keyword">return</span> H1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Insert</p><ul><li>是一种特殊的Merge，时间复杂度为$O(N)$</li><li>从一个空的二项队列开始插入N个元素最多消耗$O(N)$的时间，因此<strong>均摊到每一个操作上</strong>的时间复杂度是<strong>常数时间</strong></li></ul></li><li><p>Delete Min操作</p><ul><li>找到最小的根节点将其删除，将这颗二项树剩余的节点移除作为一个新的二项队列(find min)，将剩下的若干二项树作为一个新的二项队列，一共得到两个二项队列</li><li>将两个二项队列合并</li><li>时间复杂度为$O(\log N)$ </li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">ElementType  <span class="token function">DeleteMin</span><span class="token punctuation">(</span> BinQueue H <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>BinQueue DeletedQueue<span class="token punctuation">;</span> Position DeletedTree<span class="token punctuation">,</span> OldRoot<span class="token punctuation">;</span>ElementType MinItem <span class="token operator">=</span> Infinity<span class="token punctuation">;</span>  <span class="token comment">/* the minimum item to be returned */</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> MinTree<span class="token punctuation">;</span> <span class="token comment">/* MinTree is the index of the tree with the minimum item */</span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">IsEmpty</span><span class="token punctuation">(</span> H <span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">PrintErrorMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> –Infinity<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MaxTrees<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/* Step 1: find the minimum item */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> H<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> H<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>Element <span class="token operator">&lt;</span> MinItem <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> MinItem <span class="token operator">=</span> H<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>Element<span class="token punctuation">;</span>  MinTree <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">/* end if */</span><span class="token punctuation">&#125;</span> <span class="token comment">/* end for-i-loop */</span>DeletedTree <span class="token operator">=</span> H<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span> MinTree <span class="token punctuation">]</span><span class="token punctuation">;</span>  H<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span> MinTree <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment">/* Step 2: remove the MinTree from H => H’ */</span> OldRoot <span class="token operator">=</span> DeletedTree<span class="token punctuation">;</span>   <span class="token comment">/* Step 3.1: remove the root */</span> DeletedTree <span class="token operator">=</span> DeletedTree<span class="token operator">-></span>LeftChild<span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>OldRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>DeletedQueue <span class="token operator">=</span> <span class="token function">Initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* Step 3.2: create H” */</span> DeletedQueue<span class="token operator">-></span>CurrentSize <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>MinTree <span class="token punctuation">)</span> – <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">/* 2MinTree – 1 */</span><span class="token keyword">for</span> <span class="token punctuation">(</span> j <span class="token operator">=</span> MinTree – <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j – – <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      DeletedQueue<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> DeletedTree<span class="token punctuation">;</span>    DeletedTree <span class="token operator">=</span> DeletedTree<span class="token operator">-></span>NextSibling<span class="token punctuation">;</span>    DeletedQueue<span class="token operator">-></span>TheTrees<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-></span>NextSibling <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">/* end for-j-loop */</span>H<span class="token operator">-></span>CurrentSize  – <span class="token operator">=</span> DeletedQueue<span class="token operator">-></span>CurrentSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>H <span class="token operator">=</span> <span class="token function">Merge</span><span class="token punctuation">(</span> H<span class="token punctuation">,</span> DeletedQueue <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Step 4: merge H’ and H” */</span> <span class="token keyword">return</span> MinItem<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li></ul><h2 id="2-Algorithms"><a href="#2-Algorithms" class="headerlink" title="2. Algorithms"></a>2. Algorithms</h2><h3 id="2-1-Backtracking"><a href="#2-1-Backtracking" class="headerlink" title="2.1 Backtracking"></a>2.1 Backtracking</h3><ul><li>回溯法的基本思路：考虑所有可能的情况进行注意验证，在验证的过程中进行合理的剪枝(pruning)</li></ul><h4 id="案例1：八皇后问题"><a href="#案例1：八皇后问题" class="headerlink" title="案例1：八皇后问题"></a>案例1：八皇后问题</h4><ul><li><p>目标:在棋盘中找到八个位置放置皇后，使得它们都不同行且不同列，也不能同时位于对角线上</p></li><li><p>使用game tree的方式来表示回溯的过程：对于n个皇后的问题有n！种不同的情况需要验证</p></li></ul><h4 id="案例2：加油站问题"><a href="#案例2：加油站问题" class="headerlink" title="案例2：加油站问题"></a>案例2：加油站问题</h4><ul><li><p>目标：在一条直线上找到n个地方建立加油站，已知它们两两之间的距离，求出所有加油站的位置，假定第一个加油站的坐标是0</p></li><li><p>解决方式</p><ul><li>有$\frac{n(n-1)}{2}$个距离和n个加油站</li><li>首先需要根据加油站的数量计算出n的大小</li><li>先将第一个加油站和最后一个加油站的位置确定，并将已经可以计算出的距离从路径中删除</li><li>找到剩下的距离中最大的距离并检验，不断重复上述过程，如果检验失败则回到上一种情况，恢复原本被删除的距离再往下回溯<ul><li>每次检验分成靠近左边和靠近右边两种情况</li></ul></li><li>代码实现</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">Reconstruct</span> <span class="token punctuation">(</span> DistType X<span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">,</span> DistSet D<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right <span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">/* X[1]...X[left-1] and X[right+1]...X[N] are solved */</span>    bool Found <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">Is_Empty</span><span class="token punctuation">(</span> D <span class="token punctuation">)</span> <span class="token punctuation">)</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span> <span class="token comment">/* solved */</span>    D_max <span class="token operator">=</span> <span class="token function">Find_Max</span><span class="token punctuation">(</span> D <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* option 1：X[right] = D_max */</span>    <span class="token comment">/* check if |D_max-X[i]| in D is true for all X[i]’s that have been solved */</span>    OK <span class="token operator">=</span> <span class="token function">Check</span><span class="token punctuation">(</span> D_max<span class="token punctuation">,</span> N<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* pruning */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> OK <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* add X[right] and update D */</span>        X<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> D_max<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>left<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token function">Delete</span><span class="token punctuation">(</span> <span class="token operator">|</span>X<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">-</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">|</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token function">Delete</span><span class="token punctuation">(</span> <span class="token operator">|</span>X<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">-</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">|</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">;</span>        Found <span class="token operator">=</span> <span class="token function">Reconstruct</span> <span class="token punctuation">(</span> X<span class="token punctuation">,</span> D<span class="token punctuation">,</span> N<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>Found <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* if does not work, undo */</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>left<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token function">Insert</span><span class="token punctuation">(</span> <span class="token operator">|</span>X<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">-</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">|</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token function">Insert</span><span class="token punctuation">(</span> <span class="token operator">|</span>X<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">-</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">|</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* finish checking option 1 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>Found <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* if option 1 does not work */</span>        <span class="token comment">/* option 2: X[left] = X[N]-D_max */</span>        OK <span class="token operator">=</span> <span class="token function">Check</span><span class="token punctuation">(</span> X<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token operator">-</span>D_max<span class="token punctuation">,</span> N<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> OK <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            X<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> X<span class="token punctuation">[</span>N<span class="token punctuation">]</span> – D_max<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>left<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token function">Delete</span><span class="token punctuation">(</span> <span class="token operator">|</span>X<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">-</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">|</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token function">Delete</span><span class="token punctuation">(</span> <span class="token operator">|</span>X<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">-</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">|</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">;</span>            Found <span class="token operator">=</span> <span class="token function">Reconstruct</span> <span class="token punctuation">(</span>X<span class="token punctuation">,</span> D<span class="token punctuation">,</span> N<span class="token punctuation">,</span> left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>Found <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>left<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span> <span class="token operator">|</span>X<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">-</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">|</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span> <span class="token operator">|</span>X<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">-</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">|</span><span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* finish checking option 2 */</span>    <span class="token punctuation">&#125;</span> <span class="token comment">/* finish checking all the options */</span>        <span class="token keyword">return</span> Found<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>回溯算法的一种模板</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">Backtracking</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       bool Found <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">></span> N <span class="token punctuation">)</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span> <span class="token comment">/* solved with (x1, …, xN) */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> each xi in Si <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">/* check if satisfies the restriction R */</span>        OK <span class="token operator">=</span> <span class="token function">Check</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> …<span class="token punctuation">,</span> xi<span class="token punctuation">)</span> <span class="token punctuation">,</span> R <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* pruning */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> OK <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            Count xi in<span class="token punctuation">;</span>            Found <span class="token operator">=</span> <span class="token function">Backtracking</span><span class="token punctuation">(</span> i<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>Found <span class="token punctuation">)</span>                <span class="token function">Undo</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* recover to (x1, …, xi-1) */</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> Found <span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> Found<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>回溯方式的选择：应该选择<strong>从少到多</strong>的回溯方式，这样<strong>在剪枝的情况下可以排除更多的情况</strong> </li></ul><h4 id="案例3：AI下棋-Tic-tac-toe"><a href="#案例3：AI下棋-Tic-tac-toe" class="headerlink" title="案例3：AI下棋 Tic-tac-toe"></a>案例3：AI下棋 Tic-tac-toe</h4><ul><li>需要推算出所有可能的情况并选择当前胜率最高的情况往下走</li><li>Minimax Strategy 最大最小策略<ul><li>人需要最小化当前情况P的可能赢的情况，而AI要将它最大化</li><li>goodness函数 $f(P)=W_{AI}-W_{Human}$，<strong>W是当前情况下某一方可能赢的所有结果</strong>，不需要考虑另一方后面会怎么下，只要计算自己在当前局势下的任何可以赢的方</li></ul></li></ul><h4 id="剪枝-Pruning"><a href="#剪枝-Pruning" class="headerlink" title="剪枝 Pruning"></a>剪枝 Pruning</h4><ul><li>规则：每次在max里<strong>向下取最大</strong>的，在min里<strong>向下取最小</strong>的，并且上面的值是由下一层的取出来得到的，对于不会影响上一层取值的点就可以进行剪枝<ul><li>$\alpha$ pruning– max-min</li><li>$\beta$ pruning– min-max</li></ul></li></ul><h3 id="2-2-Divide-amp-Conquer"><a href="#2-2-Divide-amp-Conquer" class="headerlink" title="2.2 Divide &amp; Conquer"></a>2.2 Divide &amp; Conquer</h3><ul><li>A method to solve problem recursively 递归地解决问题    <ul><li>$T(N)=aT(N/b)+f(N)$</li><li>一些基本的例子<ul><li>最大子列和问题 —  $O(N\log N)$ </li><li>树的遍历—$O(N)$</li><li>归并排序和快速排序$O(N\log N)$ </li></ul></li></ul></li></ul><h4 id="案例1：Closest-Point-Problem"><a href="#案例1：Closest-Point-Problem" class="headerlink" title="案例1：Closest Point Problem"></a>案例1：Closest Point Problem</h4><ul><li>对于N个点，最垃圾的方法就是搜索$\frac{N(N-1)}{2}$次求出最短距离</li><li>分治法的解决思路<ul><li>将问题分成三个子问题，对于每个点，分别从同侧的左右两边和异侧来找到距离他最近的点<ul><li>需要按照x或者y坐标进行排序之后在进行分治，否则达不到$O(N\log N)$的复杂度</li></ul></li><li>$T(N)=3T(N/3)+f(N)$，因此总的时间复杂度是$O(N\log N)$ </li></ul></li></ul><h4 id="求解分治法时间复杂度的方法"><a href="#求解分治法时间复杂度的方法" class="headerlink" title="求解分治法时间复杂度的方法"></a>求解分治法时间复杂度的方法</h4><ul><li><p>Substitution Method</p><ul><li>总结了一下就是猜出答案</li></ul></li><li><p>Recursion-Tree Method</p><ul><li>画一棵很奇怪的树，我也不知道这玩意和直接进行数学上的推导有啥区别</li></ul></li><li><p>Master Method</p><ul><li><p>好！只要记住公式就行</p></li><li><p>一些细节</p><ul><li>N/b 是不是证书</li><li>T(N)=O(1)当N是比较小的数字的时候</li></ul></li><li><p>公式</p></li><li><p>总结起来就是三种情况: 是$N^{\log_ba}$ 的渐进上界，渐进下界和等价，证明可以通过取$N=b^k$来完成</p></li></ul></li><li><p>总结：分治法的时间复杂度可以通过下面的公式来总结</p></li></ul><h3 id="2-3-Dynamic-Programing"><a href="#2-3-Dynamic-Programing" class="headerlink" title="2.3 Dynamic Programing"></a>2.3 Dynamic Programing</h3><ul><li><p>solve sub-problems <strong>just once</strong> and save the answer in a <strong>table</strong> 用存储空间记录子问题的结果，避免重复的运算</p></li><li><p>Ordering Matrix Multiplications</p><ul><li><p>Let bn = the number of different ways to compute M1-Mn, Then $M_{1n}=M_{1i}M<br><em>{i+1,n}$ so $b_n=\sum</em>{i=1}^{n-1}b_ib_{n-i}$   // Catalan number</p></li><li><p>Let $M_{ij}$ be the cost of optional way to compute Mi-Mj, Then we have</p></li><li><p>这种算法的时间复杂度$T(N)=O(N^3)$, 而传统算法 $b_n=O(\frac{4^n}{n^{1.5}})$</p></li></ul></li><li><p>Optinmal BST</p><ul><li>using <strong>greedy method</strong> 每次选取可选范围内概率最高的作为根节点，递归建树，但不一定是最优</li></ul></li><li><p>动态规划的解决办法 $T(N)=O(N^3)$，该算法可以继续优化成$O(N^2)$ </p></li><li><p>All-Pairs Shortest Path</p><ul><li>find the shortest path between all pairs of vertices in the graph</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">AllPairs</span><span class="token punctuation">(</span> TwoDimArray A<span class="token punctuation">,</span> TwoDimArray D<span class="token punctuation">,</span> <span class="token keyword">int</span> N <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">int</span>  i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token comment">/* Initialize D */</span>          <span class="token keyword">for</span><span class="token punctuation">(</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> D<span class="token punctuation">[</span> i <span class="token punctuation">]</span><span class="token punctuation">[</span> j <span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span> i <span class="token punctuation">]</span><span class="token punctuation">[</span> j <span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> k<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token comment">/* add one vertex k into the path */</span>         <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>  <span class="token keyword">for</span><span class="token punctuation">(</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span>     <span class="token keyword">if</span><span class="token punctuation">(</span> D<span class="token punctuation">[</span> i <span class="token punctuation">]</span><span class="token punctuation">[</span> k <span class="token punctuation">]</span> <span class="token operator">+</span> D<span class="token punctuation">[</span> k <span class="token punctuation">]</span><span class="token punctuation">[</span> j <span class="token punctuation">]</span> <span class="token operator">&lt;</span> D<span class="token punctuation">[</span> i <span class="token punctuation">]</span><span class="token punctuation">[</span> j <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token comment">/* Update shortest path */</span>  D<span class="token punctuation">[</span> i <span class="token punctuation">]</span><span class="token punctuation">[</span> j <span class="token punctuation">]</span> <span class="token operator">=</span> D<span class="token punctuation">[</span> i <span class="token punctuation">]</span><span class="token punctuation">[</span> k <span class="token punctuation">]</span> <span class="token operator">+</span> D<span class="token punctuation">[</span> k <span class="token punctuation">]</span><span class="token punctuation">[</span> j <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>$T(N)=O(N^3)$ but faster in a dense graph</p></li><li><p>生产线问题</p><ul><li>两条生产线，每一步同时受到两条生产线前面一个步骤的影响，要求计算最短的加工时间</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> L<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>stage<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> stage<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> stage<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>line<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> line<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">;</span> line<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    f_stay <span class="token operator">=</span> f<span class="token punctuation">[</span>  line<span class="token punctuation">]</span><span class="token punctuation">[</span>stage<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> t_process<span class="token punctuation">[</span>  line<span class="token punctuation">]</span><span class="token punctuation">[</span>stage<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    f_move <span class="token operator">=</span> f<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">-</span>line<span class="token punctuation">]</span><span class="token punctuation">[</span>stage<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> t_transit<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">-</span>line<span class="token punctuation">]</span><span class="token punctuation">[</span>stage<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>f_stay<span class="token operator">&lt;</span>f_move<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      f<span class="token punctuation">[</span>line<span class="token punctuation">]</span><span class="token punctuation">[</span>stage<span class="token punctuation">]</span> <span class="token operator">=</span> f_stay<span class="token punctuation">;</span>      L<span class="token punctuation">[</span>line<span class="token punctuation">]</span><span class="token punctuation">[</span>stage<span class="token punctuation">]</span> <span class="token operator">=</span> line<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      f<span class="token punctuation">[</span>line<span class="token punctuation">]</span><span class="token punctuation">[</span>stage<span class="token punctuation">]</span> <span class="token operator">=</span> f_move<span class="token punctuation">;</span>      L<span class="token punctuation">[</span>line<span class="token punctuation">]</span><span class="token punctuation">[</span>stage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">-</span>line<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>背包问题</p><ul><li><p>一个背包的最大存储空间为M，将已知大小的N个物品选择一些放入背包中，每种物品的大小是$w_i$, 每种物品产生的收益是$x_i$ 目标是求解收益的最大值</p><ul><li>0-1背包问题：背包问题的特殊情况，物品只能整个放入或者不放入</li></ul></li><li><p>求解0-1背包问题的动态规划法</p><ul><li>分析：状态转移方程为$F_j=max(F_j,x_i+F_{j-w_i})_{w_i\le j}$ 也就是对于第i个物品，可以选择装上去也可以选择不装上去</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>M<span class="token punctuation">;</span>j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>    f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="2-4-Greedy"><a href="#2-4-Greedy" class="headerlink" title="2.4 Greedy"></a>2.4 Greedy</h3><ul><li>优化问题<ul><li><strong>Given a set of</strong> <strong>constraints</strong> <strong>and an</strong> <strong>optimization function</strong>. Solutions that satisfy the constrains are called <strong>feasible solutions</strong>. A feasible solution for which the optimization function has the best possible value is called an <strong>optimal solution</strong>. </li></ul></li><li>贪心算法<ul><li><strong>Make the</strong> <strong>best</strong> <strong>decision at each stage, under some</strong> <strong>greedy criterion**</strong>. A decision made in one stage is <strong>not changed</strong> <strong>in a later stage, so each decision should</strong> <strong>assure feasibility</strong></li><li>坚持局部最优直到全局最优，但<strong>不一定能达到全局最优</strong>,贪心算法的结果不一定是真正的最优解</li><li>Greedy algorithm works <strong>only if</strong> the local optimum is equal to the global optimum只在局部最优和全局最优等价的时候可以使用 </li></ul></li><li>Activity Selection Problem 活动安排问题<ul><li>动态规划方法:n个事件a1-an, Cij 表示第i和第j个事件之间能安排的最多的事件数目$c_{ij}=max(c_{ik}+c_{kj})+1$，时间复杂度$T=O(N^2)$    <ul><li>另一种动态规划方法$c_{1j}=max(c_{1,j-1},c_{1,k(j)}+1)$, 这里k(j)是距离aj最近的不冲突活动，并且要在aj之前完成</li><li>有权重的模式$c_{1j}=max(c_{1,j-1},c_{1,k(j)}+w_{ij})$</li></ul></li><li>贪心方法<ol><li>总是选择开始最早的—错</li><li>选择持续时间最短的活动—错</li><li>跟别的活动冲突最少—错</li><li>选择尽早结束的活动–对</li><li>选择最迟开始的活动–对<ul><li>规律：每个子问题中活动结束最早的一定会包含在最优解当中</li></ul></li></ol></li><li>Consider any nonempty subproblem Sk, and let am be an activity in Sk with the earliest finish time. Then am is included in <strong>some maximum-size subset</strong> of mutually compatible activities of Sk</li><li>corectness<ul><li>algorithm gives non-overlapping intervals</li><li>the result is optimal</li><li>需要证明按照这样的方法选取<strong>不会使得结果变差</strong> </li></ul></li></ul></li><li>可以进行贪心的基本条件<ul><li><strong>the local optimum is equal to the global optimum</strong></li><li>可以在做出一次贪心选择之后转化成一个子问题</li><li>证明用贪心的方法总能存在最优解</li><li>存在<strong>最优子结构</strong>(optimal substructure)，在做了贪心选择之后还可以在子问题中找到最优解</li></ul></li><li>Huffman Code哈夫曼编码–用于文件路径压缩<ul><li>把出现频率高的用短的01串来编码，以达到压缩路径的目的</li><li>需要保证没有一个字符是另一个字符的前缀，否则存在多种解码方式</li><li>等长编码：N个字母需要$\log_2N$位的01字符串进行编码</li></ul></li></ul><h2 id="3-CS-Theory"><a href="#3-CS-Theory" class="headerlink" title="3. CS Theory"></a>3. CS Theory</h2><h3 id="3-0-Amortized-Analysis-摊还分析"><a href="#3-0-Amortized-Analysis-摊还分析" class="headerlink" title="3.0 Amortized Analysis 摊还分析"></a>3.0 Amortized Analysis 摊还分析</h3><ul><li><h3 id="最坏bound-gt-摊还bound-gt-平均bound-不是cost，而是bound"><a href="#最坏bound-gt-摊还bound-gt-平均bound-不是cost，而是bound" class="headerlink" title="最坏bound&gt;=摊还bound&gt;=平均bound(不是cost，而是bound)"></a>最坏bound&gt;=摊还bound&gt;=平均bound(不是cost，而是bound)</h3><ul><li>”摊还cost一定小于平均cost“这样的表述是<strong>错</strong>的</li></ul></li><li><p>摊还分析<strong>不涉及概率</strong>上的分析，而可以保证<strong>最坏情况下每个操作的平均性能</strong> </p></li></ul><h4 id="案例：栈的multipop"><a href="#案例：栈的multipop" class="headerlink" title="案例：栈的multipop"></a>案例：栈的multipop</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>k<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">pop</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    k<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//The time cost T=min(sizeof(s),k)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>方法一：Aggregate analysis <strong>聚合分析</strong> </p><ul><li>基本思路：n个连续的操作最差情况下需要消耗的时间为T(n)，则每个操作的摊还代价为 T(n)/n</li><li>对于此题，一次multipop最差的时间复杂度为O(n)，但是pop的次数不能超过push的次数，而push最多有n次，因此n次的push，pop和multipop最多消耗O(n)的时间，摊还之后的时间复杂度就是常数时间</li></ul></li><li><p>方法二：Accounting method <strong>核算法</strong> </p><ul><li><p>基本思路：对不同的操作赋予不同的费用，可能会多于实际的代价，当一个操作的摊还代价超出实际的代价时就可以将多出来的存储邮与支付后续代价不够时的情况，称为<strong>信用</strong>credit，但是我们要<strong>始终保证信用不能是负数</strong>，也就是信用可以累计，但不能透支</p><table><thead><tr><th>操作</th><th>实际代价</th><th>摊还代价</th></tr></thead><tbody><tr><td>push</td><td>1</td><td>2</td></tr><tr><td>pop</td><td>1</td><td>0</td></tr><tr><td>multipop</td><td>min(k,s)</td><td>0</td></tr></tbody></table></li><li><p>我们可以把摊还代价设置成这样是因为pop次数之和肯定不会超过push的次数，因此可以保证任何情况下信用值不是负数，而此时摊还代价总和的上界为2n所以平均的摊还代价是O(1)</p></li></ul></li><li><p>方法三：Potential method 势能法</p><ul><li>基本思路：对信用进行更加定量的分析，定义势能函数使得 $c’<em>{i}=c</em>{i}+\Theta(D_{i})-\Theta(D_{i-1})$,计算得到，$\sum_{i=1}^{n}c’<em>{i}-\sum</em>{i=1}^{n}c_{i}=\Theta(D_{n})-\Theta(D_{0})$,因此需要保证势能函数最终值大于初始值</li><li>本题中，定义$\Theta(D_{n})$表示stack中的元素的个数，对于push，实际代价为1，引起的势能变化也是1，因此代价为2，而对于pop类型的操作，pop了K次的实际代价为K，引起势能的变化为-K，因此代价都是0，求和可得摊还代价为O(1)<ul><li>这类方法需要保证势能函数的初始值不能大于最终值</li><li><strong>In general, a good potential function should always assume its minimum at the start of the sequence.</strong> 一个好的势能函数需要让势能函数的初始值是最小值</li></ul></li></ul></li></ul><h3 id="3-1-P-and-NP"><a href="#3-1-P-and-NP" class="headerlink" title="3.1 P and NP"></a>3.1 P and NP</h3><ul><li><p>Recall</p><ul><li>Euler circuit problem 欧拉回路问题: find a path that touches <strong>every edge exactly once</strong> 找到一条路径经过每条边恰好一次，一笔画问题</li><li>Hamilton cycle problem: find a single cycle that contains every vertex 找到一个回路经过每个点一次</li><li>Halting problem 停机问题: Is it possible to have your C compliler detect all infinite loops?—No 编译器不能发现所有的无限循环</li></ul></li><li><p>图灵机 Turing Machine</p><ul><li>组成：Infinite Memory &amp;&amp; Scanner 无限的内存和扫描头<ul><li>scanner 上有若干head，每一个扫描头一次只能指向一个state，并且一次只能左右移动一格</li></ul></li><li>可以执行的操作：<ul><li>change the finite control state 改变</li><li>erase the symbol in the unit currently pointed by head and write a new symbol in 清除并写入</li><li>Head moves on unit to left or right or stays at its current position 左右移动或保持不动</li></ul></li><li>A <strong>deterministic turing machine</strong> executes one instruction at each point in time. Then depending on the instruction and it goes to the next unique instruction <strong>确定性</strong>图灵机<ul><li>对于给定的输入<strong>每一步的执行都是唯一的</strong>图灵机 </li></ul></li><li>A nondeterministic turing machine is free to choose its nect step from a finite set and is one of the steps leads to a solution, it will always choose the correct one不确定性图灵机<ul><li>对于给定的输入可以自由选择执行的下一步，并且会选择正确的solution</li></ul></li></ul></li><li><p>NP problem</p><ul><li>A problem is NP if we can prove any solution is true in polynomial time可以在<strong>多项式的时间内验证</strong>问题的<strong>任意解</strong>是对的</li><li>Not all the decidable problems are in NP. 可描述的问题不全是NP问题</li></ul></li><li><p>NP-Complete Problems – the hardest    NP完全问题</p><ul><li>性质：any problem in NP can be polynomially reduced to it 一个NPC问题可以从任何NP问题通过多项式规约得到</li><li>NP-hard + NP 可以推出是NPC</li><li>如果我们可以在多项式时间内解决<strong>任何一个NPC问题</strong>，那么我们就可以在<strong>多项式时间内解决所有NP问题</strong></li><li>例如，如果哈密顿回路问题是NPC问题，我们可以推断出旅行商人问题**(简称TSP问题)**也是NPC问题<ul><li>一个问题可以被归约成HCP问题，然后被归约成TSP问题，也就是说归约具有传递性</li></ul></li><li>第一个被证明为是NPC问题的是<strong>Circuit Satisfiability问题</strong>(Circuit SAT)</li><li>SAT问题，顶点覆盖问题，哈密顿回路问题都是NPC问题，<strong>停机问题不是NPC问题</strong></li></ul></li></ul><ul><li><h2 id="P，NP，NPH，NPC的关系总结"><a href="#P，NP，NPH，NPC的关系总结" class="headerlink" title="P，NP，NPH，NPC的关系总结"></a>P，NP，NPH，NPC的关系总结</h2><ul><li>P是可以在多项式时间内解决的问题，NP是可以在多项式时间内验证一组特定的解是否正确的问题，NP-hard问题是NP问题可以通过多项式归约得到的一个较为复杂的问题，NPC问题就是NP问题归约之后得到的，NPC问题既是NP又是NP-hard</li><li>几个问题的<strong>包含关系</strong>是，$P\subset NP,NP\cap NP-hard=NPC$ </li></ul></li><li><p>形式化的语言描述</p><ul><li><p>Abstract Problem：a binary relation on a set I of problem instances and a set S of problem solutions.</p></li><li><p>形式化语言的描述</p></li><li><p>A verification algorithm is a two-argument algorithm A, where one argument is an ordinary input string x and the other is a binary string  y called a certificate. </p></li></ul></li><li><p>SAT问题就是给定n个布尔变量$x_i$，从他们本身和他们的否中选出K组，每组m个变量，小组取并集，大组取交集，要求让最后的结果是1，这样的叫做<code>m-SAT</code>问题</p><ul><li>如果最大团问题是NPC问题，则顶点覆盖问题也是NPC问题<ul><li>转化方式是一个图G如果有大小为K的最大团当且仅当G的补图有一个大小为<code>|V|-K</code>的顶点覆盖</li></ul></li><li><code>co-NP</code>是所有满足L的补和L本身都是NP问题的形式化语言L所构成的集合<ul><li>这些概念最有可能的关系是，NP和co-NP有交集，P包含在这个交集当中</li><li>$L\in NP\and co-NP$ 如果L是一个P问题 </li></ul></li></ul></li></ul><h3 id="3-2-Approximation-algorithm"><a href="#3-2-Approximation-algorithm" class="headerlink" title="3.2 Approximation algorithm"></a>3.2 Approximation algorithm</h3><ul><li>Approximation Ratio近似率<ul><li>对于任何规模为n的输入，C为算法的cost，C*为优化后的算法的cost，则$max(\frac{C}{C’},\frac{C’}{C})\leq\rho(n)$ , 如果一个算法的近似率达到了$\rho(n)$则该算法可以被称为一个$\rho(n)$-近似算法</li><li><strong>approximation scheme</strong>：除了n以外还收一个参数$\epsilon$影响</li><li>PTAS： polynomial-time approximation scheme 关于n成多项式复杂度的算法(对于特定的$\epsilon$)</li><li>FPTAS：fully polynomial-time approximation scheme 关于n和$\epsilon$都成多项式复杂度的算法</li></ul></li></ul><h4 id="案例1：Bin-Packing"><a href="#案例1：Bin-Packing" class="headerlink" title="案例1：Bin Packing"></a>案例1：Bin Packing</h4><ul><li>Next Fit方法：策略是<strong>尽可能先把箱子填满</strong><ul><li>性质：如果最优的方法需要M个箱子，那么next fit方法使用的箱子不会超过<code>2M-1</code>，可以用反证法证明该结论，最重要的条件是<strong>相邻的两个箱子内的和肯定大于1</strong>，否则就会放到一个箱子里<ul><li>策略是当前箱子放不下直接到下一个去</li></ul></li></ul></li></ul><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">void NextFit ( )&#123;   read item1;    while ( read item2 ) &#123;        if ( item2 can be packed in the same bin as item1 )place item2 in the bin;        elsecreate a new bin for item2;        item1 &#x3D; item2;    &#125; &#x2F;* end-while *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>First Fit方法：策略是<strong>找到第一个能放下的箱子</strong> <ul><li>可以用$O(N\log N)$的时间复杂度来实现这个算法</li><li>如果最优的情况需要M个箱子，那么这个算法所需要的箱子不会多余1.7M</li></ul></li></ul><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">void FirstFit ( )&#123;   while ( read item ) &#123;        scan for the first bin that is large enough for item;        if ( found )place item in that bin;        elsecreate a new bin for item;    &#125; &#x2F;* end-while *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Best Fit方法：策略是找到<strong>能放下这个当前物品并且剩余空间最小的箱子</strong><ul><li>时间复杂度也是$O(N \log N)$ ,所需要的箱子个数不会超过最优解的1.7倍</li><li>以上三种实际上都是<strong>Online Algorithm</strong>，可以证明只要是Online的算法所需要的箱子的个数不会少于最优解的5/3倍</li></ul></li><li>OffLine Algorithm<ul><li>在开始装箱之前先检查一次所有的箱子并按照非递增的顺序排序，然后使用First Fit算法，这种情况下需要的箱子的个数不会超过(11M+6)/9</li><li>简单的贪心方法会给出一些比较好的结果</li></ul></li></ul><h4 id="案例2：Knapsack-Problem-0-1背包问题"><a href="#案例2：Knapsack-Problem-0-1背包问题" class="headerlink" title="案例2：Knapsack Problem 0-1背包问题"></a>案例2：Knapsack Problem 0-1背包问题</h4><ul><li>目标：将N个物品装入容量为M的背包里，每个物品有自己的重量Wi和收益Pi，最终目标是要让收益最大化</li><li>使用贪心算法的近似率是2，证明如下<ul><li>注意到这些关系: $p_{max}\le P_{opt}\le P_{frac}$, $p_{max}\le P_{greedy}$ , $P_{opt}\le P_{greedy}+p_{max}$ 因此可以得到$\frac{P_{opt}}{P_{greedy}} \le1+\frac{p_{max}}{P_{greedy}}\le 2$ </li></ul></li><li>使用动态规划的方法求解<ul><li>$W_{i,p}$ 代表仅考虑前i个物品利益最大化的最小的重量，则状态转移方程为$W_{i,p}=W_{i-1,p}$(如果pi&gt;p) $W_{i,p}=min(W_{i-1,p},W_{i-1,p-p_i}+w_i)$ </li><li>这种动态规划算法的事件复杂度是$O(n^2p_{max})$ </li></ul></li><li>背包问题是<code>NP-hard</code>问题，但是如果对于规模为n的背包问题，没有一个物品的大小超过多项式复杂度则不是NP-hard问题</li></ul><h4 id="案例3：K-center-problem"><a href="#案例3：K-center-problem" class="headerlink" title="案例3：K-center problem"></a>案例3：K-center problem</h4><ul><li><p>问题描述: 在给定的N个点的平面中选择K个点(不一定是已有的点)作为中心作圆覆盖所有的点，要求使得这些圆中的最大半径(distance)取得最小值</p><ul><li>关于距离的定义：需要运算函数满足同一性，对成性和三角不等式</li><li>一种贪心的思路: 将第一个中心放在尽可能好的地方，然后不断加入点使得覆盖半径减小</li><li>如果知道最优的解C*</li></ul><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">Centers  Greedy-2r ( Sites S[ ], int n, int K, double r )&#123;   Sites  S’[ ] &#x3D; S[ ]; &#x2F;* S’ is the set of the remaining sites *&#x2F;    Centers  C[ ] &#x3D; empty;    while ( S’[ ] !&#x3D; empty ) &#123;        Select any s from S’ and add it to C;        Delete all s’ from S’ that are at dist(s’, s) &lt;&#x3D; 2r;    &#125; &#x2F;* end-while *&#x2F;    if ( |C| &lt;&#x3D; K ) return C;    else ERROR(No set of K centers with covering radius at most r);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果不知道最优解r(C*): 采用<strong>二分法</strong>，将已知的最大半径和0作为起点进行二分</li></ul><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">Centers  Greedy-Kcenter ( Sites S[ ], int n, int K )&#123;   Centers  C[ ] &#x3D; empty;    Select any s from S and add it to C;    while ( |C| &lt; K ) &#123;        Select s from S with maximum dist(s, C);        Add s it to C;    &#125; &#x2F;* end-while *&#x2F;    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种算法的<strong>近似率是2</strong>，因此是个2-approximation </li><li><strong>除非P=NP，否则K-center问题不存在近似率小于2的逼近算法</strong> </li></ul></li></ul><h3 id="3-3-Local-Search局部搜索"><a href="#3-3-Local-Search局部搜索" class="headerlink" title="3.3 Local Search局部搜索"></a>3.3 Local Search局部搜索</h3><ul><li><p>和贪心算法是有区别的，贪心算法不是局部搜索的特例</p></li><li><p>局部搜索的框架Local Search Framework</p><ul><li>Local：a local optimum is a best solution in a neighborhood<ul><li>定义邻居关系：S ~ S’: S‘ is a neighboring solution of S – S’ can be obtained by a <strong>small modification</strong> of S.</li><li>N(S): neighborhood of S</li></ul></li><li>Search：在neighborhood中从一个点出发，找到局部最优的解<ul><li><strong>gradient descent</strong> —— 梯度下降法，找梯度下降最快的方向来优化</li></ul></li></ul></li><li><p>局部搜索算法的框架</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">SolutionType <span class="token function">Gradient_descent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       Start from a feasible solution S in FS <span class="token punctuation">;</span>    MinCost <span class="token operator">=</span> <span class="token function">cost</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        S’ <span class="token operator">=</span> <span class="token function">Search</span><span class="token punctuation">(</span> <span class="token function">N</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* find the best S’ in N(S) */</span>        CurrentCost <span class="token operator">=</span> <span class="token function">cost</span><span class="token punctuation">(</span>S’<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> CurrentCost <span class="token operator">&lt;</span> MinCost <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            MinCost <span class="token operator">=</span> CurrentCost<span class="token punctuation">;</span>                S <span class="token operator">=</span> S’<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>  <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> S<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="案例1：顶点覆盖问题"><a href="#案例1：顶点覆盖问题" class="headerlink" title="案例1：顶点覆盖问题"></a>案例1：顶点覆盖问题</h4><ul><li><p>问题描述：在无向图G中找出最小的点集S，对于G的每一条边，至少有一个顶点在S中</p><ul><li><p>快速得到可行解：直接取所有的顶点，此时的<code>cost(S)=|S|</code></p></li><li><p>S’是S的邻居，如果S’可以从S中去掉一个点得到</p></li><li><p>搜索方法：从S=V开始，每次删除一个点并且检查是否为最小覆盖</p><ul><li>梯度下降法不一定work，改进后的算法：Metropolis Algorithm</li><li>梯度下降法是定向选择邻居，而metropolis是<strong>随机选择邻居</strong>的算法</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">SolutionType <span class="token function">Metropolis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       Define constants k and T<span class="token punctuation">;</span>    Start from a feasible solution S in FS <span class="token punctuation">;</span>    MinCost <span class="token operator">=</span> <span class="token function">cost</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        S’ <span class="token operator">=</span> Randomly chosen from <span class="token function">N</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>         CurrentCost <span class="token operator">=</span> <span class="token function">cost</span><span class="token punctuation">(</span>S’<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> CurrentCost <span class="token operator">&lt;</span> MinCost <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            MinCost <span class="token operator">=</span> CurrentCost<span class="token punctuation">;</span>    S <span class="token operator">=</span> S’<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            With a probability e<span class="token operator">^</span><span class="token punctuation">&#123;</span><span class="token operator">-</span>dcost<span class="token operator">/</span>KT<span class="token punctuation">&#125;</span>  <span class="token punctuation">,</span> let S <span class="token operator">=</span> S’<span class="token punctuation">;</span>            <span class="token keyword">else</span>  <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> S<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="案例2：Hopfield-Neural-Network"><a href="#案例2：Hopfield-Neural-Network" class="headerlink" title="案例2：Hopfield Neural Network"></a>案例2：Hopfield Neural Network</h4><ul><li><p>无向图G中的边带有权重wi, wi是正数时两个节点状态不同，是负数时节点状态相同。<strong>There may be</strong> <strong>no</strong> <strong>configuration that respects the requirements imposed by</strong> <strong>all</strong> <strong>the edges.</strong></p><ul><li>定义好边和坏边(好边就是满足条件的边) $w_es_us_v&lt;0$ </li><li>对于一个顶点，如果其好边数大于坏边数则称之为满足的，如果所有点都是满足的，那么这个图就是稳定的</li><li><strong>state-flipping</strong>算法</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">ConfigType <span class="token function">State_flipping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Start from an arbitrary configuration S<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span> <span class="token function">IsStable</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        u <span class="token operator">=</span> <span class="token function">GetUnsatisfied</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>        su <span class="token operator">=</span> <span class="token operator">-</span> su<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> S<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>State-flipping算法最多在$W=\sum|w_e|$次循环后达到稳定情况，所以一定会停止</li></ul></li></ul><h4 id="案例3：Max-Cut-Problem"><a href="#案例3：Max-Cut-Problem" class="headerlink" title="案例3：Max Cut Problem"></a>案例3：Max Cut Problem</h4><ul><li>在无向图G中找到一个分割(A,B),使得$w(A,B)=\sum_{u\in A, v\in b}w_{uv}$最大<ul><li>可行解：任何一种分割方案</li><li>邻居的定义：S’可以由S在两个分割AB之间移动一个点得到，<strong>实际上是Hopfield Neural Network的一种特殊情况</strong> </li><li>定理：局部最优解的权重和不会低于全局最优解的一半 $w(A,B)\ge \frac{1}{2}w(A*,B*)$  </li><li><strong>big-improvement-flip</strong>算法：当新的局部最优解的增长的幅度小于$\frac{2\epsilon}{|v|}w(A,B)$的时候就停止，为了让算法可以在多项式时间内结束<ul><li>这样以来就有 $(2+\epsilon)w(A,B)\ge w(A*,B*)$   </li><li>最多$O(\frac{n}{\epsilon}\log W)$ 次flips之后就可以停下来</li></ul></li><li>最大分割问题存在近似于为1.1382的逼近算法，但是没有近似率低于$\frac{17}{16}$的</li></ul></li></ul><h3 id="3-4-Random-Algorithm-随机算法"><a href="#3-4-Random-Algorithm-随机算法" class="headerlink" title="3.4 Random Algorithm 随机算法"></a>3.4 Random Algorithm 随机算法</h3><ul><li><p>用随机的决策来处理最坏的情况</p></li><li><p>基本的性质</p><ul><li><strong>efficient randomized algorithms that only need to yield the correct answer with</strong> <strong>high probability</strong> 用非常高的概率给出正确的答案</li><li><strong>randomized algorithms that are always correct, and run efficiently</strong> <strong>in expectation</strong> 总是正确的，并且在期望中运行的很有效率</li></ul></li></ul><h4 id="案例1：雇佣问题"><a href="#案例1：雇佣问题" class="headerlink" title="案例1：雇佣问题"></a>案例1：雇佣问题</h4><ul><li>总的cost=天数N * 每天面试的花费 + 雇佣的人数M*雇佣费用</li><li>一种简单的算法<ul><li>但这种算法在参加者的质量递增的时候会不work</li></ul></li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Hiring</span> <span class="token punctuation">(</span> EventType C<span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> N <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">/* candidate 0 is a least-qualified dummy candidate */</span>    <span class="token keyword">int</span> Best <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> BestQ <span class="token operator">=</span> the quality of candidate <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Qi <span class="token operator">=</span> <span class="token function">interview</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Ci */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> Qi <span class="token operator">></span> BestQ <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            BestQ <span class="token operator">=</span> Qi<span class="token punctuation">;</span>            Best <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token function">hire</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Ch */</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> Best<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>如果参加面试者的顺序是随机的，那么最后的总cost是$O(C_h\ln N+NC_i)$ ，但是需要进行随机的排列，将上述算法中的数组C进行随机的排列之后在进行就可以达到这种效果</p></li><li><p>Randomized Permutation 随机排序算法</p><ul><li>一种比较简单的实现方式：生成<strong>随机数来代表元素的优先级</strong> </li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">PermuteBySorting</span> <span class="token punctuation">(</span> ElemType A<span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> N <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>        A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>P <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>N3<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">/* makes it more likely that all priorities are unique */</span>    Sort A<span class="token punctuation">,</span> using P as the sort keys<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="案例2：雇佣问题-online"><a href="#案例2：雇佣问题-online" class="headerlink" title="案例2：雇佣问题(online)"></a>案例2：雇佣问题(online)</h4><ul><li>新的解决思路：先面试前k个不录取，在后面的N-K个人中选出第一个比前K个最高分要高的</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">OnlineHiring</span> <span class="token punctuation">(</span> EventType C<span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> k <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> Best <span class="token operator">=</span> N<span class="token punctuation">;</span>    <span class="token keyword">int</span> BestQ <span class="token operator">=</span> <span class="token operator">-</span> INF <span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>k<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Qi <span class="token operator">=</span> <span class="token function">interview</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> Qi <span class="token operator">></span> BestQ <span class="token punctuation">)</span>   BestQ <span class="token operator">=</span> Qi<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Qi <span class="token operator">=</span> <span class="token function">interview</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> Qi <span class="token operator">></span> BestQ <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            Best <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> Best<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>记Si为第i个人被录取的概率，则需要满足第i个人是得分最高的并且第k+1到i-1个人都没有被录取</li></ul><p>$$<br>P(S_i)=\frac{k}{N(i-1)}\<br>P(S)=\sum\limits_{i=k+1}\limits^{N}\frac{k}{N(i-1)}=\frac{k}{N}\sum\limits_{i=k}\limits^{N-1}\frac{1}i\<br>\frac{k}{N}\ln \frac{N}{k}\le P(S)\le \frac{k}{N}\ln \frac{N-1}{k-1}<br>$$</p><ul><li>用求导的方法可以得到最合适的k值，应该是N/e(e是自然对数的底数)</li></ul><h4 id="案例3：快速排序"><a href="#案例3：快速排序" class="headerlink" title="案例3：快速排序"></a>案例3：快速排序</h4><ul><li>确定性的算法中，快排<strong>最差的时间复杂度</strong>是$O(N^2)$，</li><li>平均的时间复杂度是$O(N\log N)$ 要求是   <strong>every input permutation is equally likely</strong> </li><li>随机选择一个位置作为pivot<ul><li>central splitter：将数组分成两段的pivot并且每段至少是总长度的1/4</li><li>Modified Quicksort：在开始递归之前选择出一个中心分割点</li></ul></li><li><strong>The expected number of iterations needed until we find a central splitter is at most 2.</strong></li><li>最终随机选择pivot的快速排序的复杂度是$O(N\log N)$ </li></ul><h3 id="3-5-Parallel-Algorithm-并行算法"><a href="#3-5-Parallel-Algorithm-并行算法" class="headerlink" title="3.5 Parallel Algorithm 并行算法"></a>3.5 Parallel Algorithm 并行算法</h3><ul><li><p>两种并行算法的模型</p><ul><li><p>Parallel Random Access Machine(PRAM)</p><ul><li><p>使用<strong>共享的内存</strong>，每个进程消耗unit time access</p></li><li><p>解决访问冲突的办法</p><ul><li>EREW：不能同时读写一个位置</li><li>CREW：可以同时读不能同时写</li><li>CRCW：可以同时读写</li></ul></li><li><p>计算n个数的和</p></li><li><p>缺点</p></li></ul></li><li><p>不能知道当处理器个数发生变化的时候会如何影响我们的算法</p><ul><li><strong>Fully specifying the allocation of instructions to processors requires a level of detail which might be unnecessary</strong></li></ul></li><li><p>Work-Depth(WD)算法</p><ul><li>In Work-Depth presentation, each time unit consists of a sequence of instructions to be performed concurrently; the sequence of instructions may include <strong>any number</strong> </li></ul></li></ul></li><li><p>计算n个数的和，操作总数变少了</p></li><li><p>评定平行算法优劣的规则</p><ul><li>Work Load 工作总量 W(N)</li><li>最坏的运行时间 T(N)<ul><li>P(N)=W(N)/T(N) processors and T(N) time(on a PRAM)</li><li>W(N)/p time using any number of p(less than W(N)/T(N)) processors(on a PRAM)</li><li>W(N)/P+T(N) time using any number of p processors(on a PRAM)</li></ul></li></ul></li><li><p><strong>WD-presentation Sufficiency</strong> <strong>Theorem</strong></p><ul><li><p><strong>An algorithm in the WD mode can be implemented by any P(n) processors within</strong></p><p><strong>O(W(n)/P(n) + T(n)) time, using the same concurrent-write convention as in the WD presentation.</strong></p></li></ul></li></ul><h4 id="案例1：Prefix-Sum"><a href="#案例1：Prefix-Sum" class="headerlink" title="案例1：Prefix Sum"></a>案例1：Prefix Sum</h4><ul><li>T(N)=O(log N) W(N)=O(N)</li></ul><h4 id="案例2：数组归并"><a href="#案例2：数组归并" class="headerlink" title="案例2：数组归并"></a>案例2：数组归并</h4><ul><li><p>将两个单调不减的数组A,B合并成两个</p><ul><li><p>简化一下问题，m=n，并且A,B中的元素各不相同，log n是整数</p></li><li><p>分割法 Partitioning Paradigm</p><ul><li><p>分割成若干个小问题，并行执行</p></li><li><p>引入RANK(j,A)表示B[j]元素位于A的哪两个元素之间，分别计算A和B的所有RANK，然后采用如下方法归并</p></li><li><p>计算RANK使用二分查找，可以使时间复杂度变成log n级别</p></li></ul></li></ul></li><li><p>本算法的时间复杂度为<code>log n</code>，work load的大小是<code>n log n</code></p><ul><li>传统的串行算法：时间复杂度和work load都是<code>O(n+m)</code>级别 </li></ul></li><li><p>新算法：parallel ranking</p><ul><li>假设n=m并且数组严格递增</li><li>步骤一：令$p=\frac{n}{\log n}$ ，把两个数组分别等分成P组，<strong>间隔为log n</strong>，并计算每个小组中的RANK </li><li>步骤二：Actual Ranking 有2p个规模为O(log n)的子问题，所以总的时间复杂度还是log n，但是work load变成了O(n)级别</li></ul></li></ul><h4 id="案例3：找最大值"><a href="#案例3：找最大值" class="headerlink" title="案例3：找最大值"></a>案例3：找最大值</h4><ul><li><p>把求和算法中的+改成max即可使用</p></li><li><p>第一种算法：时间O(1), work load是$n^2$</p></li><li><p>第二种：双对数算法</p><ul><li>$h=\log \log n$ ，将问题按照$\sqrt{n}$ 的规模划分成$\sqrt{n}$个子问题，对每个子问题用时间和work load都为$O(\sqrt n)$的算法解决，最后用第一种算法求出$\sqrt{n}$个结果中的最大值<ul><li>最后的结果是$T(n)=O(\log \log n)$ $W(n)=n\log \log n$ </li></ul></li><li>另外的划分方式：照规模为h进行划分，最后的Work Load变成了O(n)</li></ul></li><li><p>第三种：随机算法，高概率使得$T(n)=O(1)$ 并且$W(n)=O(n)$ </p><ul><li>【Theorem】The algorithm finds the maximum among n elements. With very high probability it runs in O(1) time and O(n) work. The probability of not finishing within this time and work complexity is $O(1/n^c)$ for some positive constant c.</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>there is an element larger than M<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span>each element larger than M<span class="token punctuation">)</span>         Throw it into a random place in a new <span class="token function">B</span><span class="token punctuation">(</span>n7<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Compute a new M<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-External-Sorting-外部排序"><a href="#3-6-External-Sorting-外部排序" class="headerlink" title="3.6 External Sorting 外部排序"></a>3.6 External Sorting 外部排序</h3><ul><li><p>为什么不直接在磁盘上进行快排？</p><ul><li>磁盘I/O的效率太低了，需要找到磁道和扇区</li><li>解决方法：使用tapes进行排序<ul><li>tape的特点：只能顺序地访问，不能像内存中的数组一样直接寻址</li><li><strong>至少需要3条tapes</strong> </li></ul></li></ul></li><li><p>假如内存里最多可以保持M条记录，对N个元素进行排序</p><ul><li>每次读出M个数据放进内存进行排序，然后放在tapes中</li><li>一共需要进行的循环的次数(passes)  $1+[\log_{2}(N/M)]$ 向上取整(2路归并) </li></ul></li><li><p>优化的目标</p><ul><li>减少循环的次数</li><li>run merging</li><li>并行操作的缓冲处理</li><li>run generation 生成更好的run</li></ul></li><li><p><strong>减少循环的次数</strong>的方法 </p><ul><li>使用K路归并排序，需要的pass数变成了$1+[\log_k(N/M)]$ </li><li>缺点是<strong>需要2k个磁带</strong>，比较消耗磁带</li></ul></li><li><p>用更少的磁带来进行排序</p><ul><li><p>用3个tape来进行二路归并排序</p><ul><li>不要进行对半拆分，采用不对等的拆分来做</li><li><strong>合并的次数相比于对半分变多了，但是不需要进行磁带的复制，会更加节约时间</strong>, 不对称分割效率反而高的原因是减少了磁带复制的时间消耗</li></ul></li><li><p>当run的次数是斐波那契数Fn的时候最好的拆分的办法是把它拆成Fn-1和Fn-2</p></li><li><p>对于K路merge</p></li><li><p>如果不是斐波那契数，可以<strong>增加一些空的runs</strong>来凑到斐波那契数</p></li></ul></li><li><p>K路的merge最少需要k+1个tapes</p></li><li><h1 id="缓冲区的优化-这里还是没搞明白"><a href="#缓冲区的优化-这里还是没搞明白" class="headerlink" title="缓冲区的优化(这里还是没搞明白)"></a>缓冲区的优化(这里还是没搞明白)</h1><ul><li>并行的实际上是对buffer的读和写</li><li>对于一个K路归并，需要2k个输入buffer和2个输出buffer来进行并行操作</li><li>事实上K不是越大越好，因为如果K增大，就会导致input buffer的数量需求增加，导致buffer size减少，导致磁盘中一个block的size减少，导致访问磁盘的seek time增加，因此最优的K值取决于磁盘的参数和外部memory的规模</li></ul></li><li><p>如何获取更加长的run</p><ul><li>使用堆的结构来进行排序操作，规则是一直取出堆中现存的可以放在现在所在的run后面的最小的数，直到堆中的数据都放不进当前run了再更换一个run</li><li>如果内存可以容纳M个元素，则这种方法生成的run的平均长度为2M</li><li>再输入的元素接近已经排好序的状态时非常work</li></ul></li><li><p>最小化merge的时间(这个比较简单)</p><ul><li>使用哈夫曼树，每次把最短的两个run进行合并</li><li>T=O(the weighted external path length)</li></ul></li></ul><h2 id="4-新增内容：Project知识点的考察"><a href="#4-新增内容：Project知识点的考察" class="headerlink" title="4. 新增内容：Project知识点的考察"></a>4. 新增内容：Project知识点的考察</h2><ul><li>突然说道考试要考project中出现过的内容，心血来潮整理一下这学期七个project中的相关内容</li></ul><h3 id="4-1-Project-1：Shortest-path-with-heaps"><a href="#4-1-Project-1：Shortest-path-with-heaps" class="headerlink" title="4.1 Project 1：Shortest path with heaps"></a>4.1 Project 1：Shortest path with heaps</h3><ul><li>这个project是唯一一个我们小组没有做过的project</li><li>斐波那契堆：本题中引入的一种新的堆数据结构，具体的性质如下<ul><li>斐波那契堆和二项队列类似，是一组最小堆有序树构成的，相比于二项队列有更好的摊还性能</li><li>堆中的每一棵树都有根但是无序，每个节点x包含指向父节点的指针和指向任意一个子节点的指针，x的所有子节点都用双向的循环链表链接，称为x的子链表中的节点都有指向左右兄弟，所有的根节点之间也用一个双向的循环链表连接起来</li><li>需要维护一个<strong>指向斐波那契堆最小元素的指针</strong> </li><li>各种操作的时间复杂度的分析<ul><li>FindMin：因为维护了一个指向最小元素的指针，所以时间复杂度是$O(1)$ </li><li>DeleteMin: 需要先FindMin之后在进行合并，总的时间复杂度是$O(\log N)$</li><li>Decrease Key: 可能需要进行位置的调整，时间复杂度是$O(\log N)$</li><li>Insert：时间复杂度是$O(\log N)$，但是摊还代价是$O(1)$ </li></ul></li><li>总的空间复杂度是线性的</li></ul></li></ul><h3 id="4-2-Project-2：Safe-fruit"><a href="#4-2-Project-2：Safe-fruit" class="headerlink" title="4.2 Project 2：Safe fruit"></a>4.2 Project 2：Safe fruit</h3><ul><li>这个感觉也没什么好讲的，是一个非常具体的算法题，用回溯法实现，感觉直接拿来考没有什么必要</li></ul><h3 id="4-3-Project-3：Beautiful-Sequence"><a href="#4-3-Project-3：Beautiful-Sequence" class="headerlink" title="4.3 Project 3：Beautiful Sequence"></a>4.3 Project 3：Beautiful Sequence</h3><ul><li>这个题也是一个非常具体的算法题，主要就是定义了一种Beautiful Sequence的结构<ul><li>一个序列被称为是漂亮的，如果它包含两个相邻的元素，并且两个元素的差的绝对值小于一个给定的数字m</li><li>这个project就是需要计算所有可能的<strong>漂亮子序列</strong>的个数</li></ul></li><li>如果采用传统的方法逐一验证，那么对于长为n的序列，其子序列个数为$2^n$，则验证所需要的时间复杂度是$O(2^NN)$，是非常离谱的，但是我们这里可以使用动态规划解决<ul><li>建立一个数组<code>dp[ ]</code>，<code>dp[k]</code>表示由子序列中的前K个数中的漂亮子序列个数，我们考虑从k到k+1时候的变化，对于前K个中的所有漂亮子序列，新加入的第K+1个数可有可无，因为不管怎么样都是漂亮的子序列，因此这一部分产生的漂亮子序列个数为<code>2dp[k]</code> ，另一部分漂亮子序列则是由于第K+1个数的加入而产生的，这就需要前K个数中存在一个数i，这个数和第K+1个数的差的绝对值不超过m，此时产生的新的漂亮子序列的个数等于前i个数产生的不漂亮子序列的个数</li><li>所以这个题目的状态转移方程为$dp[k+1]=dp[k]+\sum\limits_{j&lt;=k,|a[j]-a[k]|\le m} (2^{j-1}+dp[j-1]-dp[j])$ 此时的时间复杂度是$O(N^2)$</li></ul></li></ul><h3 id="4-4-Project-4：Huffman-Code"><a href="#4-4-Project-4：Huffman-Code" class="headerlink" title="4.4 Project 4：Huffman Code"></a>4.4 Project 4：Huffman Code</h3><ul><li>主要是模拟哈夫曼树来进行哈夫曼编码的正确性校验，好像也没什么东西，因为哈夫曼编码是PPT上的内容，主要要记住一点就是哈夫曼编码的各个编码之间<strong>不能存在两个有前缀关系</strong> </li></ul><h3 id="4-5-Project-5：Bin-Pack"><a href="#4-5-Project-5：Bin-Pack" class="headerlink" title="4.5 Project 5：Bin Pack"></a>4.5 Project 5：Bin Pack</h3><ul><li>二维装箱问题，是一维的装箱问题的二位拓展，需要考虑箱子的长宽和物品的长宽</li><li>First-Fit 算法<ul><li>先将物体按照高度排序，然后从底部开始，按照高度从大到小遍历所有物体，找到第一个可以放得下的位置把物体放进去</li><li>排序消耗的时间复杂度是$O(N\log N)$ 装箱的时间复杂度是$O(N^2)$ </li><li>逼近率约为2.7，是一个不太好的数字</li></ul></li></ul><h3 id="4-6-Project6：Skip-List"><a href="#4-6-Project6：Skip-List" class="headerlink" title="4.6 Project6：Skip List"></a>4.6 Project6：Skip List</h3><ul><li><p>主要是引入了一种叫做跳表的数据结构，采用随机算法来降低时间复杂度，本质上是用时间来换空间</p></li><li><p>跳表的性质如下</p><ul><li>一个跳表有多个层级(level)，每一层都是一个普通的链表，第一层包含全部节点</li><li>每上一层会有<strong>一定概率保留上一层的部分节点</strong>，直到最高的一层只剩下一个</li><li>每一层中的节点按照递增顺序排序</li><li>在代码实现中就会给每个节点有多个next指针(按照层数构成一个数组)，代码实现应该如下</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> key<span class="token punctuation">;</span>SNode <span class="token operator">*</span>forword<span class="token punctuation">[</span>MAXN_LEVEL<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">SkipList</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> nowLevel<span class="token punctuation">;</span>SNode <span class="token operator">*</span>head<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>level的期望值是$O(\log N)$级别的，空间复杂度依然是$O(N)$级别</p></li><li><p>由于随机算法的加持，跳表的查询，插入，删除的平均时间复杂度都是$O(\log N)$ 但是最坏的时间复杂度依然是线性级别的</p></li></ul><h3 id="4-7-Project-7：MapReduce"><a href="#4-7-Project-7：MapReduce" class="headerlink" title="4.7 Project 7：MapReduce"></a>4.7 Project 7：MapReduce</h3><ul><li>主要介绍了一种并行算法的框架也就是MapReduce，核心步骤分为map和reduce两个部分，其中map是并行地对大规模的数据进行处理，reduce是将处理的结果进行合并</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统整理</title>
      <link href="2021/05/03/dbs/"/>
      <url>2021/05/03/dbs/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库系统复习整理"><a href="#数据库系统复习整理" class="headerlink" title="数据库系统复习整理"></a>数据库系统复习整理</h1><h4 id="RandomStar"><a href="#RandomStar" class="headerlink" title="RandomStar"></a>RandomStar</h4><h2 id="第一部分：基本概念和关系代数"><a href="#第一部分：基本概念和关系代数" class="headerlink" title="第一部分：基本概念和关系代数"></a>第一部分：基本概念和关系代数</h2><h3 id="1-0-课程绪论"><a href="#1-0-课程绪论" class="headerlink" title="1.0 课程绪论"></a>1.0 课程绪论</h3><ul><li>Nothing important，主要是介绍课程的评分标准和瞎吹一通</li></ul><h3 id="1-1-关系型数据库-Relational-Database"><a href="#1-1-关系型数据库-Relational-Database" class="headerlink" title="1.1 关系型数据库 Relational Database"></a>1.1 关系型数据库 Relational Database</h3><h4 id="关系型数据的一些基本特点"><a href="#关系型数据的一些基本特点" class="headerlink" title="关系型数据的一些基本特点"></a>关系型数据的一些基本特点</h4><ul><li>关系型数据库是一系列<strong>表的集合</strong> </li><li>一张表是一个基本单位</li><li>表中的一行表示一条关系</li></ul><h3 id="1-2-基本概念和结构"><a href="#1-2-基本概念和结构" class="headerlink" title="1.2  基本概念和结构"></a>1.2  基本概念和结构</h3><ul><li>a relation r is a subset of $D_{1}\times D_{2}\times …\times D_{n}$，一条relation就是其中的一个n元的<strong>元组(tuple)</strong> </li><li>attribute属性，指表中的<strong>列名</strong>  <ul><li>attribution type 属性的类型</li><li>attribute value 属性值，某个属性在某条relation中的值<ul><li>关系型数据库中的属性值必须要是atomic的，即不可分割的</li><li>domain：属性值的值域，null是所有属性的domain中都有的元素，但是null值会造成一些问题</li></ul></li></ul></li><li>Relation Schema 关系模式<ul><li>$R=(A_{1},A_{2},…,A_{n})$ 其中$A_i$是一系列属性，关系模式是对关系的一种<strong>抽象</strong> </li><li>r(R)表示关系模式R中的一种关系，table表示这个关系当前的值(关系实例)<ul><li>每个关系r中的元素是table中的一行</li><li>不过经常用相同的名字命名关系模式和关系</li></ul></li><li>关系是<strong>无序</strong>的，关系中行和列的顺序是irrelevant的</li></ul></li></ul><h3 id="1-3-Keys键"><a href="#1-3-Keys键" class="headerlink" title="1.3 Keys键"></a>1.3 Keys键</h3><ul><li>super key超键：能够<strong>唯一标识</strong>元组的属性集，即对于每一条关系而言超键的值是唯一的<ul><li>超键可以是多个属性的组合</li><li>如果A是关系R的一个超键，那么(A, B)也是关系R的一个超键</li><li>超键的“唯一标识”各个元组是可以有冗余信息的</li></ul></li><li>candidate key候选键：<strong>不含多余属性</strong>的超键<ul><li>如果K是R的一个超键，而任何K的真子集不是R的一个超键，那么K就是R的一个候选键</li></ul></li><li>primary key主键：<ul><li>数据库管理员<strong>指定</strong>的元组标识的一个候选键，不能是null值</li></ul></li><li>foreign key外键：用来描述两个表之间的关系，可以有空值<ul><li>如果关系模式R1中的一个属性是另一个关系模式R2中的一个<strong>主键</strong>，那么这个属性就是R1的一个外键<ul><li>a foreign key from r1 referencing r2</li></ul></li></ul></li></ul><h3 id="1-4-Relational-algebra关系代数"><a href="#1-4-Relational-algebra关系代数" class="headerlink" title="1.4 Relational algebra关系代数"></a>1.4 Relational algebra关系代数</h3><ul><li>Select 选择：$\sigma_{p}(r)={t|t\in r \cap p(t) }$ <ul><li>筛选出所有满足条件p(t)的元素t</li></ul></li><li>Project投影：$\prod_{A_1,A_2,\cdots,A_k}(r)$<ul><li>运算的结果是原来的关系r中各列只保留属性$A_1,A_2,\dots,A_k$ 后的关系</li><li>会<strong>自动去掉重复</strong>的元素，因为可能投影的时候舍弃的属性是可以标识关系唯一性的属性</li></ul></li><li>Union 并操作：$r \cup s={t|t\in r \cup t \in s}$  <ul><li>两个关系的属性个数必须相同</li><li>各属性的domain必须是可以比较大小的</li></ul></li><li>Set difference 差操作：$r-s={t| t\in r \cap t \notin s}$ </li><li>Cartesian-Product笛卡尔积：$r\times s={tq| t\in r\cap q\in s}$ <ul><li>两个关系必须是不相交的，如果相交则需要对结果中重复的属性名进行重命名</li><li>笛卡儿积运算的结果关系中元组的个数应该是rs的个数之乘积</li></ul></li><li>Renaming重命名：$\rho_{X}(E)$ <ul><li>将E重命名为x, 让一个关系拥有多个别名，同时X可以写为$X(A_1,A_2,\dots,A_n)$ 表示对属性也进行重命名</li><li>类似于C++中的引用</li></ul></li><li>扩展运算: 可以用前面的六种基本运算得到<ul><li>Intersection 交运算$r \cap s={t|t\in r \cap t \in s}=r-(r-s)$   </li><li>Natual-Join 自然连接：$r\Join s$ <ul><li>两个关系中同名属性在自然连接的时候当作<strong>同一个属性</strong>来处理</li><li><strong>Theta join</strong> 满足某种条件的合并：$r\Join_{\theta} s=\sigma_{\theta}(r\Join s)$  </li></ul></li><li>Outer-Join外部连接，分为左外连接，右外连接，全外连接<ul><li>用于应对一些<strong>信息缺失</strong>的情况(有null值)</li><li>左外连接$\ltimes $ <ul><li>左边的表取全部值按照关系和右边连接，右边不存在时为空值 </li></ul></li><li>右外连接$\rtimes $ <ul><li>右边的表取全部值按照关系和右边连接，不存在为空值</li></ul></li><li>Full join左右全上，不存在对应的就写成空值</li></ul></li><li>Division除法：$r\div s={t|t\in\prod_{R-S}(r)\cap \forall u \in s (tu\in r)}$<ul><li>如果$R=(A_1,A_2,\dots,A_m,B_1,\dots,B_n)\cap S=(B_1,\dots,B_n)$ 则有$R- S=(A_1,A_2,\dots,A_m)$ </li></ul></li><li>Assignment声明操作，类似于变量命名用$\leftarrow$  可以把一个关系代数操作进行命名 </li></ul></li><li>Aggregation operations聚合操作<ul><li>基本形式：$<em>{G_1,G_2,\dots,G_n}{\cal {G}}</em>{F_1(A_1),\dots,F_n(A_n)}(E)$ </li><li>G是聚合的标准，对于关系中所有G值相同的元素进行聚合，F( )是聚合的运算函数</li><li>常见的有SUM/MAX/MIN/AVG/COUNT</li></ul></li></ul><h2 id="第二部分：SQL"><a href="#第二部分：SQL" class="headerlink" title="第二部分：SQL"></a>第二部分：SQL</h2><h3 id="2-1-SQL基本概念"><a href="#2-1-SQL基本概念" class="headerlink" title="2.1 SQL基本概念"></a>2.1 SQL基本概念</h3><ul><li><strong>SQL：结构化查询语言</strong>，分为DDL,DML,DCL几种类型，用的比较多的标准是SQL-92</li><li><strong>非过程式的语言</strong> </li></ul><h3 id="2-2-SQL-创建，更新，删除"><a href="#2-2-SQL-创建，更新，删除" class="headerlink" title="2.2 SQL 创建，更新，删除"></a>2.2 SQL 创建，更新，删除</h3><ul><li><p>SQL支持的数据类型</p><ul><li>char, varchar, int, numeric(p,d), null-value,  date, time, timestamp</li><li>所有的数据类型都支持null作为属性值，可以在定义的时候声明一个属性的值not null</li></ul></li><li><p>创建数据表create table</p><ul><li>创建表的语法<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> table_name<span class="token punctuation">(</span>variable_name1 type_name1<span class="token punctuation">,</span>variable_name2 type_name2<span class="token punctuation">,</span>    <span class="token punctuation">(</span>integrity<span class="token operator">-</span>contraints<span class="token punctuation">)</span>……<span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>integrity-contraint</code> 完整性约束：可以<strong>指定primary key</strong>, <strong>foreign key references xxx, not null</strong></li></ul></li><li><p>删除数据表 <code>drop table</code> </p></li><li><p>更新数据表的栏目 <code>alter table</code> </p><ul><li><code>alter table R add A D</code>  添加一条新属性<ul><li>其中A是属性名，D是A的domain</li></ul></li><li><code>alter table R drop A</code>  删除A属性</li></ul></li></ul><h3 id="2-3-SQL查询"><a href="#2-3-SQL查询" class="headerlink" title="2.3 SQL查询"></a>2.3 SQL查询</h3><ul><li><p>事实上的最重要SQL语句，考试考的一般都是查询语句</p></li><li><p>SQL查询的基本形式：select语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> A1<span class="token punctuation">,</span>A2<span class="token punctuation">,</span>…<span class="token punctuation">,</span>An<span class="token keyword">from</span> r1<span class="token punctuation">,</span>r2<span class="token punctuation">,</span>…<span class="token punctuation">,</span>rn<span class="token keyword">where</span> P<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>上述查询等价于$\prod_{A_1,A_2,\cdots,A_k}(\sigma_{p}(r_1\times r_2\times \dots\times r_m))$ </li><li>SQL查询的结果是一个关系</li></ul></li><li><p>select子句的一些<strong>细节</strong> </p><ul><li><p><code>select * from xxx</code> 表示获取<strong>所有属性</strong>，事实上我怀疑*是正则表达式，表示可能有的所有内容，从后面的内容来看，select语句确实是支持正则表达式</p></li><li><p>SQL中的<strong>保留字</strong>对于<strong>大小写不敏感</strong> </p></li><li><p>去除重复：<code>select distinct</code>，防止重复丢失的办法<code>select all</code></p></li><li><p>select子句中的表达式支持基本的<strong>四则运算</strong>(加减乘除)，比如</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select ID, name, salary&#x2F;2from instructor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>where子句中：</p><ul><li>支持<code>and or not</code>等逻辑运算</li><li>支持<code>between and</code>来查询范围</li></ul></li><li><p>from 子句：</p><ul><li>重命名操作，可以通过 <code>old_name as new_name</code>进行重命名</li><li>from 可以选择多个表，此时会先将这些表进行笛卡儿积的运算，再进行select</li><li>元组变量：可以从多个表中select满足一定条件的几个不同属性值的元组</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> instructor<span class="token punctuation">.</span>name <span class="token keyword">as</span> teacher<span class="token operator">-</span>name<span class="token punctuation">,</span> course<span class="token punctuation">.</span>title <span class="token keyword">as</span> course<span class="token operator">-</span>title<span class="token keyword">from</span> instructor<span class="token punctuation">,</span> teaches<span class="token punctuation">,</span> course<span class="token keyword">where</span> instructor<span class="token punctuation">.</span>ID <span class="token operator">=</span> teaches<span class="token punctuation">.</span>ID <span class="token operator">and</span>teaches<span class="token punctuation">.</span>course_id <span class="token operator">=</span> course<span class="token punctuation">.</span>course_id <span class="token operator">and</span>instructor<span class="token punctuation">.</span>dept_name <span class="token operator">=</span> <span class="token string">'Art'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串支持<strong>正则表达式</strong>匹配，用<code>like regrex</code>的方式可以进行属性值的正则表达式匹配</p><ul><li>正则表达式的用法没怎么讲</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> name <span class="token keyword">from</span> teacher<span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%hihci%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>将输出的结果排序</p><ul><li><code>order by 属性名 asc/desc</code> </li></ul></li><li><p>集合操作：</p><ul><li>可以用<code>union/intersect/except</code>等集合运算来<strong>连接两条不同的查询</strong></li></ul></li><li><p>聚合操作：</p><ul><li>支持的操作有avg/min/max/sum/count，获取的是表中的统计量</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> dept_name<span class="token punctuation">,</span><span class="token function">avg</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">as</span> avg_salary<span class="token keyword">from</span> instructor<span class="token keyword">group</span> <span class="token keyword">by</span> dept_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>事实上SQL语句的聚合操作和关系代数中的聚合运算是完全对应的，关系代数中的聚合运算表达式$<em>{G_1,G_2,\dots,G_n}{\cal G}</em>{F_1(A_1),\dots,F_n(A_n)}(E)$对应的SQL语句是</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> G1<span class="token punctuation">,</span>G2<span class="token punctuation">,</span>…<span class="token punctuation">,</span>Gn<span class="token punctuation">,</span>F1<span class="token punctuation">(</span>A1<span class="token punctuation">)</span><span class="token punctuation">,</span>…<span class="token punctuation">,</span>Fn<span class="token punctuation">(</span>An<span class="token punctuation">)</span><span class="token keyword">from</span> E<span class="token keyword">group</span> <span class="token keyword">by</span> G1<span class="token punctuation">,</span>G2<span class="token punctuation">,</span>…<span class="token punctuation">,</span>Gn<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>聚合操作的SQL语句书写可以在末尾用<code>having xxx</code>来表示一些需要聚合操作来获得的条件，比如</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> cno<span class="token keyword">from</span> pos <span class="token keyword">natural</span> <span class="token keyword">join</span> detail<span class="token keyword">where</span> <span class="token keyword">year</span><span class="token punctuation">(</span>detail<span class="token punctuation">.</span>cdate<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2018</span><span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> campus<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Null values 空值</p><ul><li>属性值可以为null，当然也可以在定义数据表的时候规定哪些元素不能为空</li></ul></li></ul></li><li><p>Nested Subquery 嵌套查询</p><ul><li><p>对于查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> A1<span class="token punctuation">,</span>A2<span class="token punctuation">,</span>…<span class="token punctuation">,</span>An<span class="token keyword">from</span> r1<span class="token punctuation">,</span>r2<span class="token punctuation">,</span>…<span class="token punctuation">,</span>rn<span class="token keyword">where</span> P<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中的A，r，P都可以被替换为一个<strong>子查询</strong> </p></li><li><p>集合关系：用 <code>in/not in +子查询</code>来判断否些属性是否属于特定的集合中</p><ul><li><code>some+子查询</code> 用于判断集合中是否存在满足条件的元组，用来判断存在性</li><li><code>all+子查询</code> 可以用来筛选最值</li><li><code>exists+子查询</code> 判断子查询的结果是否不为空</li><li><code>not exists+子查询</code> 判断是否为空集</li></ul></li><li><p>with子句：对子查询定义一个变量名，可以在之后调用</p></li><li><p>scalar子查询：用于需要一个值作为查询结果的时候</p></li><li><p>join子句：可以对若干张表进行各种join之后再查询</p><ul><li><code>natural join</code> 自然连接</li><li><code>A join B on(xxx)</code> </li></ul></li></ul></li></ul><h3 id="2-4-SQL插入，删除，更新"><a href="#2-4-SQL插入，删除，更新" class="headerlink" title="2.4 SQL插入，删除，更新"></a>2.4 SQL插入，删除，更新</h3><ul><li><p>插入: <code>insert into table_name values( );</code></p><ul><li>可以用select查询子句得到的结果作为values，此时可以同时插入多条结果</li></ul></li><li><p>删除：<code>delete from table_name where xxxxxx</code></p></li><li><p>更新：<code>update table_name set xxx where xxxxx</code></p><ul><li>case 子句：用于分类讨论</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> instructor<span class="token keyword">set</span> salary <span class="token operator">=</span> <span class="token keyword">case</span><span class="token keyword">when</span> salary <span class="token operator">&lt;=</span> <span class="token number">100000</span> <span class="token keyword">then</span> salary<span class="token operator">*</span><span class="token number">1.05</span><span class="token keyword">else</span> salary <span class="token operator">*</span><span class="token number">1.03</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2-5-SQL-view-视图-index-索引"><a href="#2-5-SQL-view-视图-index-索引" class="headerlink" title="2.5 SQL view 视图, index 索引"></a>2.5 SQL view 视图, index 索引</h3><ul><li><p>视图：一种<strong>只显示数据表中部分属性值</strong>的机制</p><ul><li>不会在数据库中重新定义一张新的表，而是隐藏了一些数据</li><li>创建视图的定义语句：<ul><li>xxx是视图的名称，内容是从某个table中select出的</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">view</span> xxx <span class="token keyword">as</span> <span class="token punctuation">(</span>a subquery<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>视图的更新</p><ul><li>也需要使用insert语句更新视图</li><li>可以更新的条件<ul><li>创建时只使用了一张表的数据</li><li>创建时没有进行distinct和聚合操作</li><li>没有出现空值和default</li></ul></li></ul></li><li><p>Domain创建新类型</p><ul><li><p> <code>create domain new_name + data type</code>(比如 char(20))</p></li><li><p>domain可以设置约束条件，比如下面这一段domain定义表示degree_level只能在这三个中进行选择</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> domain degree_level varvhar<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">constraint</span> degree_level_test<span class="token keyword">check</span><span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'Bachelors'</span><span class="token punctuation">,</span> <span class="token string">'Masters'</span><span class="token punctuation">,</span> <span class="token string">'Doctorate'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Large-Object Types 大对象类型，分为blob(二进制大对象)和clob(文本大对象)两种，当查询需要返回大对象类型的时候，取而代之的是一个代表大对象的指针</p></li></ul></li><li><p>Index索引</p><ul><li>语法<code>create index index_name on table_name(attribute)</code></li><li>在对应的表和属性中建立索引，加快查询的速度</li></ul></li><li><p>Transactions 事务</p><ul><li>一系列查询等操作的集合</li><li>Atomic transaction 原子事务：只能被完全执行或者回滚(roll back)</li></ul></li></ul><h3 id="2-6-Integrity-完整性控制"><a href="#2-6-Integrity-完整性控制" class="headerlink" title="2.6 Integrity 完整性控制"></a>2.6 Integrity 完整性控制</h3><ul><li>单个关系上的约束<ul><li>主键 primary key， <strong>unique</strong>， not null</li><li>check子句：写在数据表的定义中<ul><li>check(P) 检查某个属性是否为特定的一些值</li></ul></li><li>Domain constraints 值域的约束<ul><li>在domain的定义中加入check</li><li>语法 <code>create domain domain_name constraints check_name check(P)</code></li></ul></li><li><strong>Referential Integrity</strong> 引用完整性<ul><li>被引用表中主键和外键的关系</li><li>其实PPT里这一段讲了半天就是在说要在定义表的时候定义主键和外键进行约束</li></ul></li><li>Cascading action(不知道这一段在讲什么狗屁)<ul><li>on update</li><li>on delete</li></ul></li></ul></li><li>对于整个数据库的约束<ul><li><p>Assertions(Mysql不支持)</p><ul><li><p>对于数据库中需要满足的关系的一种<strong>预先判断</strong> </p></li><li><p><code>create assertion &lt;assertion-name&gt; check &lt;predicate&gt;</code> 下面是一段例子</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> assertion credits_constaint <span class="token keyword">check</span>   <span class="token punctuation">(</span> <span class="token operator">not</span> <span class="token keyword">exists</span><span class="token punctuation">(</span>  <span class="token keyword">select</span> <span class="token operator">*</span>       <span class="token keyword">from</span> student S  <span class="token keyword">where</span> total_cred <span class="token operator">&lt;></span><span class="token punctuation">(</span>       <span class="token keyword">select</span> <span class="token function">sum</span><span class="token punctuation">(</span>credits<span class="token punctuation">)</span>       <span class="token keyword">from</span> takes nature <span class="token keyword">join</span> course       <span class="token keyword">where</span> takes<span class="token punctuation">.</span>ID <span class="token operator">=</span> S<span class="token punctuation">.</span>ID <span class="token operator">and</span> grade <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token operator">and</span> grade <span class="token operator">&lt;></span> <span class="token string">'F'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   )<br>   )<br>)</p><pre class="line-numbers language-none"><code class="language-none">- Trigger触发器  - 在修改了数据库时会自动执行的一些语句  - 时间节点的选择    - **referencing old row as** 对旧的行进行操作，用于删除和更新    - **referencing new row as** 对新的行进行操作，用于插入和更新  - trigger event触发事件      - insert&#x2F;delete&#x2F;update等操作都可以触发设置好的trigger    - 触发的时间点可以是before和after，触发器的语法如下      &#96;&#96;&#96;sql    create trigger trigger_name before&#x2F;after trigger_event of table_name on attribute    referencing xxx    for each row    when xxxx    begin     xxxx(SQL operation)    end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li></ul><h3 id="2-7-Authorization"><a href="#2-7-Authorization" class="headerlink" title="2.7 Authorization"></a>2.7 Authorization</h3><ul><li>数据库中的四种权限 read,insert,update,delete</li><li>Security specification in SQL 安全规范<ul><li>grant语句可以赋予用户权限 <code>grant &lt;privilege list&gt; on &lt;relation name or view name&gt; to &lt;user list&gt;</code></li><li><code>&lt;user list&gt;</code>可以是用户名，也可以是public(允许所有有效用户拥有这项权限)</li><li>grant语句后面可以加<code>with grant option</code>，表示该用户拥有赋予其他用户这项权限的权力</li><li>revoke 权力回收<ul><li><code>revoke &lt;privilege list&gt; on &lt;relation/view name&gt; from &lt;user list&gt; [restrict|cascade]</code>从用户中回收权力</li></ul></li><li>role语句<ul><li><code>create role role_name</code></li><li>允许一类用户持有相同的权限</li></ul></li></ul></li></ul><h2 id="第三部分：ER模型和Normal-Form-范式"><a href="#第三部分：ER模型和Normal-Form-范式" class="headerlink" title="第三部分：ER模型和Normal Form(范式)"></a>第三部分：ER模型和Normal Form(范式)</h2><h3 id="3-1-E-R模型"><a href="#3-1-E-R模型" class="headerlink" title="3.1 E-R模型"></a>3.1 E-R模型</h3><ul><li><p>E-R模型由enitites(实体)和relation(关系)组成</p></li><li><p>Entity set 实体集</p><ul><li><p>实体是一系列独特的对象，用一系列属性来表示</p></li><li><p>同一类实体共享相同的Properties，实体集就是由同类型的实体组成的集合</p></li><li><p>表示方法</p><ul><li>长方形代表实体集合</li><li>属性写在长方形中，<strong>primary key用下划线</strong>标注 </li></ul></li><li><p>实体集中对于属性的定义和之前的几乎一样</p><ul><li><p>实体集中属性定义可以存在组合与继承的关系，下面是一个样例</p><blockquote><p>Instructor</p><p><u>ID</u> </p><p>name</p><p>​    first_name</p><p>​    last_name</p><p>address</p><p>​    street</p><p>​        street_number</p><p>​        street_name</p><p>​        apt_number</p><p>​    city</p><p>​    state</p></blockquote></li></ul></li></ul></li><li><p>Relationship set 关系集</p><ul><li>一个relationship是几个实体之间的联系，关系集就是同类关系之间构成的集合</li><li>一个relationship至少需要两个及以上的实体，一个关系集至少和两个实体集有关联<ul><li>一个关系集所关联的实体集的个数称为degree，其中以二元关系集为主</li></ul></li></ul></li><li><p>E-R model constraints 约束</p><ul><li>mapping cardinalities <strong>映射基数</strong> <ul><li>二元关系中映射基数只有一对一，一对多，多对一，多对多</li><li>E-R模型中表示映射关系：箭头表示一，直线表示多</li><li>三元关系中：<strong>箭头只能出现一次</strong>，否则会出现<strong>二义性</strong> </li></ul></li><li>参与度约束<ul><li>total participation： 若一个实体集全部参与到关系中，要用两条线</li><li>partical participation 部分参与</li></ul></li><li>key约束：和前面的基本一样</li><li>弱实体集weak entity set：一些实体集的属性不足以形成主键，就是弱实体集，与之相对的是强实体集<ul><li>用于表示一些关系中的依赖性，弱实体集需要和强实体集关联才有意义</li><li>经常出现在一对多的关系中，在ER图中需要用<strong>双线方框</strong>表示，比如职工和职工家属，职工家属不能脱离于职工存在，所以职工家属就是一个弱实体集</li></ul></li></ul></li><li><p>Aggregation 聚合</p><ul><li>可以把一部分E-R关系聚合成一个Entity进行操作</li><li>在ER图中用方框将一些关系集和实体集括起来表示一个聚合后的实体集</li></ul></li><li><p>Specialization 特殊化</p><ul><li>自顶向下的设计过程</li><li>Attribute inheritance：overlapping，disjoint</li><li>画图的方式就是从上往下画，Entity的内容逐渐细分，但是都继承了上一阶的所有attribute</li></ul></li><li><p>Generalization 泛化</p><ul><li>自底向上的设计过程</li><li>从下往上，下层的内容合成上层的内容</li></ul></li></ul><h3 id="3-2-E-R-Diagram"><a href="#3-2-E-R-Diagram" class="headerlink" title="3.2 E-R Diagram"></a>3.2 E-R Diagram</h3><ul><li>E-R图中的各种表述</li></ul><h3 id="3-3-Normal-Form-范式"><a href="#3-3-Normal-Form-范式" class="headerlink" title="3.3 Normal Form 范式"></a>3.3 Normal Form 范式</h3><h4 id="3-3-1-数据库设计的目标"><a href="#3-3-1-数据库设计的目标" class="headerlink" title="3.3.1 数据库设计的目标"></a>3.3.1 数据库设计的目标</h4><ul><li>存储信息时没有不必要的冗余，检索信息的效率高</li><li>这些设计方式通过各种范式(normal form)来实现</li></ul><h4 id="3-3-2-First-Normal-Form-第一范式"><a href="#3-3-2-First-Normal-Form-第一范式" class="headerlink" title="3.3.2 First Normal Form 第一范式"></a>3.3.2 First Normal Form 第一范式</h4><ul><li><p>原子性atomic ：不能再继续拆分，属性不能再向下拆分</p></li><li><p>第一范式的定义：一个关系模式R的<strong>所有属性都是atomic的</strong>，这个关系模式R就是<strong>第一范式</strong> </p></li><li><p>存在的问题</p><ul><li>redundancy 冗余</li><li>complicates updates 更新数据很复杂</li><li>null-values—difficult to insert/remove</li></ul></li><li><p>Decomposition 分解</p><ul><li>Lossy Decomposition 有损的分解：不能用分解后的几个关系重建原本的关系</li><li>Lossless join 无损分解的定义：<ul><li>R 被分解为(R1, R2)并且$R=R_1\cup R_2$  </li><li>对于任何关系模式R上的关系r有 $r=\prod_{R_1}(r)\Join \prod_{R_2}(r)$</li></ul></li></ul></li></ul><h4 id="3-3-3-Functional-dependency-函数依赖"><a href="#3-3-3-Functional-dependency-函数依赖" class="headerlink" title="3.3.3 Functional dependency 函数依赖"></a>3.3.3 Functional dependency 函数依赖</h4><ul><li><strong>函数依赖</strong>的定义<ul><li>对于一个关系模式E，如果$\alpha \subset R$ 并且$\beta\subset R$ 则函数依赖$\alpha \rightarrow\beta$ 定义在R上，当且仅当<ul><li>如果对于R的任意关系r(R)  当其中的任意两个元组t1和t2，如果他们的$\alpha$属性值相同可以推出他们的$\beta$属性值也相同</li></ul></li><li>如果某个属性集A可以决定另一个属性集B的值，就称$A\rightarrow B$是一个函数依赖</li><li>函数依赖和键的关系：函数依赖实际上是键的概念的一种泛化<ul><li>K是关系模式R的<strong>超键</strong>当且仅当 $K\rightarrow R$ </li><li>K 是R上的<strong>候选主键</strong>当且仅当 $K\rightarrow R$ 并且不存在 $\alpha\sub K, \alpha\rightarrow R$ </li></ul></li><li>一个平凡的的结论：子集一定对自己函数依赖</li></ul></li></ul><h4 id="3-3-4-闭包"><a href="#3-3-4-闭包" class="headerlink" title="3.3.4 闭包"></a>3.3.4 闭包</h4><ul><li><p>Closure 闭包</p><ul><li><p>闭包, 对于原始的函数依赖集合F可以推出的所有函数依赖关系产生的集合就是<strong>F的闭包</strong> </p></li><li><p>符号用$F^+$表示</p></li><li><p>函数依赖的性质</p><ul><li>reflexity：$\alpha$的子集一定关于$\alpha$函数依赖</li><li>augmentation：如果$\alpha\rightarrow \beta$ 则有$\lambda\alpha\rightarrow \lambda\beta$ </li><li>transitivity：如果$a\rightarrow \beta \cap \beta\rightarrow\gamma$ 则有$a\rightarrow \gamma$ </li><li>union：如果$\alpha\rightarrow \beta\cap \alpha\rightarrow \gamma$ 则有$\alpha \rightarrow \beta\gamma$ </li><li>decomposition：如果$\alpha \rightarrow \beta\gamma$ 则有$\alpha\rightarrow \beta\cap \alpha\rightarrow \gamma$ </li><li>pseudotransitivity：如果$\alpha\rightarrow \beta\cap \beta\gamma\rightarrow \delta$ 则有$\gamma\alpha\rightarrow\delta$  </li></ul></li><li><p>计算闭包的方法</p><ul><li>根据初始的函数依赖关系集合F和函数依赖的性质，计算出所有的函数依赖构成闭包</li><li>可以用有向图表示属性之间的关系，通过图来写出所有的函数依赖</li></ul></li><li><p>属性集的闭包</p><ul><li>闭包中所有关于$\alpha$函数依赖的属性集构成的集合<ul><li>即如果$(\alpha\rightarrow \beta)\in F^+$则有$\beta\in\alpha^{+}$ </li></ul></li><li>计算<strong>属性集闭包</strong>的算法</li></ul><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">result&#x3D;&#123;a&#125;while result is changed dofor each b-&gt;c in F dobeginif b is in result then push c into resultend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>属性集闭包的作用<ul><li>测试是否为主键：如果$\alpha$的闭包包含了所有属性，则α就是主键</li><li>测试函数独立：为了验证$\alpha\rightarrow \beta$是否存在只需要验证β是否在α的闭包中</li><li>计算$F^+$：通过每个属性的闭包可以得到整个关系模式的闭包</li></ul></li></ul></li><li><p>判定是否为Lossless Join的办法</p><ul><li>当且仅当$R_1\cap R_2\rightarrow R_1$ 或者$R_1\cap R_2\rightarrow R_2$至少有一个$F^+$中</li></ul></li></ul></li></ul><h4 id="3-3-5-BCNF-3NF"><a href="#3-3-5-BCNF-3NF" class="headerlink" title="3.3.5 BCNF/3NF"></a>3.3.5 BCNF/3NF</h4><ul><li><p>BC 范式(Boyee-Codd Normal Form) </p><ul><li>BC范式的条件是：闭包$F^+$中的所有函数依赖$\alpha \rightarrow \beta$ 至少满足下面的一条<ul><li>$\alpha \rightarrow \beta$ 是平凡的(也就是β是α的子集)</li><li>α是关系模式R的一个<strong>超键</strong>，即$\alpha \rightarrow R$ </li></ul></li><li>如何验证BCNF：<ul><li>检测一个非平凡的函数依赖$\alpha\rightarrow\beta$是否违背了BCNF的原则<ul><li>计算α的属性闭包</li><li>如果这个属性闭包包含了所有的元素，那么α就是一个<strong>超键</strong> </li><li>如果α不是超键而这个函数依赖又不平凡，就打破了BCNF的原则</li></ul></li><li>简化的检测方法：<ul><li>只需要看关系模式R和已经给定的函数依赖集合<strong>F中的各个函数依赖</strong>是否满足BCNF的原则<ul><li>不需要检查F闭包中所有的函数独立</li></ul></li><li>可以证明如果F中没有违背BCNF原则的函数依赖，那么F的闭包中也没有</li><li>这个方法不能用于检测R的分解</li></ul></li></ul></li><li>BC范式的分解算法伪代码</li></ul><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">result&#x3D;&#123;R&#125;done&#x3D;falsecompute F+ by Fwhile (!done) doif exist Ri in result that is not a BCNFthen beginlet a-&gt;b be a non-trivial function dependency that holds on Ri such that a-&gt;Ri is not in F+ and (a and b)&#x3D;empty setresult&#x3D;(result-Ri)or(Ri-b)or(a,b);endelsedone&#x3D;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>当我们对关系模式R进行分解的时候，我们的目标是</p><ul><li><p>没有冗余，每个关系都是一个good form</p></li><li><p>无损分解</p></li><li><p>Denpendency preservation 独立性保护,把R和F的闭包按照关系的对应进行划分</p><ul><li>用$F_i$表示只包含在$R_i$中出现的元素的函数依赖构成的集合</li><li>我们希望的结果是 $(F_1\cup F_2\cup\dots\cup F_n)^+=F^+$ <ul><li>BCNF的分解一定是有独立性保护的</li></ul></li><li>独立性保护的验证算法</li><li>如果最终的结果result包含了所有属性，那么函数依赖$\alpha\rightarrow \beta$ 就是被保护的</li></ul><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">result &#x3D; αwhile result changed dofor each Ri in the compositiont &#x3D; (result and Ri)+ and Riresult &#x3D; result or t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Third normal form 第三范式</p><ul><li>第三范式的定义：对于函数依赖的闭包$F^+$中的所有函数依赖$\alpha\rightarrow\beta$ 下面三条至少满足一条<ul><li>$\alpha\rightarrow\beta$ 是平凡的</li><li>$\alpha$是关系模式R的超键</li><li>每一个$\beta-\alpha$ 中的 属性A都包含在一个R的候选主键中 </li></ul></li><li>BCNF一定是3NF，实际上3NF是为了保证独立性保护的BCNF</li><li>3NF有冗余，某些情况需要设置一些空值</li></ul></li><li><p>3NF的判定</p><ul><li>不需要判断闭包中的所有函数依赖，只需要对已有的F中的所有函数依赖进行判断</li><li>用闭包可以检查$\alpha\rightarrow \beta$中的α是不是超键</li><li>如果不是，就需要检查β中的每一个属性包含在R的候选键中</li></ul></li></ul><h4 id="3-3-6-最小覆盖"><a href="#3-3-6-最小覆盖" class="headerlink" title="3.3.6 最小覆盖"></a>3.3.6 最小覆盖</h4><ul><li><p>Canonical conver 最小覆盖问题</p><ul><li>函数依赖关系的最小集合(也就是没有冗余，和F等价可以推导出F+的关系集合)</li><li>无关属性Extraneous Attributes：<ul><li>定义：对于函数依赖集合F中的一个函数依赖$\alpha\rightarrow\beta$<ul><li>α中的属性A是多余的，如果F逻辑上可以推出$(F-{\alpha\rightarrow\beta})\cup {(\alpha-A)\rightarrow\beta}$ </li><li>β中的属性A是多余的，如果$(F-{\alpha\rightarrow\beta})\cup {\alpha\rightarrow(\beta-A)}$ 逻辑上可以推出F<ul><li>更强的函数逻辑上可以推导出更弱的函数</li></ul></li></ul></li><li>判断$\alpha\rightarrow\beta$中的一个属性是不是多余的<ul><li>测试α中的属性A是否为多余的<ul><li>计算$(\alpha-A)^+$</li><li>检查结果中是否包含β，如果有就说明A是多余的</li></ul></li><li>测试β中的属性A是否为多余的<ul><li>只用$(F-{\alpha\rightarrow\beta})\cup {\alpha\rightarrow(\beta-A)}$中优的依赖关系计算$\alpha^+$ </li><li>如果结果包含A，就说明A是多余的</li></ul></li></ul></li></ul></li><li>最小覆盖$F_c$的定义<ul><li>和F可以互相从逻辑上推导出，并且最小覆盖中没有多余的信息</li><li>最小覆盖中的每个函数依赖中左边的内容都是unique的</li><li>如何计算最小覆盖：PPT-8的53页有一个例子<ul><li>先令Fc=F</li><li>用Union rule将Fc中所有满足$\alpha\rightarrow\beta_1 \cap \alpha\rightarrow\beta_2$的函数依赖替换为$\alpha\rightarrow\beta_1\beta_2$ </li><li>找到Fc中的一个函数依赖去掉里面重复的属性</li><li>重复2，3两个步骤直到Fc不再变化</li></ul></li></ul></li></ul></li></ul><p>下面这些部分看起来不太会考，先不管了，有空再看</p><ul><li><p>3NF decomposition algorithm</p></li><li><p>Multivalued denpendency</p><ul><li>多值依赖 a-&gt;-&gt;b，记作D，闭包记为D+</li></ul></li><li><p>Fourth Normal Form</p><ul><li>对于D+中的所有a-&gt;-&gt;b有①是平凡的或者②a是一个超键</li><li>4NF一定是BCNF</li></ul></li></ul><h2 id="第四部分-数据库设计理论"><a href="#第四部分-数据库设计理论" class="headerlink" title="第四部分: 数据库设计理论"></a>第四部分: 数据库设计理论</h2><h3 id="4-1-存储和文件结构"><a href="#4-1-存储和文件结构" class="headerlink" title="4.1 存储和文件结构"></a>4.1 存储和文件结构</h3><p>这一部分好像不怎么会考试，理论性的东西比较多，跟计原的存储器部分好像还有一部分交集</p><ul><li>存储的结构 storage hierarchy<ul><li>primary主存储器<ul><li>快而易失，常见的有主存和cache</li><li>cache的存取效率最高，但是costly，主存访问快但是对于数据库而言空间太小</li></ul></li><li>secondary 二级存储器<ul><li>不容易丢失，访问较快，又叫在线存储</li><li>常见的是闪存和磁盘</li></ul></li><li>tertiary三级存储器<ul><li>不容易丢失，访问慢，但是容量大而cheap，离线存储</li><li>磁带，光存储器</li></ul></li><li>总体的存储架构：cache–主存–闪存–磁盘–光盘–磁带</li></ul></li></ul><h4 id="4-1-1-磁盘-Magnetic-Disks"><a href="#4-1-1-磁盘-Magnetic-Disks" class="headerlink" title="4.1.1 磁盘 Magnetic Disks"></a>4.1.1 磁盘 Magnetic Disks</h4><ul><li>组成结构<ul><li>read-write head 读写头<ul><li>和磁盘表面靠得很近</li><li>用于读写磁盘中的文件信息</li></ul></li><li>tracks 磁道, 由磁盘表面划分，每个硬盘大概有50k到100k个磁道<ul><li>sectors 扇区，由磁道划分而成<ul><li>扇区是数据读写的最小单位</li><li>每个扇区的大小是512字节，每个磁道有500-1000个扇区</li></ul></li></ul></li><li>磁盘控制器：计算机系统和磁盘之间的接口</li><li>Disk subsystem 磁盘子系统：由disk controller操纵若干个磁盘组成的字系统</li></ul></li><li>磁盘的性能评价标准<ul><li>access time： 访问时间，包括<ul><li>seek time：读写头的arm正确找到track的时间，平均的seek time是最坏情况的一半</li><li>rotational latency：旋转造成的延迟，平均时间是最坏的一半</li></ul></li><li>data-transfer rate 数据从磁盘读写的速度</li><li>MTTF：出现failure之前的平均运行时间</li></ul></li><li>磁盘访问的优化<ul><li>block ：一个磁道中的若干连续扇区组成的序列</li><li>buffering</li><li>read-ahead</li><li>disk-arm-scheduling</li><li>file organization:  通过按照访问数据的方式来组织block优化访问时间</li></ul></li></ul><h4 id="4-1-2-File-organization-文件组织"><a href="#4-1-2-File-organization-文件组织" class="headerlink" title="4.1.2 File organization 文件组织"></a>4.1.2 File organization 文件组织</h4><ul><li><p>数据库存储在一系列的文件中，每个文件是一系列的记录，每条记录包含一系列的fields</p><ul><li><p>每个文件被划分为固定长度的block，block是数据存取/存储空间分配的基本单位</p></li><li><p>一个block有多条记录，在传统的数据库中</p><ul><li>记录的长度不能超过block</li><li>每条记录一定都是完整的</li></ul></li><li><p>Free List 用链表的形式来存储records</p></li><li><p>Variable-length records 变长记录</p><ul><li><p>典型的变长记录</p><ul><li>属性按照顺序存储</li><li>变长的变量用offset+data的形式存储，空值用null-value bitmap存储</li></ul></li><li><p>slotted page结构，它的header包含</p><ul><li>记录的总数</li><li>block中的空闲区域的end</li><li>每条记录所在的位置和大小</li></ul><p><img src="/2021/05/03/dbs/image-20200805110144890.png" alt="image-20200805110144890"></p></li></ul></li><li><p>文件中记录的组织方式</p><ul><li>heap</li><li>sequential</li><li>hashing</li><li>nulti-table clustering file organization</li></ul></li></ul></li><li><p>存储缓冲区的管理</p><ul><li>通过将数据放到主存中来提高访问效率<ul><li>buffer manager：用于管理缓冲区中的内存分配<ul><li>当需要从磁盘读取block的时候，数据库会调用buffer mananger的功能</li><li>如果block已经在buffer中了，就直接返回这个block的地址</li><li>如果不在，则buffer manager 会动态分配buffer中的内存给block，并且可能会覆盖别的block，然后将磁盘中block中的内容写入buffer中<ul><li>涉及到buffer的替换算法LRU strategy 即替换掉最近使用频率最低的block</li></ul></li></ul></li><li>pinned block 内存中的不允许写回磁盘的block，表示正在处理事务或者处于恢复接断</li></ul></li></ul></li></ul><h3 id="4-2-B-树索引"><a href="#4-2-B-树索引" class="headerlink" title="4.2 B+树索引"></a>4.2 B+树索引</h3><h4 id="4-2-1-索引"><a href="#4-2-1-索引" class="headerlink" title="4.2.1 索引"></a>4.2.1 索引</h4><ul><li>数据库系统中引入索引机制，用于加快查询和访问需要的数据<ul><li>search key 通过一个属性值查找一系列属性值，用于文件中查询</li><li>Index file 索引文件包含一系列的search key和pointer(两者的组合被称为index entry)，查询方式是通过search key在index file中查询data的地址(pointer)，然后再从data file中查询数据<ul><li>两种search key的排序方式：ordered index，hash index</li><li>ordered index 顺序索引<ul><li>index entry按照search key的值来进行排列</li><li>primary key 指定文件顺序的索引 secondary key 次关键字</li></ul></li><li>索引的不同方式<ul><li>Dense index 密集的索引：每一条记录都有对应的索引</li><li>Sperse index 稀疏的索引<ul><li>需要的空间和插入删除新索引的开销较小，但是比密集的索引要慢</li></ul></li><li>Secondary indice索引通过一个大的bucket来寻找所指向的地方</li><li>Multilevel index 多级索引，分为outer index和inner index</li></ul></li></ul></li></ul></li></ul><h4 id="4-2-2-B-树索引"><a href="#4-2-2-B-树索引" class="headerlink" title="4.2.2 B+树索引"></a>4.2.2 B+树索引</h4><ul><li><p>B+树文件索引</p><ul><li>通过B+树的索引方式来寻找文件中数据的地址，B+树的定义和ads中的B+树基本相同，<ul><li>树的非叶节点由指向儿子的指针和search-key相间组合而成</li><li>两个search-key之间的指针指向的数据的值在这两个search-key之间</li></ul></li><li>B+树上的查询的时间复杂度是logN级别，N是search key的总个数<ul><li>查询的路径长度：不会超过$\log_{n/2}(K)$ + 1其中K是B+树中的索引的个数(即规模N)</li><li>B+树的一个节点的大小和一个磁盘区块一样大(往往是4KB)而在n的规模一般在100左右</li></ul></li></ul></li><li><p>B+树的更新：插入和删除</p><ul><li>插入的算法：先找到该插入的位置直接插入，如果当前的节点数量超过了阶数M则拆成两个部分，并向上更新索引</li><li>删除的算法: 直接把要删除的节点删除，然后把没有索引key了的非叶节点删除，从旁边找一个叶节点来合并出新的非叶节点</li></ul></li><li><p>B+树的相关计算</p><ul><li><p>高度的估计：</p><ul><li>B+树高度最小的情况：所有的叶节点都满，此时的$h = \lceil \log_{N}(M)\rceil$ </li><li>最大的情况，所有的叶节点都半满，此时的$h=\lfloor \log_{[N/2]}(\frac{M}{2})\rfloor+1$ </li></ul></li><li><p>size大小的估计：也是两种极端情况</p><p>  <img src="/2021/05/03/dbs/image-20200823175046650.png" alt="image-20200823175046650"></p></li></ul></li></ul><h4 id="4-2-3-文件索引"><a href="#4-2-3-文件索引" class="headerlink" title="4.2.3 文件索引"></a>4.2.3 文件索引</h4><ul><li>Hash文件索引<ul><li>静态哈希<ul><li>使用一系列buckets来存储一系列的records，通过hash函数和search-key的运算来查找文件</li><li>hash函数：将不同的search key映射到不同的bucket里面去</li></ul></li><li>Hash indices 将hash用于索引结构中<ul><li>A <strong>hash index</strong> organizes the search keys, with their associated record pointers, into a hash file structure.</li><li>hash indices are always secondary indices </li></ul></li><li>动态哈希<ul><li>哈希函数会被动态地修改</li><li>可扩展的哈希</li></ul></li></ul></li></ul><h4 id="4-2-4-总结：存储结构和B-树的计算"><a href="#4-2-4-总结：存储结构和B-树的计算" class="headerlink" title="4.2.4 总结：存储结构和B+树的计算"></a>4.2.4 总结：存储结构和B+树的计算</h4><ul><li>记录的存储：<ul><li>数据库的记录在block中存储，一个block中有大量的记录存储，有线性存储的，也有使用B+树索引的</li><li>线性存储的记录：<ul><li>假设一条记录的长度位L，block的大小为B，那么一条记录中最多有$\lfloor \frac{B}{L}\rfloor$ 条记录</li><li>如果一共有N条记录，一个block中有M条记录，那么一共需要$\lceil\frac{N}{M}\rceil$ 个block，而 $M=\lfloor \frac{B}{L}\rfloor$ </li></ul></li><li>B+树索引block的计算，假设block的大小为B，指针的大小是a，被索引的属性值大小是b<ul><li>要注意指针节点比属性值多一个，所以一个块上的扇出率n(fan-out rate)是$\lfloor \frac{B-a}{a+b}\rfloor+1$ </li><li>n也就是这个B+树的阶数，然后根据公式来估算B+树的高度，其中M应该是作为索引的值可以取到的个数</li></ul></li></ul></li></ul><h3 id="4-3-查询处理-QueryProcess"><a href="#4-3-查询处理-QueryProcess" class="headerlink" title="4.3 查询处理 QueryProcess"></a>4.3 查询处理 QueryProcess</h3><p>印象中这一部分的作业题以套公式算为主</p><ul><li><p>查询处理的基本步骤</p><ul><li>Parsing and translation 解析和翻译</li><li>Optimization 优化<ul><li>一种SQL查询可能对应了多种等价的关系代数表达式</li><li>可以通过估计每种方式的cost来评判方法的好坏</li><li>查询优化会选择最节约的方式进行查询</li></ul></li><li>Evaluation</li></ul></li><li><p>Query cost的计算</p><ul><li>主要的cost来源：disk access<ul><li>seeks</li><li>block read</li><li>block written</li></ul></li><li>cost计算的方式：在B个blocks中查询S次所消耗的时间=B*转移到一个block的时间+S*一次查询的时间：$B\times t_T+S\times t_S$ 其中$t_T$ 表示一次block transfer的时间<ul><li>cost依赖于主存中<strong>缓冲区的大小</strong>：更多的内存可以减少disk access</li><li>通常考虑最坏的情况：只提供最少的内存来完成查询工作</li></ul></li></ul></li></ul><h4 id="4-3-1-select的cost估计"><a href="#4-3-1-select的cost估计" class="headerlink" title="4.3.1 select的cost估计"></a>4.3.1 select的cost估计</h4><ul><li><p>Select 操作的cost计算</p><ul><li><p>Algorithm1:线性搜索，查询每个block判断是否满足查询条件</p><ul><li><p>Cost =  br block transfers + 1 seek，其中$b_r$ 是关系r中<strong>存储了记录的block的数量</strong> </p></li><li><p>如果通过键来搜索，在找到的时候就停止，则 cost = (br /2) block transfers + 1 seek</p></li><li><p>二分搜索此时不起作用，因为数据不是连续存储的</p></li></ul></li><li><p>Index scan–使用索引进行搜索</p></li><li><p>Algorithm2: primary index，equality on key，搜索一条记录</p><ul><li>$cost = (h_i+1)\times(t_T+t_S)$ — hi是索引的高度</li></ul></li><li><p>Algorithm3: primary index, equality on non-key 需要搜索多条记录</p><ul><li>想要的结果会存储在连续的block中(因为有主索引)</li></ul></li><li><p>$cost =h_i (t_T + t_S) + t_S + t_T * b$ 其中b表示包含匹配记录的block总数</p><ul><li>当使用B+树作为索引时可以节约一次seek的时间，$cost =h_i (t_T + t_S)+ t_T * b$ </li></ul></li></ul></li><li><p>算法4：Secondary index</p><ul><li><p>用候选主键作为索引检索单条记录 $cost = (h_i + 1) \times (t_T + t_S)$ </p></li><li><p>用候选主键检索了n条记录(不一定在同一个block上面)</p><p>$Cost = (h_i + n) \times (t_T + t_S)$ 有时候会非常耗时</p></li></ul></li></ul><h4 id="4-3-2-sort和join的cost估计"><a href="#4-3-2-sort和join的cost估计" class="headerlink" title="4.3.2 sort和join的cost估计"></a>4.3.2 sort和join的cost估计</h4><ul><li><p>Sort：<strong>external</strong> <strong>sort-merge</strong> 其实类似于ads里面的外部归并排序</p><ul><li>M表示内存的大小，$b_r$表示block的数量<ul><li>基本步骤如下<ul><li>create sorted runs</li><li>merge the runs</li></ul></li><li>需要的merge pass总数 $[ \log_{M-1}(b_r/M)]$ </li><li>创建和每次run过程中的disk access数量 2<em>br</em></li><li>外部排序中总的disk access次数 $(2[ \log_{M-1}(b_r/M)]+1)b_r$ </li></ul></li></ul></li><li><p>Join 操作的cost估计</p><ul><li><p>nested-loop join</p><ul><li>计算theta-join表达式：$r\Join_{\theta} s$ 算法的伪代码如下</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> each tuple tr in r <span class="token keyword">do</span> begin    <span class="token keyword">for</span> each tuple ts in s <span class="token keyword">do</span> begin        test <span class="token function">pair</span> <span class="token punctuation">(</span>tr<span class="token punctuation">,</span>ts<span class="token punctuation">)</span> to see <span class="token keyword">if</span> they satisfy the join condition        <span class="token keyword">if</span> they <span class="token keyword">do</span><span class="token punctuation">,</span> add tr • ts to the result    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>block transfer次数: $n_r\times b_s+b_r$</li><li>seeks的次数 $n_r+b_r$ </li></ul></li><li><p>block nested-loop join $r\Join_{\theta} s$  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> each block Br of r <span class="token keyword">do</span> begin    <span class="token keyword">for</span> each block Bs of s <span class="token keyword">do</span> begin        <span class="token keyword">for</span> each tuple tr in Br  <span class="token keyword">do</span> begin            <span class="token keyword">for</span> each tuple ts in Bs <span class="token keyword">do</span> beginCheck <span class="token keyword">if</span> <span class="token punctuation">(</span>tr<span class="token punctuation">,</span>ts<span class="token punctuation">)</span> satisfy the join condition <span class="token keyword">if</span> they <span class="token keyword">do</span><span class="token punctuation">,</span> add tr • ts to the result<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>最坏情况的cost<ul><li>block transfer $b_r\times b_s+b_r$</li><li>seeks $2b_r$ </li></ul></li><li>最好情况的cost<ul><li>block transfers $b_r+b_s$ with 2 seeks</li></ul></li><li>优化：使用M-2个block作为blocking unit(M是内存可以容纳的block数量)，此时的<ul><li>block transfer次数=$\frac{b_r}{M-2}\times b_s+b_r$ </li><li>seek次数= $\frac{2b_r}{M-2}$ </li></ul></li></ul></li><li><p>Index nested-loop join</p><ul><li>索引一定程度上可以代替file scan</li><li> $cost=b_r(t_T+t_s)+c\times n_r$ 其中c表示遍历索引和找到所有匹配的s中的tuple所消耗的时间，可以用<strong>一次s上的单个selection来估计s的值</strong> </li></ul></li><li><p>Merge-Join</p><ul><li>只能在natural-join和equal-join中使用</li><li>block transfer的次数=$b_r+b_s$，seek的次数=$[b_r/b_b]+[b_s/b_b]$ </li></ul></li><li><p>Hash join：使用hash函数进行join</p><ul><li><em>h</em> maps JoinAttrs values to {0, 1, …, $n_h$},  将两个关系进行比较和同类型的匹配</li><li>cost of hash-join<ul><li>block transfer: $3(b_r+b_s)+4n_h$<ul><li>partition: 读 $b_r+b_s$ blocks 写 $(b_r+b_s)+2n_h$ blocks</li><li>join: 读$(b_r+b_s)+2n_h$</li></ul></li><li>seeks: $2([b_r/b_b]+[b_s/b_b])$ </li><li>如果所有东西都能放进主存里，则$n_h=0$ 并且不需要partition</li><li>需要partition的时候 $cost=2(b_r+b_s[\log_{M-1}(b_s)-1])+b_r+b_s$ </li></ul></li></ul></li></ul></li><li><p>Evaluation of Expression 表达式求值</p><ul><li><strong>Materialization</strong> 实体化<ul><li>依次进行表达式的计算，构建前缀树递归进行</li></ul></li><li>Pipelining 流水线，同时评估多个操作<ul><li>evaluate several operations simultaneously , passing the results of one operation on to the next.</li></ul></li></ul></li></ul><h3 id="4-4-查询优化-Query-Optimization"><a href="#4-4-查询优化-Query-Optimization" class="headerlink" title="4.4 查询优化 Query Optimization"></a>4.4 查询优化 Query Optimization</h3><ul><li>两种查询优化的办法<ul><li>找到等价的查询效率最高的关系代数表达式</li><li>指定详细的策略来处理查询</li></ul></li></ul><h4 id="4-4-1-等价关系代数表达式"><a href="#4-4-1-等价关系代数表达式" class="headerlink" title="4.4.1 等价关系代数表达式"></a>4.4.1 等价关系代数表达式</h4><ul><li><p>Equivalent Expressions 等价的关系代数表达式</p><ul><li><p><strong>evaluation plan</strong>：类似于算术表达式的前缀树，表示了每部操作进行的过程</p></li><li><p>Cost-based optimization基于cost的优化</p><ul><li>基本步骤<ul><li>用运算法则找到逻辑上等价的表达式</li><li>注释结果表达式来获得查询计划</li><li>选择cost最低的表达式</li></ul></li><li>cost的估算<ul><li>统计信息量的大小，比如tuples的数量，一个属性不同取值的个数</li><li>中间结果的数量，用于复杂表达式的优化</li><li>算法的消耗</li></ul></li></ul></li><li><p><strong>等价表达式的规则</strong></p></li></ul></li><li><p>合取选择和选两次等价：$\sigma_{\theta_1\cap\theta_2}(E)=\sigma_{\theta_1}(\sigma_{\theta_2}(E))$ </p><ul><li>选择两次的顺序可以交换；$\sigma_{\theta_1}(\sigma_{\theta_2}(E))=\sigma_{\theta_2}(\sigma_{\theta_1}(E))$ </li><li>嵌套的投影只需要看最外层的：$\prod_{L_1}(\prod_{L_2}(\dots(E)))=\prod_{L_1}(E)$ </li><li>选择可以变成笛卡尔积和theta join</li><li>$\sigma_{\theta}(E_1\times E_2)=E_1\Join_{\theta}E_2$ <ul><li>$\sigma_{\theta_1}(E_1\Join_{\theta_2}E_2)=E_1\Join_{\theta_1\cap\theta_2}E_2$ </li><li>Theta-join和自然连接可以改变连接的两张表的顺序：$E_1\Join_{\theta}E_2=E_2\Join_{\theta}E_1$ </li><li>自然连接满足结合律：$(E_1\Join E_2)\Join E_3=E_1\Join (E_2\Join E_3)$ </li><li>Theta-join的结合规则</li></ul></li><li>$(E_1\Join_{\theta_1} E_2)\Join_{\theta_2\cap\theta_3} E_3=E_1\Join_{\theta_1\cap\theta_3} (E_2\Join_{\theta_2} E_3)$ <ul><li>选择操作的优化<ul><li>当$\theta_1$ 中的属性都只出现在E1中的时候：$\sigma_{\theta_1}(E_1\Join_{\theta_2}E_2)=\sigma_{\theta_1}(E_1)\Join_{\theta_2}E_2$ </li><li>当$\theta_1,\theta_2$ 分别只包含E1,E2中的属性时：$\sigma_{\theta_1\cap\theta_2}(E_1\Join_{\theta}E_2)=\sigma_{\theta_1}(E_1)\Join\sigma_{\theta_2}(E_2)$ </li></ul></li><li>投影操作和Theta-join的混合运算</li></ul></li><li>当θ只包含$L_1\cup L_2$ 中的属性的时候：$\prod_{L_1\cup L_2}(E_1\Join_{\theta}E_2)=(\prod_{L_1}(E_1))\Join_{\theta}(\prod_{L_2}(E_2))$ <ul><li>集合运算中的交运算和并运算满足交换律和结合律</li><li>选择操作中有集合的运算时满足分配律(比如进行差运算再选择等价于分别选择再差运算)</li><li>投影操作中有并运算时满足分配律</li></ul></li><li>Join的顺序优化：当有若干张表需要join的时候，<strong>先从join后数据量最小的开始</strong> </li><li>可以通过共享相同的子表达式来减少表达式转化时的空间消耗，通过动态规划来减少时间消耗</li></ul></li></ul><h4 id="4-4-2-cost的估计"><a href="#4-4-2-cost的估计" class="headerlink" title="4.4.2 cost的估计"></a>4.4.2 cost的估计</h4><ul><li><p>基本的变量定义</p><ul><li>$n_r$ 表示关系r中元组的数量(也就是关系r的size)</li><li>$b_r$ 包含r中元组的block数量</li><li>$l_r$ r中一个元组的size</li><li>$f_r$ block factor of r 比如可以选取一个block能容纳的r中元组的平均数量</li><li>V(A, r) 关系r中属性A可能取到的不同的值的数量</li><li>当关系r中的元组都存储在一个文件中的时候 $b_r=\frac{n_r}{f_r}$ </li></ul></li><li><p>选择的估计</p><ul><li>从r中选择A属性=x的$cost = \frac{n_r}{V(A,r)}$ </li><li>选择A属性小于x的cost<ul><li>$cost=0$ if x &lt; min(A,r)</li><li>$cost=n_r\times \frac{x-min(A,r)}{max(A,r)-min(A,r)}$</li></ul></li><li>选择A属性大于x，和上面的表达式是对称的</li></ul></li><li><p>complex selection 多重选择</p><ul><li>假设$s_i$是满足条件$\theta_i$的元组的个数</li><li>conjunction $cost=n_r\times\frac{s_1\times s_2\times …\times s_n}{n_r^n}$</li><li>disjunction  $cost=n_r\times(1-(1-\frac{s_1}{n_r})\times…\times(1-\frac{s_n}{n_r}))$ </li><li>negation $cost=n_r-size(\delta_{\theta}(r))$ </li></ul></li><li><p>join 的估计</p><ul><li>笛卡尔积的情况下，关系R,S的join最终元组的个数为$n_r\times n_s$ </li><li>如果R∩S为空，则自然连接的结果和笛卡尔积的结果相同</li><li>如果非空，且R∩S是R的key，则R,S的自然连接最终结果中的元组个数不会超过r</li><li>如果R∩S的结果是S到R的外键，则最后的元组数和s中的元组数相同</li><li>一般情况 自然连接的最终结果的size估计值为$\frac{n_r\times n_s}{max(V(A,r),V(A,s))}$  </li></ul></li><li><p>其他操作的估计</p><ul><li><p>投影的size=V(A,r)</p></li><li><p>聚合操作的size=V(A,r)</p></li><li><p>集合操作：根据DNA里的高中数学知识自己编</p></li><li><p>外部连接：</p><ul><li>左外连接的size = 自然连接的size + r的size</li><li>右外连接的size = 自然连接的size + s的size</li><li>全连接的size = 自然连接的size + r的size + s 的size</li></ul></li><li><p>不同值个数的估计</p></li></ul></li><li><p>基于cost的join顺序优化</p><ul><li>n个关系进行自然连接有$\frac{(2n-2)!}{(n-1)!}$种不同的join顺序</li><li>找到最合适的join-tree的办法：递归地尝试,局部搜索的办法</li><li>Left Deep Join Trees左倾树，当结合方式只考虑左倾树的时候，找到最优解的时间复杂度是$O(n2^n)$ </li></ul></li><li><p><strong>Heuristic Optimization</strong> 探索式的优化</p><ul><li>尽早进行selection</li><li>尽早进行projection</li><li>选择最严格的selection和operations操作</li></ul></li><li><p>用于查询优化的结构</p><ul><li>pipelined evaluation plan</li><li>optimization cost budget</li><li>plan catching</li></ul></li></ul><h2 id="第五部分：事务处理"><a href="#第五部分：事务处理" class="headerlink" title="第五部分：事务处理"></a>第五部分：事务处理</h2><ul><li>这一部分感觉和操作系统关系比较密切</li></ul><h3 id="5-1-事务和并发控制"><a href="#5-1-事务和并发控制" class="headerlink" title="5.1 事务和并发控制"></a>5.1 事务和并发控制</h3><h4 id="5-1-1-基本的概念"><a href="#5-1-1-基本的概念" class="headerlink" title="5.1.1 基本的概念"></a>5.1.1 基本的概念</h4><ul><li><p>事务的概念</p><ul><li>事务时程序执行的基本单位，会引起一些数据项的更新，需要解决的两个问题：<ul><li>数据库系统的硬件问题和系统奔溃</li><li>多事务的并行执行</li></ul></li><li>事务开始和结束的时候数据库都必须是consistent的</li><li>事物的四个性质ACDI：<ul><li>事务的原子性 <strong>Atomicity</strong><ul><li>事务中的所有步骤只能完全执行(commit)或者回滚(rollback)</li></ul></li><li>事务的持久性 <strong>Durability</strong><ul><li>更新之后哪怕软硬件出了问题，更新的数据也必须存在</li></ul></li><li>事务的一致性 <strong>Consistency</strong></li><li>单独执行事务可以保持数据库的一致性</li><li>事务的独立性 <strong>Isolation</strong> <ul><li>事务在并行执行的时候不能感知到其他事务正在执行，执行中间结果对于其他并发执行的事务是隐藏的</li></ul></li></ul></li></ul></li><li><p>事务的状态</p><ul><li>active 初始状态，执行中的事务都处于这个状态</li><li>partially committed 在最后一句指令被执行之后</li><li>failed 在发现执行失败之后</li><li>aborted 回滚结束，会选择是<strong>重新执行事务</strong>还是结束</li><li>committed 事务被完整的执行</li></ul></li></ul><h4 id="5-1-2-事务的并发执行"><a href="#5-1-2-事务的并发执行" class="headerlink" title="5.1.2 事务的并发执行"></a>5.1.2 事务的并发执行</h4><ul><li>同时执行多个事务，可以提高运行的效率，减少平均执行时间<ul><li>并发控制处理机制：让并发的事务独立进行，控制并发事务之间的交流</li><li>Schedules 调度<ul><li>一系列用于指定并发事务的执行顺序的指令<ul><li>需要包含事务中的所有指令</li><li>需要保证单个事务中的指令的相对顺序</li></ul></li><li>事务的最后一步<ul><li>成功执行，最后一步是commit instruction</li><li>执行失败最后一步是abort instruction</li></ul></li><li>serial schedule 串行调度：一个事务调度完成之后再进行下一个</li><li>equivalent schedule 等价调度：改变处理的顺序但是和原来等价</li><li><strong>Serializability</strong>可串行化<ul><li>基本假设：事务不会破坏数据库的一致性，只考虑读写两种操作</li><li>冲突可串行化 conflict serializability<ul><li>同时读不引发冲突，而读写并行或者同时写会引发冲突</li><li><strong>conflict equivalent</strong>：两个调度之间可以通过改变一些不冲突的指令来转换，就叫做冲突等价</li><li><strong>conflict serializable</strong>：冲突可串行化：当且仅当一个调度S可以和一个串行调度等价</li><li><strong>Precedence graph</strong>  前驱图 <ul><li>图中的顶点是各个事务，当事务$T_i, T_j$ 冲突并且$T_i$ 先访问出现冲突的数据的时候，就画一条边$T_i\rightarrow T_j$ </li><li>一个调度是冲突可串行化的当且仅当前驱图是无环图</li><li>对于无环图，可以使用<strong>拓扑逻辑排序</strong>获得一个合适的执行顺序</li></ul></li></ul></li></ul></li><li>Recoverable Schedules 可恢复调度<ul><li>database must ensure that schedules are recoverable. 不然会出现dirty read</li><li>如果一个事务$T_1$要读取某一部分数据，而$T_2$要写入同一部分的数据，则$T_1$必须在$T_2$commit之前就commit，否则就会造成dirty read</li></ul></li><li><strong>Cascading Rollbacks</strong> 级联回滚<ul><li>单个事务的fail造成了一系列的事务回滚</li></ul></li><li><strong>Cascadeless Schedules</strong> 避免级联回滚的调度<ul><li>对于每一组事务a和b并且b需要读入一个a写入的数据，那么a必须在b的读操作开始之前commit</li><li><strong>Cascadeless Schedules</strong>也是可恢复的调度</li></ul></li></ul></li></ul></li></ul><h4 id="5-1-3-Concurrency-Control-并发控制"><a href="#5-1-3-Concurrency-Control-并发控制" class="headerlink" title="5.1.3 Concurrency Control 并发控制"></a>5.1.3 Concurrency Control 并发控制</h4><ul><li><p>Lock-Based Protocols 基于锁的协议</p><ul><li><p>lock是一种控制并发访问同一数据项的机制</p></li><li><p>两种lock mode </p><ul><li>exclusive(X) ：表示数据项可以读和写，用lock-X表示</li><li>shared(S) ：表示数据项只能读，用lock-S 表示</li></ul></li><li><p>两个事务的冲突矩阵：</p><table><thead><tr><th></th><th>S</th><th>X</th></tr></thead><tbody><tr><td>S</td><td>true</td><td>flase</td></tr><tr><td>X</td><td>false</td><td>false</td></tr></tbody></table><ul><li>如果请求的锁和其他事务对这个数据项已经有的锁不冲突，那么就可以给一个事务批准一个锁</li><li>对于一个数据项，可以有任意多的事务持有S锁，但是如果有一个事务持有X锁，其他的事务都不可以持有这个数据项的锁</li><li>如果一个锁没有被批准，就会产生一个请求事务，等到所有冲突的锁被release之后再申请 </li></ul></li></ul></li><li><p>锁协议中的特殊情况</p><ul><li><p>dead lock 死锁：两个事务中的锁互相等待造成事务无法执行，比如事务2的锁需要事务1先release，但是事务1的release步骤再事务2的申请锁后面，就会造成事务12的死锁</p></li><li><p>Starvation 饥荒：一个事务在等一个数据项的Xlock，一群别的事务在等他release，造成饥荒</p></li></ul></li><li><p>Two-Parse Locking Protocol 二阶段锁协议：确保冲突可串行化的调度</p><ul><li>两个阶段 growing和shrinking，growing只接受锁而不释放，shrinking反之</li><li>无法解决死锁的问题</li><li><strong>strict two-phase locking</strong><ul><li>每个事务都要保持所有的exclusive锁直到结束</li><li>为了解决级联回滚的问题</li></ul></li><li><strong>Rigorous two-phase locking</strong> <ul><li>所有的锁必须保持到事务commit或者abort</li></ul></li></ul></li><li><p>Lock Conversions锁转换：提供了一种将S锁升级为X锁的机制</p><ul><li>两个阶段<ul><li>第一个阶段可以设置S和X锁，也可以升级S锁</li><li>第二个阶段可以释放S和X锁，也可以降级X锁</li></ul></li><li>事务不需要显式调用所得请求，比如read和write的执行过程如下<ul><li>所有的锁在事务commit或者abort之后再被释放</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> Ti has a lock on Dthen <span class="token function">read</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span> <span class="token keyword">else</span>begin <span class="token keyword">if</span> necessary wait until no other  transaction has a lock<span class="token operator">-</span>X on Dgrant Ti a  lock<span class="token operator">-</span>S on D<span class="token punctuation">;</span><span class="token function">read</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> Ti has a  lock<span class="token operator">-</span>X on D     then           <span class="token function">write</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token keyword">else</span>    begin    <span class="token keyword">if</span> necessary wait until no other trans<span class="token punctuation">.</span> has any lock on D<span class="token punctuation">,</span>        <span class="token keyword">if</span> Ti has a lock<span class="token operator">-</span>S on D        then            upgrade lock on D  to lock<span class="token operator">-</span>X        <span class="token keyword">else</span>            grant Ti a lock<span class="token operator">-</span>X on D        <span class="token function">write</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span>    end<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>锁的实现：Lock Manager可以被作为一个独立的进程来接收事务发出的锁和解锁请求</p><ul><li>Lock Manager会回复申请锁的请求</li><li>发出请求的事务会等待请求被回复再继续处理</li><li>lock manager维护一个内存中的数据结构lock-table来记录已经发出的批准<ul><li>Lock table 是一个<strong>in-memory的hash表</strong></li><li>通过被上锁的数据项作为索引，黑框代表上锁，而白框表示在等待</li><li>新的上锁请求被放在队列的末端，并且在和其他锁兼容的时候会被授权上锁</li><li>解锁的请求会删除对应的请求，检查后面的请求是否可以被授权</li><li>如果一个事务aborts了，所有该事务的请求都会被删除</li><li>lock-manager会维护一个记录每个事务上锁情况的表来提高操作的效率</li></ul></li></ul></li><li><p>Deadlock prevention protocols 死锁保护协议，保证系统不会进入死锁</p><ul><li><p>predeclaration 执行之前先检查会不会出现死锁，保证一个事务开始执行之前对涉及到的所有的数据项都上锁</p></li><li><p>graph-based protocol：使用偏序来确定数据项上锁的顺序</p></li><li><p><strong>wait-die</strong> scheme 被动</p><ul><li>老的事务等待新事务释放，但是新的事务不等老的而是直接回滚</li></ul></li><li><p><strong>wound-wait</strong> scheme  主动</p><ul><li>老的事务强制让新的事务回滚而不等待其释放，新的事务会等老的事务结束</li></ul></li><li><p>Timeout-Based Schemes</p><ul><li>只等待一段时间，过了时间就回滚</li><li>容易实现，但是会导致starvation</li></ul></li><li><p>Deadlock Detection 死锁检测</p><ul><li>wait-for 图: 所有的事务表示图中的点，如果事务i需要j释放一个data item则图中画一条点i到点j的有向边，如果图中有环，说明系统存在一个死锁——跟前驱图很相似</li><li>死锁恢复<ul><li>total rollback 将事务abort之后重启</li><li>partial rollback 不直接abort而实仅回滚到能解除死锁的状态</li></ul></li><li>同一个事务经常发生死锁会导致starvation，因此避免starvation的过程中cost要考虑回滚的次数</li></ul></li></ul></li><li><p><strong>Multiple Granularity</strong> 多粒度</p><ul><li><p>允许数据项具有不同的大小，并定义数据粒度的层次结构，其中小粒度嵌套在大粒度中</p></li><li><p>可以用树形结构来表示</p></li><li><p>锁的粒度 (level in tree where locking is done)</p><ul><li>fine granularity(lower in tree) 高并发，高开销</li><li>coarse granularity(higher in tree) 低并发，低开销</li><li>最高等级的是整个DB</li><li>最低等级的是区域，文件和记录</li></ul></li></ul></li><li><p>扩展的Lock Modes</p><ul><li><p><strong>intention-shared</strong> (IS): indicates explicit locking at a lower level of the tree but only with shared locks.</p></li><li><p><strong>intention</strong>-exclusive (IX): indicates explicit locking at a lower level with exclusive or shared locks</p></li><li><p><strong>shared and intention</strong>-exclusive (SIX): the subtree rooted by that node is locked explicitly in shared mode and explicit locking is being done at a lower level with exclusive-mode locks.</p></li><li><p>冲突矩阵如下</p></li><li><p>这部分感觉不太像会考的样子，先不管了</p></li></ul></li></ul><h3 id="5-2-Recovery-System-事务恢复"><a href="#5-2-Recovery-System-事务恢复" class="headerlink" title="5.2 Recovery System 事务恢复"></a>5.2 Recovery System 事务恢复</h3><ul><li><p>故障的分类</p><ul><li>Transaction failure 事务错误：包含逻辑错误和系统错误，死锁属于系统错误</li><li>System crash 系统崩溃导致的故障(磁盘没出事)</li><li>Disk failure 磁盘中的问题导致磁盘存储被销毁</li></ul></li><li><p>恢复算法：保持数据库的一致性，事务的原子性和持久性</p><ul><li>在普通事务处理中要保证有足够的信息保证可以从故障中恢复</li><li>在故障发生之后要保持数据库的一致性，事务的原子性和持久性</li></ul></li><li><p>Data Access 数据访问回顾</p><ul><li>物理block是磁盘上的区分</li><li>缓冲block是在主存中的block</li><li>磁盘和主存之间的数据移动依赖input和output操作</li><li>每个事务$T_i$ 在内存中有自己的work-area，并且拷贝了一份该事务要用到的全部数据</li><li>事务通过read和write操作把数据在自己的工作区域和buffer blocks区间之间进行传递</li></ul></li><li><p>如何在事务failure的情况下仍然保证原子性</p><ul><li>先把数据存储在磁盘上，而不是直接存到数据库中</li><li>然后在提交点对数据库进行修改，如果发生错误就立马回滚<ul><li>但这个方法效率太低了，是世上没有被采用</li></ul></li></ul></li></ul><h4 id="5-2-1-log-based-Recovery基于日志的恢复"><a href="#5-2-1-log-based-Recovery基于日志的恢复" class="headerlink" title="5.2.1 log-based Recovery基于日志的恢复"></a>5.2.1 log-based Recovery基于日志的恢复</h4><ul><li><p>日志(log)被存储在稳定的存储中，包含一系列的日志记录</p><ul><li>事务开始<code>&lt;T start&gt;</code></li><li>写操作之前之前的日志记录<code>&lt;Ti,X,V1,V2&gt;</code>(X)是写的位置，V1，V2分别是写之前和之后的X处的值</li><li>事务结束的时候写入<code>&lt;Ti commit&gt;</code></li></ul></li><li><p>更新事务导致的不一致性</p><ul><li>新的数据在提交的时候不一定是安全的：错误发生时难以保护改变后的值不变</li><li>旧的数据在提交之前不一定是安全的：在commit之前发生错误将无法回滚到原来的值</li><li>对于更新事务的两条规则<ul><li>commit rule：新的数据在commit之前必须被写在<strong>非易失性</strong>的存储器中</li><li>logging rule：旧的值在新的写入之前需要被写在日志里</li></ul></li><li>日志中写入commit的时候视为一个事务被提交了，但此时buffer中可能还在进行write操作，因为log的写入先于操作</li></ul></li><li><p><strong>deferred database modification</strong> 延迟数据库更新：先把所有的更新写在日志里，在写入commit之后再开始写入数据库</p><ul><li>假设事务是串行执行的</li><li>事务开始的时候要写入<code>&lt;Ti start&gt;</code> </li><li> <strong>write</strong>(<em>X</em>) 操作对应的日志是 <code>&lt;Ti, X, V&gt;</code> ，V表示X新的值</li><li>事务partially commits的时候需要写入commit</li><li>然后根据日志来实际执行一些write的操作<ul><li>当错误发生时，当且仅当日志中start和commit都有的时候，事务需要redo</li></ul></li></ul></li><li><p><strong>immediate database modification</strong> 直接修改数据库</p><ul><li><p>先要写好日志记录，假设日志记录直接output到稳定的存储中</p></li><li><p>block的输出可以发生在任何时间点，包括事务commit前和commit后，block输出的顺序和write的顺序不一定相同</p></li><li><p>恢复的过程中有两种操作</p><ul><li>undo：撤回，将事务$T_i$ 中已经更新的值变回原本的值</li></ul></li><li><p>redo：从事务$T_i$ 的第一步开始重新做，将所有值设定为新的值</p><ul><li>两种操作都需要<strong>idempotent</strong>——也就是操作执行多次和执行一次的效果相同</li></ul></li><li><p>undo的条件：日志中包含这个事务的start而不包含commit，即事务进行到一半中断了</p><ul><li>redo的条件：日志中包含这个事务的start和commit</li></ul></li></ul></li><li><p>并行控制和恢复</p><ul><li>所有事务共用一个日志和disk buffer</li><li>基本的假设<ul><li>如果一个事务改变了某个数据项，其他的事务直到这个事务commit或者abort之前都不能改变这个数据项的值</li><li>没有commited的事务引起的更新不能被其他事务更新</li></ul></li><li>日志中不同事务的日志可能会相交</li></ul></li><li><p>check point</p><ul><li><p>通过定期执行checkpoint操作来完成简化的恢复</p><blockquote><p>1.将内存中的记录都写到稳定的存储中</p><p>2.将所有更改过的block写入磁盘中</p><p>3.写入日志记录&lt; **checkpoint** **L**&gt; ，其中L是一个在checkpoint时依然处于进行状态的事务</p></blockquote></li><li><p>通过checkpoint，在日志处理的时候就不需要处理所有的日志，只需要关注异常时正在活跃的事务，恢复的步骤如下</p><ul><li>从日志的末尾向前扫描，直到发现最近的checkpoint记录</li><li>只有L中记录的，或者在L之后发生的事务需要redo或者undo</li><li>checkpoint之前的记录已经生效并保存在了稳定的存储中</li></ul></li><li><p>日志中更早的部分<strong>或许需要</strong>undo，但一定不需要redo</p><ul><li>继续向前扫描直到发现一个事务的start日志</li><li>最早的start之前的日志不需要进行恢复操作，并且可以清除</li></ul></li><li><p>在上面这个图中 T1 ignored，T2，T3需要redo，T4 undo</p></li></ul></li><li><p>恢复算法</p><ul><li><p>单个事务回滚时的基本操作</p><ul><li>从后往前扫描，当发现记录$&lt;T_i,X_i,V_1,V_2&gt;$ 的时候</li><li>将X的值修改为原本的值</li><li>在日志的末尾写入记录$&lt;T_i,X_i,V_1&gt;$ </li><li>发现start记录的时候，停止扫描并在日志中写入abort记录</li></ul></li><li><p>恢复的两个阶段：redo和undo</p></li><li><p>redo需要先找到最后一个check point并且设置undo-list</p><blockquote><p>1.从checkpoint开始往下读</p><p>2.当发现修改值的记录的时候，redo一次将X设置为新的值</p><p>3.当发现start的时候将这个事务加入undo-list</p><p>4.当发现commit或者abort的时候将对应的事务从undo-list中移除</p></blockquote></li><li><p>undo</p><blockquote><p>1.从日志的末尾开始往回读</p><p>2.当发现记录 &lt;Ti, Xj,  V1,  V2&gt;并且Ti在undo-list中的时候，进行一次回滚</p><p>3.当发现Ti start并且Ti在undo-list中的时候，写入abort日志并且从undo-list中移除Ti</p><p>4.当undo-list空了的时候停止undo</p></blockquote></li></ul></li><li><p>log record buffering 缓冲日志记录</p><ul><li><p>日志记录一开始在主存的缓冲区中，当日志在block中满了的时候或者进行了log force操作(上面提到的checkpoint)时写入稳定的存储中</p></li><li><p>需要遵守的规则</p><ul><li>写入稳定存储中的时候日志记录按照原本的顺序写入<ul><li>在commit记录被写入稳定存储的时候，Ti才算进入commit状态</li></ul></li><li>WAL(write-ahead logging)规则：在数据block写入数据库之前，必须先把日志写入稳定的存储中</li></ul></li><li><p>中间有几页先留着慢慢学习，这几页看起来不太像考试内容，buffer这一部分应该了解就好</p></li></ul></li></ul><h4 id="5-2-2-ARIES-Recovery-Algorithm——Aries恢复算法"><a href="#5-2-2-ARIES-Recovery-Algorithm——Aries恢复算法" class="headerlink" title="5.2.2 ARIES Recovery Algorithm——Aries恢复算法"></a>5.2.2 ARIES Recovery Algorithm——Aries恢复算法</h4><ul><li><p>和普通恢复算法的区别：</p><ul><li>最核心的区别——Aries算法考试考到的概率很高</li><li>使用LSN(log sequence number)来标注日志<ul><li>以页的形式来存储LSN来标注数据库页表中进行了哪些更新</li></ul></li><li>生理redo(?)</li><li>使用脏页表(dirty page table) 来避免不必要的redo</li><li>模糊的checkpoint机制，只记录脏页信息和相关的信息，不需要把脏页写入磁盘</li></ul></li><li><p>ARIES中的数据结构</p><ul><li>Log sequence number (LSN) <ul><li>用于标识<strong>每一条记录</strong>，需要是线性增长的</li><li>其实是一个offset，方便从文件的起点开始访问</li></ul></li><li><strong>Page LSN</strong> 每一页的LSN<ul><li>是每一页中<strong>最后一条</strong> <strong>起作用</strong>的日志记录的LSN编号</li><li>每当一个更新的操作在某一页发生的时候，Page LSN就变成对应的Page LSN</li><li> 在恢复的撤销阶段，LSN值不超过PageLSN的日志记录将<strong>不会在该页上执行</strong>，因为其动作已经在该页上了</li><li>可以避免重复的redo</li></ul></li><li>log record 日志记录<ul><li>每一条日志记录包含自己的LSN和<strong>同一个事务中前一步操作</strong>的LSN——PreLSN</li><li>CLR：在恢复期间不需要undo，是redo-only的日志记录<ul><li>有一个UndoNextLSN区域用于记录下一个(更早,往前搜索)的需要undo的记录</li><li>在这之间的记录应该早就已经undo了</li></ul></li></ul></li><li>Dirty Page Table 脏页表<ul><li>存储在缓冲区的，记录已经被更新过的page的表</li><li>包含以下内容<ul><li>每个页的PageLSN</li><li>每个页的RecLSN，表示这一页的日志记录中，LSN在这之前的记录已经<strong>都被写入磁盘中</strong>了<ul><li>当page被插入脏页表的时候，<strong>初始化为当前的PageLSN</strong> </li><li>记录在checkpoint中，用于减少redo的次数</li></ul></li></ul></li><li>只要页被写入磁盘，就从脏页表中移除该页</li></ul></li><li>checkpoint处的日志记录<ul><li>包含：脏页表和当前活跃的所有事务</li><li>对每一个活跃的事务，记录了LastLSN，即这个事务在日志中写下的<strong>最后一条记录</strong> </li><li>在checkpoint的时间点，脏页的信息不会写入磁盘</li></ul></li></ul></li><li><p>ARIES算法的恢复操作</p><ul><li><p>分为三个阶段：分析阶段，redo阶段和undo阶段</p><ul><li>RedoLSN 记录了从哪一条开始需要redo</li></ul></li><li><p>分析阶段：需要决定哪些事务undo，哪些页是脏页</p><ul><li><p>从<strong>最后一条完整的checkpoint日志记录</strong>开始</p></li><li><p>读取脏页表的信息</p><ul><li>设置RedoLSN = min RecLSN(脏页表中的)，如果脏页表是空的就设置为checkpoint的LSN</li><li>设置undo-list：checkpoint中记录的事务</li><li>读取undo-list中每一个事务的最后一条记录的LSN</li></ul></li><li><p>从checkpoint开始正向扫描</p><ul><li>如果发现了不在undo-list中的记录就写入undo-list</li><li>当发现一条<strong>更新记录</strong>的时候，如果这一页<strong>不在脏页表</strong>中，用该记录的LSN作为RecLSN写入脏页表中</li><li>如果发现了标志事务<strong>结束</strong>的日志记录(commit, abort) 就从undo-list中<strong>移除</strong>这个事务</li><li>搜索直到undo-list中的每一个事务都到了最后一条</li></ul></li><li><p>分析结束之后</p><ul><li>RedoLSN决定了从哪里开始redo</li><li>所有undo-list中的事务都需要回滚</li></ul></li></ul></li><li><p>Redo阶段</p><ul><li>从RedoLSN开始<strong>正向扫描</strong>，当发现更新记录的时候<ul><li>如果这一页不在脏页表中。或者这一条记录的LSN小于页面的RecLSN就忽略这一条</li><li>否则从磁盘中读取这一页，如果磁盘中得到的这一页的PageLSN比这一条要小，就redo，否则就忽略这一条记录</li></ul></li></ul></li><li><p>Undo阶段</p><ul><li>从日志末尾先前向前搜索，undo所有undo-list中有的事务</li><li>符合如下条件的记录可以<strong>跳过</strong> <ul><li>用分析阶段的最后一个LSN来找到每个日志最后的记录</li><li>每次选择一个最大的LSN对应的事务undo</li><li>在undo一条记录之后<ul><li>对于普通的记录，将NextLSN设置为PrevLSN</li><li>对于CLR记录，将NextLSN设置为UndoNextLSN</li></ul></li></ul></li><li>如何undo：当一条记录undo的时候<ul><li>生成一个包含执行操作的CLR</li><li>设置CLR的UndoNextLSN 为更新记录的LSN</li></ul></li></ul></li><li><p>Aries算法的其他特性</p><ul><li>Recovery Independence 恢复的独立性</li><li>Savepoints 存档点</li><li>Fine-grained locking 细粒度的锁</li><li>Recovery optimizations 恢复的优化</li></ul></li></ul></li></ul><h2 id="第六部分-XML"><a href="#第六部分-XML" class="headerlink" title="第六部分 XML"></a>第六部分 XML</h2><h4 id="6-1-XML的定义和基本结构"><a href="#6-1-XML的定义和基本结构" class="headerlink" title="6.1 XML的定义和基本结构"></a>6.1 XML的定义和基本结构</h4><ul><li>XML：Extensible Markup Language 一种可扩展的标记语言<ul><li>区别于HTML(Hyper-Text Markup Language)</li><li>XML可以有任意名称的标记，HTML的标记名是有限的</li><li>XML已经成为一种信息交互的基本结构，适合数据库之间的交互</li></ul></li><li>XML的结构<ul><li>Tag 标签，表明一种数据类型</li><li>Element 被标签所括起来的内容，正确的格式应该是<code>&lt;tag&gt;element&lt;/tag&gt;</code> <ul><li>标签必须要正确嵌套，可以嵌套是XML相比于关系代数的优势</li></ul></li><li>XML文档需要有一个root</li><li>一个元素可以有多个<strong>属性</strong>，但是<strong>属性名不能重复</strong>，用<code>attr_name=value</code>的形式内嵌在起始tag上面</li><li>命名空间namespaces<ul><li>同一个标签名在不同的地方可能代表不同的意思，需要在tag前面加上<code>namespace:</code>标识这个tag是被谁定义的</li></ul></li><li>没有子元素的元素可以只用一个tag标识：<code>&lt;tag /&gt;</code> </li><li>当tag表示字符串时可以用<code>CDATA[ ]</code> 括起来表示</li></ul></li></ul><h4 id="6-2-XML-Document-Schema"><a href="#6-2-XML-Document-Schema" class="headerlink" title="6.2 XML Document Schema"></a>6.2 XML Document Schema</h4><ul><li><p>Document Type Definition (DTD) 使用较为广泛，定义了XML文档结构的一种标准</p><ul><li><p><strong>不限制数据的种类</strong>，标签不预先规定有多少种，可以自由定义，但是限制XML中数据的结构</p><ul><li>有什么元素可以出现</li><li>元素必须有哪些属性</li><li>每个元素中可以出现哪些子元素</li></ul></li><li><p>基本的语法结构 </p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;!ELEMENT element (subelements-specification) &gt;&lt;!ATTLIST element (attributes) &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>子元素可以声明为</p><ul><li>子元素的名称</li><li><code>#PCDATA(parsed character data)</code> 被解析的字符数据</li><li>EMPTY 或者 ANY 表示没有子元素或者任何东西都可以作为子元素</li></ul></li><li><p>子元素的声明可以使用<strong>正则表达式</strong> </p><ul><li>“ | ” 表示可以互相替代</li><li>“ + ” 至少出现一个</li><li>“ * ” 出现0个或多个</li><li>“ ？” 不出现或者出现一个</li></ul></li><li><p>比如说下面这一段</p><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;!DOCTYPE note [  &lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!ELEMENT to      (#PCDATA)&gt;  &lt;!ELEMENT from    (#PCDATA)&gt;  &lt;!ELEMENT heading (#PCDATA)&gt;  &lt;!ELEMENT body    (#PCDATA)&gt;]&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这一段DTD中，第一行表示文档类型叫note，里面有若干个元素，其中note元素有四个子元素，都是被解析的字符数据</li></ul></li></ul></li><li><p>Attribute声明，对每一个属性，声明</p><ul><li><p>属性名name</p></li><li><p>属性种类type</p><ul><li>CDATA</li><li>ID or IDREF(id的索引) or IDREFS(多重id索引)<ul><li>每个元素最多一个属性作为ID，并且必须是不同的值</li><li>IDREF类型的属性必须包含ID的值</li></ul></li><li>其他内容<ul><li> <code>#REQUIED</code> 属性是必须的</li><li>是否有默认值</li><li><code>#IMPLIED</code>属性不是必须的</li></ul></li></ul><pre class="line-numbers language-xml-dtd" data-language="xml-dtd"><code class="language-xml-dtd">&lt;!ATTLIST course course_id CDATA #REQUIRED&gt;, 或者&lt;!ATTLIST course    course_id     ID          #REQUIRED        dept_name  IDREF   #REQUIRED    instructors    IDREFS #IMPLIED   &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>DTD的一些限制</p><ul><li>元素和属性没有类型</li><li>IDs和IDREFs是untyped，每个元素的ID属性值必须是唯一的</li></ul></li></ul></li><li><p>XML Schema——不常用</p><ul><li>解决了DTD的缺点，更复杂，支持<ul><li>值的类型，包括integer，string等</li><li>用户定义类型，更复杂的类型</li><li>更多功能包括 unique和foreign key的限制</li><li>但比DTD模式更加冗余</li></ul></li><li>语法规则<ul><li>可以使用xs的namespace</li><li>属性被xs:attribute的tag所定义</li><li>键约束， 外键约束：通过xpath进行查询</li></ul></li></ul></li></ul><h4 id="6-3-XML-查询"><a href="#6-3-XML-查询" class="headerlink" title="6.3 XML 查询"></a>6.3 XML 查询</h4><ul><li><p>XML 数据的查询和传输</p><ul><li><p>可以用于XML查询和传输的语言</p><ul><li>XPath</li><li>XSLT</li><li>XQuery</li></ul></li><li><p>查询和交换基于XML的<strong>树模型</strong></p><ul><li>树模型中的节点是XML文档中的元素，节点分为元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点，元素下的节点是属性或者子元素，上面的则是父元素</li><li>根节点只有一个儿子，就是XML文档的根元素</li></ul></li><li><p>XPath </p><ul><li>用类似于文件路径的表达式来进行查询，用斜杠进行连接</li><li>第一个斜杠的意思表示根目录，路径中<strong>可以添加查询条件</strong>，需要用<code>[]</code>括起来<ul><li>比如<code>//title[@lang]</code> 可以选取所有拥有属性名lang的元素title</li><li>比如<code>/bookstore/book[1]</code> 表示选取bookstore下面第一个查询到的book元素</li></ul></li><li>访问<strong>属性</strong>需要使用<code>@</code>标记(注意标签的属性和值的区别)</li><li>可以使用通配符来查询：<ul><li>*可以表示所有的元素节点，比如<code>//*</code>  可以获取文档中的所有元素</li><li>@*可以表示所有的属性节点</li></ul></li><li>可以用 | 来连接两个查询</li></ul></li><li><p><code>//</code> 可以跳过多层node直奔要找的目标</p><ul><li>查询路径不仅能往下查询，也可以往上查询，既可以搜索子节点，也可以搜索父节点</li></ul></li><li><p>XPath中提供了一些可以使用的函数</p><ul><li>count函数可以用来计算某个路径下的元素个数，比如<code>/university-2/instructor[count(./teaches/course)&gt; 2]</code> 可以表示获取所有上课数目超过2的老师</li><li>布尔函数and和or和not() 可以使用</li><li>IDREFs可以使用id()引用</li></ul></li><li><p>使用doc来返回文档的名称</p></li><li><p>XQuery：XML文档的信息查询</p><ul><li>XQuery使用的语法是<ul><li><code>for xxx let xxx where xxx order by xxx return</code></li><li>for相当于SQL中的<code>select</code>，let允许使用<strong>临时变量</strong> </li></ul></li><li>一个简单的案例，对<code>&lt;course_id&gt;..&lt;/course_id&gt;</code>中的内容进行查询</li></ul><pre class="line-numbers language-xquery" data-language="xquery"><code class="language-xquery">  <span class="token keyword">for</span> <span class="token variable">$x</span> <span class="token keyword">in</span> <span class="token punctuation">/</span>university<span class="token punctuation">/</span>course  <span class="token keyword">let</span> %courseid<span class="token operator">:=</span><span class="token variable">$x</span><span class="token punctuation">/</span><span class="token operator">@</span>course_id<span class="token keyword">where</span> <span class="token variable">$x</span><span class="token punctuation">/</span>credits <span class="token operator">></span> <span class="token number">3</span>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>course_id</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token variable">$courseid</span><span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>course_id</span><span class="token punctuation">></span></span>    <span class="token punctuation">/</span><span class="token punctuation">/</span> 可以进行如下的化简  <span class="token keyword">for</span> <span class="token variable">$x</span> <span class="token keyword">in</span> <span class="token punctuation">/</span>university-<span class="token number">3</span><span class="token punctuation">/</span>course<span class="token punctuation">[</span>credits <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">]</span>     <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>course_id</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> <span class="token variable">$x</span><span class="token punctuation">/</span><span class="token operator">@</span>course_id <span class="token punctuation">&#125;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>course_id</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>join操作：在where后面用逻辑关系连接若干个条件</li><li>嵌套查询：用法是将一个XQeury语句当作return的结果用tags包起来</li><li>聚合操作 可以使用sum等聚合函数，比如<code>fu:sum()</code></li><li>使用order by进行排序</li><li>可以使用自定义函数来进行某些操作</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS核心课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
